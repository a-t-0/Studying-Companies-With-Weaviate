{
    "data": {
        "Get": {
            "WebPage": [
                {
                    "_additional": {
                        "summary": [
                            {
                                "property": "webPageMainText",
                                "result": "Weaviate 1.24 is here! Here are the release highlights. Named vectors make your collections richer and more versatile. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata."
                            }
                        ]
                    },
                    "url": "https://weaviate.io/blog/weaviate-1-24-release#backend-improvements",
                    "webPageMainText": "Weaviate 1.24 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nNamed vectors make your collections richer and more versatile.\nStarting in 1.24, collections can have multiple named vectors. Each vector is independent. Each vector has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to fine tune interactions with your data.\nIn earlier versions, objects in your collections are limited to one vector. Now, you can vectorize meta data like titles and descriptions so that it is available for vector search. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata. A single object in a collection can have multiple named vectors.\nYou don't have to use multiple vectors in your collections, but if you do, adjust your queries to specify which vector you want to"
                },
                {
                    "_additional": {
                        "summary": [
                            {
                                "property": "webPageMainText",
                                "result": "This section includes reference guides for reader & generator modules, such as the QA module, NER module and the Summarization module. This section includes guide guides for QA and NER modules, as well as other modules. The guide also includes guides for the NER and Summarizing modules."
                            }
                        ]
                    },
                    "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules",
                    "webPageMainText": "This section includes reference guides for reader & generator modules, such as the QA module, NER module and the Summarization module.\n"
                },
                {
                    "_additional": {
                        "summary": [
                            {
                                "property": "webPageMainText",
                                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
                            }
                        ]
                    },
                    "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#enable-pq-compression",
                    "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
                },
                {
                    "_additional": {
                        "summary": [
                            {
                                "property": "webPageMainText",
                                "result": "The Concepts section explains various aspects related to Weaviate and its architecture. You can read these sections in any order. If you are after a practical guide, try the quickstart tutorial. The figure below gives a 30,000 feet view of Weaviates architecture."
                            }
                        ]
                    },
                    "url": "https://weaviate.io/developers/weaviate/concepts#weaviate-architecture",
                    "webPageMainText": "The Concepts section explains various aspects related to Weaviate and its architecture to help you get the most out of it. You can read these sections in any order.\nIf you are after a practical guide, try the quickstart tutorial.\nData structure\nModules\nIndexing\nVector indexing\nVector quantization\nThe figure below gives a 30,000 feet view of Weaviate's architecture.\n\nYou can learn more about the individual components in this figure by following these guides:\nLearn about storage inside a shard\nWays to scale Weaviate horizontally\nHow to plan resources\nFiltered vector search\nUser-facing interfaces\nReplication architecture\nIf you have any questions or feedback, let us know in the user forum. \n"
                },
                {
                    "_additional": {
                        "summary": [
                            {
                                "property": "webPageMainText",
                                "result": "In this unit, you learned about additional types of queries, including keyword (BM25), hybrid, generative and QnA searches. Combined with the tools that you learned earlier in Queries 1, you are now armed with a variety of search tools. Each of these tools allow you to interrogate the data differently."
                            }
                        ]
                    },
                    "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_2/wrap_up",
                    "webPageMainText": "In this unit, you learned about additional types of queries, including keyword (BM25), hybrid, generative and QnA searches. Combined with the tools that you learned earlier in Queries 1, you are now armed with a variety of search tools.\nEach of these tools allow you to interrogate the data differently. Being aware of how each type works will allow you to formulate the right query for your tasks.\nBM25 searches for example can be used for precise keyword searches, and a hybrid search allows you to combine results of both BM25 and vector searches. Meanwhile, generative searches and QnA searches transform your data before it is delivered to the user. These searches leverage the power of language models, bringing your data to life and allowing Weaviate to go further than simple data retrieval.\nHaving finished this unit, you should be able to:\nIf you have any questions or feedback, let us know in the user forum. \n"
                }
            ]
        }
    }
}