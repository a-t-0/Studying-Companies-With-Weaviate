{
  "data": {
    "Get": {
      "WebPage": [
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Sydney Opera House is one of the most famous buildings in the world. It was designed by Danish architect J\u00f8rn Utzon in the 1950s. The Opera House was officially opened by Queen Elizabeth II on 20 October 1973. It is now one of Australia's most popular tourist attractions."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/theory/hello_weaviate/examples_2",
          "webPageMainText": "You can do a lot more with Weaviate than simply retrieve static information.\nLet's take a look at a couple of examples where we do more than simply retrieve objects from the database.\nWe will extract information from this Wikipedia entry.\nThe Sydney Opera House is a multi-venue performing arts centre in Sydney. Located on the foreshore of Sydney Harbour, it is widely regarded as one of the world's most famous and distinctive buildings and a masterpiece of 20th-century architecture. Designed by Danish architect J\u00f8rn Utzon, but completed by an Australian architectural team headed by Peter Hall, the building was formally opened by Queen Elizabeth II on 20 October 1973 after a gestation beginning with Utzon's 1957 selection as winner of an international design competition. The Government of New South Wales, led by the premier, Joseph Cahill, authorised work to begin in 1958 with Utzon directing construction. The government's decision to build Utzon's design is often overshadowed by circums"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#manually-configure-pq",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue. Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/filters#by-property-length",
          "webPageMainText": "Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion. The operator used for filtering is also called a where filter.\nA filter may consist of one or more conditions, which are combined using the And or Or operators. Each condition consists of a property path, an operator, and a value.\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\nFor example, this filter will only allow objects from the class Article with a wordCount that is GreaterThan than 1000.\nThe where filter is an algebraic object, which takes the following arguments:\nIf the operator is And or Or, the operands are a list of where filters.\nWeaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue.\nThe behavior for the Equal operator on multi-word textual properties in where filters depends on the tokenization of the property.\nSee the Schema p"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a search engine that uses inverted indices to store data and values. Data is stored as vectors, which enables semantic search. This combination of data storage is unique, and enables fast, filtered and semantic search from end-to-end. Weaviate comes containerized to make it easier for others to build their own systems."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/faq#q-how-do-i-get-the-cosine-similarity-from-weaviates-certainty?",
          "webPageMainText": "Our goal is three-folded. Firstly, we want to make it as easy as possible for others to create their own semantic systems or vector search engines (hence, our APIs are GraphQL based). Secondly, we have a strong focus on the semantic element (the \"knowledge\" in \"vector databases,\" if you will). Our ultimate goal is to have Weaviate help you manage, index, and \"understand\" your data so that you can build newer, better, and faster applications. And thirdly, we want you to be able to run it everywhere. This is the reason why Weaviate comes containerized.\nOther database systems like Elasticsearch rely on inverted indices, which makes search super fast. Weaviate also uses inverted indices to store data and values. But additionally, Weaviate is also a vector-native search database, which means that data is stored as vectors, which enables semantic search. This combination of data storage is unique, and enables fast, filtered and semantic search from end-to-end.\nYes, we do - check out Weaviate"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "There are currently four clients developed for Weaviate's APIs. These clients, and all future clients are and will be developed according to the following guidelines: It is more important that a client feels native todevelopers used to a specific language than it is to have all clients exactly the same."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-clients",
          "webPageMainText": "There are currently four clients developed for Weaviate's APIs:\nThese clients, and all future clients are and will be developed according to the following guidelines:\nAs a rule of thumb it is more important that a client feels native to\ndevelopers used to a specific language than it is to have all clients exactly\nidentical. When developers make their first contact with a Weaviate client,\nthey should think \"This feels like proper Java [Go/Python/JavaScript...]\", as\nopposed to \"I guess it was designed like this to be consistent with other\nlanguage clients\". Therefore you should design clients in a way that feels\nnative to those with experience in that language.\nThis can also mean that specific patterns deviate from one client to another.\nFor example, python has keyword arguments next to positional arguments. This\nmakes it easy to add optional arguments with defaults. Golang, on the other\nhand, has a fixed set of arguments per function call making it much better\nsuited for a builder patte"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn about why you need distance metrics in vector search and the metrics implemented in Weaviate (Cosine, Dot Product, L2-Squared, Manhattan, and Hamming) Learn about our latest open source demo and how we used Semantic and Generative Search to improve access to health data."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/concepts/page/2",
          "webPageMainText": "Learn about new trends in RAG evaluation and the current state of the art.\nFine-tuning LlaMA 7B to use the Weaviate GraphQL APIs\nHow hybrid search works, and under the hood of Weaviate's fusion algorithms.\nLearn about why you need distance metrics in vector search and the metrics implemented in Weaviate (Cosine, Dot Product, L2-Squared, Manhattan, and Hamming).\nVector databases explained by their core concepts of vector embeddings, vector search, and vector indexing\nLearn about our latest open source demo and how we used Semantic and Generative Search to improve access to health\nML Models that can see, read, hear and more!\nLearn about the new native multi-tenancy feature\nLearn about the intersection between LLMs and Search\nA discussion on data privacy and privacy-preserving machine learning for LLMs\nVideos on authentication: an overview, how to log in, how to set it up, and core concepts - including recommendations.\nLearn about how to monitor Weaviate in production and observe key metr"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The live endpoint checks if the application is alive. You can use it for a Kubernetes liveness probe. The discovery endpoint accepts a GET request. If OpenID Connect (OIDC) authentication is enabled, the endpoint returns configuration details. If there is no OIDC provider, the Endpoint returns a 404 status code."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/well-known",
          "webPageMainText": "If OpenID Connect (OIDC) authentication is enabled, the endpoint returns configuration details.\nIf a token is configured, the endpoint redirects to it.\nThe discovery endpoint accepts a GET request:\nIf there is an OIDC provider, the endpoint returns the following fields:\nIf there is no OIDC provider, the endpoint returns a 404 HTTP status code.\nIf OIDC is configured, the endpoint returns a document like this:\nThe live endpoint checks if the application is alive. You can use it for a Kubernetes liveness probe.\nThe endpoint accepts a GET request:\nThe endpoint returns HTTP status code 200 if the application is able to respond to HTTP requests.\nThe endpoint returns HTTP status code 200 if the application is able to respond to HTTP requests.\nThe ready endpoint checks if the application is ready to receive traffic. You can use it for Kubernetes readiness probe.\nThe discovery endpoint accepts a GET request:\nThe endpoint returns HTTP status code 200 if the application is able to respond to HTTP"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.24 is here! Here are the release highlights. Named vectors make your collections richer and more versatile. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/release_1_24",
          "webPageMainText": "Weaviate 1.24 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nNamed vectors make your collections richer and more versatile.\nStarting in 1.24, collections can have multiple named vectors. Each vector is independent. Each vector has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to fine tune interactions with your data.\nIn earlier versions, objects in your collections are limited to one vector. Now, you can vectorize meta data like titles and descriptions so that it is available for vector search. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata. A single object in a collection can have multiple named vectors.\nYou don't have to use multiple vectors in your collections, but if you do, adjust your queries to specify which vector you want to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Inclusive culture is good for business and good for people. Inclusive culture allows people with different backgrounds to be heard. It also encourages people to share their views. Inclusion is key to the success of a business or business in the long run. It is also good for the community."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/creating-an-inclusive-culture-in-remote-work-settings",
          "webPageMainText": "\nWorking in a company with an inclusive culture is important and it\u2019s good for business, too.\nInclusive workplaces enable and encourage employees with different personalities, values, perspectives, and cultural backgrounds to coexist and thrive. In turn, employees who feel welcome, respected as unique individuals, who feel heard, and that they belong are more engaged and productive, and more likely to stick around. That\u2019s exactly what I want to achieve at Weaviate.\nHowever, inclusive workplaces don\u2019t simply happen, nor can they be wished into existence. In a previous job, I worked for a large company based in the Netherlands; my department - that was part of the head office - had hubs in several other European countries. Some of those satellite locations had been part of our department for years. And yet, I came to realize that the people who worked in those locations felt left out, maybe even less important. Even though we were part of a global company, my department saw lots of thing"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Dynamic indexing is an experimental feature. Use with caution."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/vector-index#pq-configuration-parameters",
          "webPageMainText": "Vector indexes facilitate efficient, vector-first data storage and retrieval.\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nAvailable starting in v1.25. Dynamic indexing is an experimental feature. Use with caution.\nUse these parameters to configure the index type and their properties. They can be set in the collection configuration.\nGenerally, the hnsw index type is recommended for most use cases. The flat index type is recommended for use cases where the data the number of objects per index is low, such as in multi-tenancy cases."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integration with Google AI Studio and Google Vertex AI. Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the Google AI generative model to generate outputs. This integration is enabled by default on Weaviates Cloud (WCD) serverless instances."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/google/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Google AI Studio and Google Vertex AI APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use a Google AI generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model and your Google AI API key.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the Google AI generative model to generate outputs.\n\nAt the time of writing (November 2023), AI Studio is not available in all regions. See this page for the latest information.\nYour Weaviate instance must be configured with the Google AI generative AI integration (generative-palm) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide valid API credentials to Weaviate for"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate offers a variety of tokenization options to choose from. These options allow you to configure how keyword searches and filters are performed in Weaviate for each property. The main options are: word tokenization, lowercase and whitespace. Let's explore each of these options in more detail, including how they work."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/tokenization/options",
          "webPageMainText": "Weaviate offers a variety of tokenization options to choose from. These options allow you to configure how keyword searches and filters are performed in Weaviate for each property.\nThe main options are:\nLet's explore each of these options in more detail, including how they work and when you might want to use them.\nThe word tokenization method splits the text by any non-alphanumeric characters, and then lowercases each token.\nHere are some examples of how the word tokenization method works:\nThe word tokenization is the default tokenization method in Weaviate.\nGenerally, if you are searching or filtering \"typical\" text data, word tokenization is a good starting point.\nBut if symbols (such as &, @ or _) are important to your data and search, or distinguishing between different cases is important, you may want to consider using a different tokenization method such as lowercase or whitespace.\nThe lowercase tokenization method splits the text by whitespace, and then lowercases each token.\nHe"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Azure OpenAI's APIs allows you to access their models' capabilities directly from Weaviate. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances. You must provide a valid Azure Open AI API key to Weaviated for this integration."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/openai-azure/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Azure OpenAI's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use an Azure OpenAI generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model and your Azure OpenAI API key.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the Azure OpenAI generative model to generate outputs.\n\nYour Weaviate instance must be configured with the Azure OpenAI generative AI integration (generative-openai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Azure OpenAI API key to Weaviate for this integration. Go to Azure OpenAI to sign up and obtain an API key.\nProvide the API key to Weaviate using one of the follo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This is a preview version of this unit. Some sections are not yet complete - such as videos and quiz questions. Please check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.We have covered a lot of ground on chunking in this unit already. We will take a step back out from the detailed, micro view to the high level, macro view."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking/considerations",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nWe have covered a lot of ground on chunking in this unit already.\nYou saw what chunking is and learned about different chunking methods, and dived into example implementations so that you can see their impact.\nIn this section, we will take a step back out from the detailed, micro view to the high level, macro view, while using all that we've learned in context. More specifically, we will take a look at some considerations of what to think about when chunking data, and what it means for your Weaviate implementation.\nAs you have seen, there are many different ways to chunk data. But which one is right for you?\nThe answer is, as always, \"it depends\". But here are some things to consider when choosing a chunking method:\nHow much text should each \"hit"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.22 is already available on Weaviate Cloud - so try it out! Nested properties let you work with an address value that has number, street, and city` properties of its own. Object and object[] join the available list of data types."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/release_1_22#asynchronous-vector-indexing-experimental",
          "webPageMainText": "Weaviate 1.22 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f relating to this release:\n\n1.22 is already available on Weaviate Cloud - so try it out!\nFor more details, keep scrolling \u2b07\ufe0f!\n\n1.22 welcomes new members to the Weaviate data type family, with object and object[] joining the available list.\nThis allows you to store nested objects directly in Weaviate as property values. In other words, you can store them without having to flatten the object or use cross-references to other Weaviate classes.\nThis is particularly useful for storing data that is not easily represented in a flat structure. For example, nested properties let you work with an address value that has number, street, and city` properties of its own.\nAn example class definition is shown below, where a Nested class has a parent property with an object datatype. Because the parent property is an object, it can have its own properties (nestedProperties), such as child in this example, which is a text datatype.\nAn example obje"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Culture is how employees' hearts and stomachs feel about Monday morning on Sunday night. Bill Marklein is head of people and culture at Weaviate. Marklein: Culture is so central to our business that it deserved some time to think about and reflect on this."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/from-sunday-nights-blues-to-monday-morning-cheers-the magic-of-company-culture",
          "webPageMainText": "\nI have wanted to write a blog about the topic of culture for a very long time now. Because - first of all - I find it a fascinating topic. How do you explain culture, how do you put a feeling into words? And second of all, how do you build and scale culture? \n\"Culture is how employees' hearts and stomachs feel about Monday morning on Sunday night.\" \u2014 Bill Marklein\nIn my role as head of people and culture at Weaviate, I often find myself talking about creating and sustaining a strong company culture. During interviews, candidates ask, \u201cWhat do you do to create or foster a strong culture?\u201d And at other times, friends and people I talk with \u2013 who are not familiar with the people & culture space \u2013 ask what I actually do.\nThese are very good questions, and since Weaviate\u2019s culture is so central to our business (strategy), it deserved some time to think about and reflect on this. Because it\u2019s pretty hard to really get to the core of culture in a few words or to define specific tasks or proj"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "CNN.com will feature iReporter photos in a weekly Travel Snapshots gallery. Please submit your best shots of the U.S. for next week. Visit CNN.com/Travel each week for a new gallery of snapshots. Visit http://www.dailymail.co.uk/travel/features/travellers-take-pictures-of-the-united-kingdom.html#storylink=cpy. We'll feature some of the best shots in next week's gallery."
              }
            ]
          },
          "url": "https://weaviate.io/developers/tags/google-cloud-marketplace",
          "webPageMainText": "Overview\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " vector databases use Machine Learning models to offer incredible functionality to operate on your data. These use cases require Machine Learning model inference \u2013 a process of running data through an ML model and calculating an output. There are companies \u2013 like Hugging Face, OpenAI, and Cohere \u2013 that offer running model inference as a service."
              }
            ]
          },
          "url": "https://weaviate.io/blog/hugging-face-inference-api-in-weaviate",
          "webPageMainText": "\nVector databases use Machine Learning models to offer incredible functionality to operate on your data. We are looking at anything from summarizers (that can summarize any text into a short) sentence), through auto-labelers (that can classify your data tokens), to transformers and vectorizers (that can convert any data \u2013 text, image, audio, etc. \u2013 into vectors and use that for context-based queries) and many more use cases.\nAll of these use cases require Machine Learning model inference \u2013 a process of running data through an ML model and calculating an output (e.g. take a paragraph, and summarize into to a short sentence) \u2013 which is a compute-heavy process.\nRunning model inference in production is hard.\nThe good news is, there are companies \u2013 like Hugging Face, OpenAI, and Cohere \u2013 that offer running model inference as a service.\n\"Running model inference in production is hard,\nlet them do it for you.\"\nStarting from Weaviate v1.15, Weaviate includes a Hugging Face module, which provide"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate can be accessed using the Python client library. You can check whether the Weaviate instance is up using the is_live function. We will not include the try-finally blocks in the remaining code snippets. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/setup_weaviate/communicate",
          "webPageMainText": "Here, we'll perform basic operations to communicate with Weaviate using the Python client library.\nYou can check whether the Weaviate instance is up using the is_live function.\nYou can retrieve meta information about the Weaviate instance using the meta function.\nThis will print the server meta information to the console. The output will look similar to the following:\nAfter you have finished using the Weaviate client, you should close the connection. This frees up resources and ensures that the connection is properly closed.\nWe suggest using a try-finally block as a best practice. For brevity, we will not include the try-finally blocks in the remaining code snippets.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/assets/files/filtered-vector-search-with-caches-performance-fac846a6b769cac8845c4c8ab2f0e07c.png",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-huggingface module enables Weaviate to obtain vectors using the Hugging Face Inference API. To use the module, you must enable it in your Docker Compose file ( docker-compose.yml) You can set vectorizer behavior using the moduleConfig section under each clas."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-huggingface",
          "webPageMainText": "The text2vec-huggingface module enables Weaviate to obtain vectors using the Hugging Face Inference API.\nKey notes:\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use text2vec-huggingface, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables text2vec-huggingface, sets it as the default vectorizer, and sets the API keys.\nYou can configure how the module will behave in each class through the Weaviate schema.\nThe following parameters are available for the API.\nNote that you should only set one of:\nThe following example configures the Document class by setting the vectorizer to text2vec-huggingface, model to sentence-transformers/all-MiniLM-L6-v2 as well as to wait for the model to load, use GPU and use the cache.\nYou can set vectorizer behavior using the moduleConfig section under each clas"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A 'grouped task' generation wil perform RAG queries on a set of retrieved objects. This is useful when you want to transform the set of objects as a whole, with one prompt. For grouped_task queries, you simply pass on the prompt to the grouped_ task parameter. You can also pass on a list of properties to be used. This can be useful to reduce the amount of data passed on."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_rag/grouped_task",
          "webPageMainText": "A 'grouped task' generation wil perform RAG queries on the set of retrieved objects. This is useful when you want to transform the set of objects as a whole, with one prompt.\nThis example finds entries in \"Movie\" whose vector best matches the query vector (for \"dystopian future\"). Then, instructs the large language model to find commonalities between them.\nEach of the results are then printed out to the console.\nFor grouped_task queries, you simply pass on the prompt to the grouped_task parameter. This will instruct Weaviate to pass on the:\nto the large language model.\nYou can also pass on a list of properties to be used, as the grouped_properties parameter. This can be useful to reduce the amount of data passed on to the large language model and omit irrelevant properties.\nA RAG query with the grouped_task parameter will return a response with an additional generated attribute. This attribute will contain the generated output for the set of objects.\nIf you have any questions or feedba"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Our brains evolved to process images, not text. As a result, we still process images much faster than words. Website interfaces, social media messages, videos and images, printed material\u2026 It has all been designed and usually the designer\u2019s goal has been to communicate a message, not just make it pretty."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/good-design-is-good-business",
          "webPageMainText": "\nYou\u2019re reading this blog, not just looking at it. And most of the ideas in this post are conveyed in words. But admit it: The first thing that caught your eye was that cute drawing of the GoLang gopher holding a vacuum cleaner.\n\nEven though a paragraph of text precedes this image, you probably looked at this picture before it. Congratulations, you\u2019re a human, not a robot.\nThere\u2019s a good reason for that. For most of human evolution, written language didn\u2019t even exist. We had to identify plants - some were poisonous, others were nutritious - based on what they looked like, not printed labels at the supermarket. Our brains evolved to process images, not text. As a result, we still process images much faster than words.\nWe are all swimming in content. Website interfaces, social media messages, videos and images, printed material\u2026 It has all been designed and usually the designer\u2019s goal has been to communicate a message, not just make it pretty. Design is especially useful in a \u201cborderless"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The visualization below shows how modules are part of and connected to Weaviate. If you have your own vectorizer, machine learning or other model that you want to use, you can build your own Weaviates Module. Everything that is blue belongs to a specific module (more than one module can be attached, but here we show one module)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-modules/how-to-build-a-new-module",
          "webPageMainText": "If you have your own vectorizer, machine learning or other model that you want to use with Weaviate, you can build your own Weaviate Module.\nThe visualization below shows how modules are part of and connected to Weaviate. The black border indicates Weaviate Core, with the grey boxes as internals. Everything in red involves how Weaviate uses the modules that are connected, with the general Module System API. The red Module API spans two internal 'layers', because it can influence the Weaviate APIs (e.g. by extending GraphQL or providing additional properties), and it can influence the business logic (e.g. by taking the properties of an object and setting a vector).\nEverything that is blue belongs to a specific module (more than one module can be attached, but here we show one module). Here we have an example of Weaviate using the text2vec-transformers module bert-base-uncased. Everything that belongs to the text2vec-transformers module is thus drawn in blue. The blue box inside Weaviate"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In Weaviate, you can use cross-references to manage relationships between objects. For example, a blog application might need to store information about the author of each post. Or, a document store may chunk documents into smaller pieces and store them in separate objects, each with a reference to the original document."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/cross-references",
          "webPageMainText": "In this tutorial, you will learn how to use cross-references to manage relationships between objects, and to use them to enhance your queries.\nMany applications require the ability to manage relationships between objects. For example, a blog application might need to store information about the author of each post. Or, a document store may chunk documents into smaller pieces and store them in separate objects, each with a reference to the original document.\nIn Weaviate, you can use cross-references to manage relationships between objects. In the preceding examples, a blog post class could have a cross-reference property called hasAuthor to link each post to its author, or a chunk class could have a cross-reference property called sourceDocument to link each chunk to its original document.\nWe will refer to the originating object as the source object, and the object that is being linked to (cross-referenced object) as the target object.\nThis tutorial assumes that you have completed the Q"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.18 brings a set of great features, performance improvements, and fixes. This release introduces a compact, modern data structure to Weaviate called \u201cRoaring bitmaps\u201d The new Roaring bitmap indexing dramatically speeds up filtered searches. It provides up to 1000(!) times faster performance in some cases."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-18-release",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.18, which brings a set of great features, performance improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\n\n\nThis release introduces a compact, modern data structure to Weaviate called \u201cRoaring bitmaps\u201d that will replace the internals of the inverted index. The new Roaring bitmap indexing dramatically speeds up filtered searches, and we\u2019ve seen it provide up to 1000(!) times faster performance in some cases.\nAt Weaviate, we've been on a journey to keep up with the growing needs of our users. As more and more vectors are added to Weaviate instances, the \"allow list\" of pre-filtered items can reach tens, or hundreds of millions of objects. This can result in long retrieval times that are far from ideal from a user perspective. The introduction of Roaring Bitmaps is another step that will help us and our users scale"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#configure-autopq",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is happy to announce our inclusion in the Forbes AI 50 2024 list!Hybrid Search for curious Web Developers with the new Weaviate TypeScript client and Next.js. In-depth technical breakdown of how binary quantization works and how to use it in Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/blog/page/2",
          "webPageMainText": "Weaviate is happy to announce our inclusion in the Forbes AI 50 2024 list!\nHybrid Search for curious Web Developers with the new Weaviate TypeScript client and Next.js\nIn-depth technical breakdown of how binary quantization works and how to use it in Weaviate.\nBoosting Weaviate using SIMD-AVX512, Loop Unrolling and Compiler Optimizations\nA beta release of our new TypeScript client is now available! Help us make it better by trying it out and providing your feedback.\nHurricane is a web application to demonstrate Generative Feedback Loops with blog posts.\nWe\u2019re excited to share the details of our newly launched Weaviate Hero Program! Let\u2019s find out more ...\nExplore enterprise use cases heavily used by our customers adopting generative AI features, search capabilities, and RAG with Weaviate vector database.\nVerba is an open source Retrieval Augmented Generation (RAG) application built using a modular, customizable architecture that makes it easy for anyone to use AI methods to get persona"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative search is a powerful technique that retrieves relevant data to provide to large language models (LLMs) as context. It is also called retrieval augmented generation (RAG), or in-context learning in some cases. This pages introduces you to generative search with Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/starter-guides/generative",
          "webPageMainText": "This pages introduces you to generative search with Weaviate. It covers:\nThis guide assumes some familiarity with Weaviate, but it is not required. If you are new to Weaviate, we suggest starting with the Weaviate Quickstart guide.\nGenerative search is a powerful technique that retrieves relevant data to provide to large language models (LLMs) as context, along with the task prompt. It is also called retrieval augmented generation (RAG), or in-context learning in some cases.\nLLM are incredibly powerful, but can suffer from two important limitations. These limitation are that:\nGenerative search remedies this problem with a two-step process.\nThe first step is to retrieve relevant data through a query. Then, in the second step, the LLM is prompted with a combination of the retrieve data with a user-provided query.\nThis provides in-context learning for the LLM, which causes it to use the relevant and up-to-date data rather than rely on recall from its training, or even worse, hallucinated "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.19 brings a set of great features, performance improvements, and fixes. A downgrade to v1.18 will no longer be supported. You can now group Get search results based on a specific property. The groups and objectsPerGroup limits are custom."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/older-releases/release_1_19",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.19, which brings a set of great features, performance improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\nKeep in mind that after upgrading to v1.19 a downgrade to v1.18 will no longer be supported. If you anticipate having to downgrade, please create a backup before upgrading! If a backup is done with v1.18 before upgrading, you can always go back to v1.18 if you wish.\n\nWith the introduction of this feature, you can now group Get search results based on a specific property.\nTake a collection of Passage objects for example, each object belonging to a Document. If searching through Passage objects, you can group the results according to any property of the Passage, including the cross-reference property that represents the Document each Passage is associated with.\nThe groups and objectsPerGroup limits are customi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's queries are built using GraphQL. We will take it step-by-step and build up from the basics. You can query Weaviate using one or a combination of a semantic (i.e. vector) search and a lexical (e.g. scalar) search."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/query",
          "webPageMainText": "In this section, we will explore different queries that you can perform with Weaviate. Here, we will expand on the nearText queries that you may have seen in the Quickstart tutorial to show you different query types, filters and metrics that can be used.\nBy the end of this section, you will have performed vector and scalar searches separately as well as in combination to retrieve individual objects and aggregations.\nWe recommend you complete the Quickstart tutorial first.\nBefore you start this tutorial, you should follow the steps in the Quickstart to have:\nWeaviate's queries are built using GraphQL. If this is new to you, don't worry. We will take it step-by-step and build up from the basics. Also, in many cases, the GraphQL syntax is abstracted by the client.\nYou can query Weaviate using one or a combination of a semantic (i.e. vector) search and a lexical (i.e. scalar) search. As you've seen, a vector search allows for similarity-based searches, while scalar searches allow filtering"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Dynamic indexing is an experimental feature. Use with caution."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/vector-index#hnsw-configuration-tips",
          "webPageMainText": "Vector indexes facilitate efficient, vector-first data storage and retrieval.\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nAvailable starting in v1.25. Dynamic indexing is an experimental feature. Use with caution.\nUse these parameters to configure the index type and their properties. They can be set in the collection configuration.\nGenerally, the hnsw index type is recommended for most use cases. The flat index type is recommended for use cases where the data the number of objects per index is low, such as in multi-tenancy cases."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Persuasive Adversarial Prompting to Jailbreak LLMs with 92% Success Rate. More advanced models like GPT-4 are more vulnerable to persuasive adversarial prompts (PAPs) Test these PAPs to perform attacks covering 14 different risk categories (such as economic harm, etc.)"
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper15",
          "webPageMainText": "\n\ud83d\udde3\ufe0fPersuasive Adversarial Prompting to Jailbreak LLMs with 92% Success Rate\n\ud83d\udd12Fascinating new paper breaks down jailbreak prompting to a science!\n\u23e9In Short:\nProvide a taxonomy of 40 persuasion prompting techniques\nUse this list of 40 techniques they can jailbreak LLMs including GPT4 with a 92% success rate!!\nPretty interestingly Anthropic models are not susceptible at all to PAP attacks!! More advanced models like GPT-4 are more vulnerable to persuasive adversarial prompts (PAPs).\nIf you can defend against these PAPs this also provides effective protection against other attacks\nTest these PAPs to perform attacks covering 14 different risk categories (such as economic harm, etc.)\nBlog+Demo: https://chats-lab.github.io/persuasive_jailbreaker/\n\ud83d\udd17 arXiv Link\n\ud83d\udcdc Download paper\nCheck out the Quickstart tutorial, and begin building amazing apps with the free trial of Weaviate Cloud (WCD).\nGitHub\nForum\nSlack\nX (Twitter)\nSign up for our bi-weekly newsletter to stay updated!\n"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/tags/engineering",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Large Language Models (LLM\u2019s) have revolutionized how we access and consume information. We\u2019re seeing these models revolutionize how we work, learn and interact on a scale never seen before. This wide-scale adoption of LLMs makes the concerns and challenges around privacy and data security paramount, and ones that each organization needs to address."
              }
            ]
          },
          "url": "https://weaviate.io/blog/private-LLM",
          "webPageMainText": "\nLarge Language Models (LLM\u2019s) have revolutionized how we access and consume information, shifting the pendulum from a search engine market that was predominantly retrieval-based (where we asked for source documents containing concepts relevant to our search query), to one now that is growingly memory-based and performs generative search (where we ask LLMs to generate answers to questions based on their knowledge of and training on massive datasets). More importantly, what\u2019s different this time is that with the advent of widely accessible products like ChatGPT that have exposed the underlying technology of these models to the wider consumer market, we\u2019re seeing these models revolutionize how we work, learn and interact on a scale never seen before.\nThis wide-scale adoption of LLMs makes the concerns and challenges around privacy and data security paramount, and ones that each organization needs to address. In this blog post we will explore some of the different potential approaches org"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector search returns the objects with most similar vectors to that of the query. To search a collection that has named vectors, use the target vector field to specify which named vector to search. To set a similarity threshold between the search and target vectors, define a maximum distance (or certainty)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/similarity#an-input-medium",
          "webPageMainText": "Vector search returns the objects with most similar vectors to that of the query.\nTo search a collection that has named vectors, use the target vector field to specify which named vector to search.\nThe output is like this:\nUse the Near Text operator to find objects with the nearest vector to an input text.\nThe output is like this:\nUse the Near Image operator to find objects with the nearest vector to an image.\nThis example uses a base64 representation of an image.\nSee Image search for more information.\nIf you have an object ID, use the Near Object operator to find similar objects to that object.\nIf you have an input vector, use the Near Vector operator to find objects with similar vectors\nTo set a similarity threshold between the search and target vectors, define a maximum distance (or certainty).\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\nTo limit results to groups of similar distances to the query, use the autocut fil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use these search how-to guides to find the data you want. The query basics page covers basic search syntax and how to specify the properties you want to retrieve. These guides cover additional search topics:If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search",
          "webPageMainText": "Use these search how-to guides to find the data you want.\nThe query basics page covers basic search syntax and how to specify the properties you want to retrieve.\nThese guides cover additional search topics:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Researchers at the University of Maryland created a way for us to modify LLMs such that a watermark would automatically be applied to any content that LLM generates. The watermark they created can be identified in as little as 25 tokens and has negligible impact on text quality."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper5",
          "webPageMainText": "\nCan you tell the difference between human-written language and AI-generated text?\ud83e\udd14 \nTo solve this problem we need watermarks!\ud83d\udcc3\nResearchers at the University of Maryland(https://arxiv.org/abs/2301.10226) created a way for us to modify LLMs such that a watermark would automatically be applied to any content that LLM generates. This allows us to run a test for this watermark to identify synthetic content in the wild.\nA watermark is a hidden pattern in text that is imperceptible to humans, but when the text is statistically analyzed it allows us to identify synthetic content. The watermark they created can be identified in as little as 25 tokens and has negligible impact on text quality.\nThe watermark works by selecting a randomized set of secret \u201cgreen\u201d tokens before a word is generated, and then softly incentivizing the LLM to use those green tokens by slightly nudging the output word probabilities during sampling. The more \"green\" tokens found in a chunk of text the higher the probabil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Goldfish Loss works by omitting a portion of tokens from loss computation during training. When the model encounters these excluded tokens at test time, it has to guess, reducing its ability to reproduce training samples exactly. With Goldfish Loss, the model usually diverges from the training data within the first 5 tokens it generates. The model learns slower because it does not get credit for the dropped tokens."
              }
            ]
          },
          "url": "https://weaviate.io/papers/goldfish",
          "webPageMainText": "\nThis paper proposes a technique called Goldfish Loss that is now used to mitigate the risk of LLMs memorizing copyrighted or private training data.\nThe paper introduces Goldfish Loss, a method where the model does not compute the loss on every token but excludes (e.g.) 1 in 4 tokens from loss computation. This makes it difficult for the model to memorize the training data.\nGoldfish Loss works by omitting a portion of tokens from loss computation during training. When the model encounters these excluded tokens at test time, it has to guess, reducing its ability to reproduce training samples exactly.\nIn standard training on Wikipedia articles, about 85% of them get perfectly memorized after 100 updates. With Goldfish Loss, the model usually diverges from the training data within the first 5 tokens it generates.\nThe model learns slower because it does not get credit for the dropped tokens. Training on N tokens with Goldfish Loss is equivalent to standard training on 0.75N tokens.\nGoldfis"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Cohere announced the release of the text-understanding multilingual model. LangChain is one of the most exciting new tools in AI. Weaviate introduces Ref2Vec, a new module that utilises Cross-References for Recommendation. Learn about the various Sentence Transformers from Hugging Face."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/integrations/page/2",
          "webPageMainText": "LangChain is one of the most exciting new tools in AI. It helps overcome many limitations of LLMs, such as hallucination and limited input lengths.\nEver wonder how Weaviate turns objects into vectors, behind-the-scenes? Find out in this post!\nCohere announced the release of the text-understanding multilingual model. Learn how to use it in Weaviate.\nWeaviate introduces Ref2Vec, a new module that utilises Cross-References for Recommendation!\nLearn about the various Sentence Transformers from Hugging Face!\nRunning ML Model Inference in production is hard. You can use Weaviate \u2013 a vector database \u2013 with Hugging Face Inference module to delegate the heavy lifting.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "PQ is currently only supported for the HNSW index. If you are using the flat index, you will need to use BQ. PQ parameters are tunable whereas BQ is not. This means you can adjust PQ to be more or less aggressive on performance parameters."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/compression/strategy",
          "webPageMainText": "Given the choice of PQ, BQ, or no compression, which should you choose? The answer is, it depends.\nPQ and BQ are both lossy compression techniques, and the choice between them depends on your circumstances, your model and the use case.\nPQ is currently only supported for the HNSW index, while BQ is supported for both the HNSW and flat indexes. If you are using the flat index, you will need to use BQ.\nPQ is generally a more robust compression technique, as it is fitted on your specific data during the training step. This means that you don't need to worry as much about whether your model is suitable for PQ.\nOn the other hand, BQ can be more sensitive to the model, such as its length and whether it is designed for binary quantization.\nIf you do not know whether your model is suitable for BQ, we recommend using PQ.\nAs you've seen, PQ parameters are tunable whereas BQ is not. This means that you can adjust PQ to be more or less aggressive on performance parameters, such as recall and QPS ta"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "DSPy lets you define each component that makes a language model request, such as a prompt. DSPy is returning to its roots in Machine Learning, allowing us to better control generative AI systems. To achieve this, D SPy introduces two new concepts: a programming model and a collection of optimizers or compilers."
              }
            ]
          },
          "url": "https://weaviate.io/blog/dspy-optimizers",
          "webPageMainText": "\nLanguage models have revolutionized the way we interact with and utilize artificial intelligence. These powerful tools can be prompted to perform a wide array of tasks, from creative writing to answering complex questions, and even assisting with decision making. However, the quality and effectiveness of the generated output is heavily dependent on the particular language in the prompt to the language model.\nCrafting the perfect prompt, also known as Prompt Engineering, is generally more of an art than a science. AI developers typically have unique styles of prompting large language models (LLMs) through trial-and-error experiences. With the inception of DSPy, prompting is returning to its roots in Machine Learning, allowing us to better control generative AI systems.\nTo achieve this, DSPy introduces two new concepts: a programming model and a collection of optimizers or compilers. The DSPy programming model lets you define each component that makes a language model request, such as a"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has released a pre-release version of our new Python client API. It's available for you to try out and provide feedback through this form. We've made a number of major improvements, including strong typing, a collections-first approach, and performance improvements."
              }
            ]
          },
          "url": "https://weaviate.io/blog/collections-python-client-preview",
          "webPageMainText": "\nThe v4 client has since been officially released! Thank you to everyone who provided feedback and helped shape the client. You can find the official release announcement here.\nWe've released a pre-release version of our new Python client API. It's available for you to try out and provide feedback through this form. We've made a number of major improvements, including strong typing, a collections-first approach, and performance improvements.\nYou can try it here - Experimental clients.\nWe want to ensure that Weaviate is not just powerful, but also user-friendly.\nAfter all, the best tools are those that are accessible and easy to integrate into your projects. This is why we prioritize client libraries for different programming languages.\nToday, we're thrilled to unveil our pre-release collections Python client API. We've designed it to be more Pythonic, leveraging modern IDE features like code completion and type hints. Moreover, we've revamped the way you work with your data.\nWhile our "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#dynamic-index",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Objects are parsed twice: First, closest to disk, immediately after reading-in the byte blob. A second time at the root level of the db.DB type, the whole request is parsed again (recursively) and cross-refs are resolved as requested by the user."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/parsing-cross-refs",
          "webPageMainText": "Objects are parsed twice:\nFirst, closest to disk, immediately after reading-in the byte blob, all\nnon-reference props are parsed and their respective Golang types (e.g.\n*models.GeoCoordinates or *models.PhoneNumber) are returned.\nA second time at the root level of the db.DB type, the whole request is\nparsed again (recursively) and cross-refs are resolved as requested by the\nuser (through traverser.SelectProperties)\n\nGenerally, shards (and also indices) are self-contained units. It is thus\nnatural that they return objects which work in isolation and can be interpreted\nby the rest of the application (usually in the form of a search.Result or\nsearch.Results, both defined as entities)\nHowever, cross-references aren't predictable. They could point to an item in\nanother shard or even to an item of another index (because they are a different\nuser-facing Class). When running in multi-node mode (horizontal replication)\nthe shards could be distributed on any node in the cluster.\nFurthermore it i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#hnsw-index",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "RAG queries are also called 'generative' queries in Weaviate. You can access these functions through the generate submodule of the collection object. Each generative query works in addition to the regular search query. This allows you to retrieve objects from a Weaviates instance and then generate outputs based on the retrieved objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_rag/setup",
          "webPageMainText": "Retrieval augmented generation (RAG) is a way to combine the best of both worlds: the retrieval capabilities of semantic search and the generation capabilities of AI models such as large language models. This allows you to retrieve objects from a Weaviate instance and then generate outputs based on the retrieved objects.\nWhen we created a collection, we specified the generative_module parameter as shown here.\nThis selects a generative module that will be used to generate outputs based on the retrieved objects. In this case, we're using the openai module, and the GPT family of large language models.\nAs we did before with the vectorizer module, you will require an API key from the provider of the generative module. In this case, you will need an API key from OpenAI.\nRAG queries are also called 'generative' queries in Weaviate. You can access these functions through the generate submodule of the collection object.\nEach generative query works in addition to the regular search query, and wi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.20 is a new release of Weaviate. This release includes a number of new features. The most important new feature is the ability to store data from up to millions of tenants in a single setup. This means that scaling your business or infrastructure to include data from a large group of users is easier and faster than ever."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-20-release#autocut",
          "webPageMainText": "\nWeaviate 1.20 is here!\nAs always, a brand-new release means a set of brand-new features. Here are the \u2b50\ufe0fhighlights\u2b50\ufe0f:\nWe hope we've whetted your appetite - so what're you waiting for?! Keep scrolling \u2b07\ufe0f!\nDowngrading from 1.20.x to a 1.19.x or lower is not possible.\nPlease proceed with caution, such as by making a backup of your data & schema, or cluster before upgrading.\nStore data from up to millions of tenants in a single setup.\n\n\nWe\u2019ll keep this brief as Etienne covered this in great detail in this blog post. The key point, though, is that Weaviate now makes it easy to store data from up to millions of tenants in a single setup.\nThis means that scaling your business or infrastructure to include data from a large group of users is easier and faster than ever. We have worked with our community on this feature to ensure that your compliance needs are met as well as performance needs, while keeping the experience a smooth one for everybody. Our multi-tenancy implementation allows for h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "It is also possible to add a cross-reference property to an existing collection definition. This requires adding reference properties in both directions, and adding two cross-references per object pair. Use cross- references to establish directional relationships between collections. Use the reference property in the collection definition before adding cross-References to it."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/cross-references#delete-a-cross-reference",
          "webPageMainText": "Use cross-references to establish directional relationships between collections.\nNotes:\nInclude the reference property in the collection definition before adding cross-references to it.\nIt is also possible to add a cross-reference property to an existing collection definition.\nSpecify a cross-reference when creating an object.\nSpecify the required id and properties for the source and the target.\nThis requires adding reference properties in both directions, and adding two cross-references per object pair (from A -> to B and from B -> to A).\nCreate the JeopardyCategory collection:\nCreate the JeopardyQuestion collection including the reference property to JeopardyCategory:\nModify JeopardyCategory to add the reference to JeopardyQuestion:\nAnd add the cross-references:\nWeaviate allows creation of multiple cross-references from one source object.\nCross-references can be read as part of the object.\nDeleting a cross-reference with the same parameters used to define the cross-reference.\nWhat ha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Work from Microsoft uses synthetic data + LLMs as embedding models to achieve SOTA on the MTEB benchmark. They generate a multilingual synthetic retrieval dataset using GPT-4 which includes {queries, positive matches, hard negatives}. They use this synthetic dataset along with 13 other public datasets and embed the queries & negatives using the last layer vectors of Mistral-7B."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper14",
          "webPageMainText": "\n\u2753Your RAG workflow is only as good as the retrieved context. Can you use LLMs to improve recall and search relevance for dense retrievers?\ud83e\udd14\n\ud83d\udcdcWork from Microsoft uses synthetic data + LLMs as embedding models to achieve SOTA on the MTEB benchmark.\n\u23e9In Short: \nThey generate a multilingual synthetic retrieval dataset using GPT-4 which includes {queries, positive matches, hard negatives}. \nThey use this synthetic dataset along with 13 other public datasets and embed the queries & positives/negatives using the last layer vectors of Mistral-7B.\nThey tune the Mistral-7B embedding model using a contrastive loss along with embeddings from step 2.\nUsing this fine-tuned Mistral-7B as an embedding model then achieves SOTA(+2.4%) on MTEB.\n\n\u274c Limitations/Short-coming: Potential data contamination? Didn't Mistral-7B have access to all MTEB benchmark datasets? - The MTEB was released(Oct 2022) before the training cutoff(~2023) of the model. So there might be some contamination since we are using the "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We welcome and support people of all backgrounds and identities. We will all experience frustration from time to time, but we cannot allow that frustration to become personal attacks. An environment where people feel uncomfortable or threatened is not a productive or creative one. Be kind to others. Do not insult or put down others."
              }
            ]
          },
          "url": "https://weaviate.io/service/code-of-conduct",
          "webPageMainText": "We welcome and support people of all backgrounds and identities.\nThis includes, but is not limited to members of any sexual orientation, gender identity and expression, race, ethnicity, culture, national origin, social and economic class, educational level, color, immigration status, sex, age, size, family status, political belief, religion, and mental and physical ability.\nWe all depend on each other to produce the best work we can as a company.\nYour decisions will affect clients and colleagues, and you should take those consequences into account when making decisions.\nWe won't all agree all the time, but disagreement is no excuse for disrespectful behavior.\nWe will all experience frustration from time to time, but we cannot allow that frustration become personal attacks.\nAn environment where people feel uncomfortable or threatened is not a productive or creative one.\nAlways conduct yourself professionally.\nBe kind to others.\nDo not insult or put down others.\nHarassment and exclusiona"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-gpt4all module is not available on Weaviate Cloud. To use it, you must enable it in your Docker Compose file ( docker-compose.yml) You can set vectorizer behavior using the moduleConfig section under each class and property."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-gpt4all",
          "webPageMainText": "The text2vec-gpt4all module enables Weaviate to obtain vectors using the gpt4all library.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use text2vec-gpt4all, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables text2vec-gpt4all, sets it as the default vectorizer, and sets the API keys.\nYou can configure how the module will behave in each class through the Weaviate schema.\nThe following example configures the Article class by setting the vectorizer to text2vec-gpt4all:\nYou can set vectorizer behavior using the moduleConfig section under each class and property:\nCurrently, the only available model is all-MiniLM-L6-v2.\nThe text2vec-gpt4all module is optimized for CPU inference and should be noticeably faster then text2vec-transformers in CPU-only (i.e. no CUDA acceleration) usage. You can read more about expected inference times here.\ntext2vec-gpt4all wil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate uses the Raft consensus algorithm for schema replication, implemented with Hashicorp's raft library. A schema change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. This architecture ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/cluster-architecture#replication-factor",
          "webPageMainText": "This page describes how the nodes or clusters in Weaviate's replication design behave.\nIn Weaviate, schema replication and data replication are separate. For the schema, Weaviate uses the Raft consensus algorithm with strong consistency. For data replication, Weaviate uses a leaderless design with eventual consistency.\nWeaviate uses the Raft consensus algorithm for schema replication, implemented with Hashicorp's raft library.\nRaft ensures that schema changes are consistent across the cluster. A schema change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. Once a majority of nodes have acknowledged the change, the leader commits the change to the log. The leader then notifies the followers, which apply the change to their logs.\nThis architecture ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures.\nAs a result, a Weaviate cluster will include a leader node that"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate v3 TypeScript client is now stable. How to use OpenAI's embedding models trained with Matryoshka Representation Learning in a vector database like Weaviate. A comprehensive overview of common information retrieval metrics, such as precision, recall, MAP, and NDCG."
              }
            ]
          },
          "url": "https://weaviate.io/blog",
          "webPageMainText": "How to use OpenAI's embedding models trained with Matryoshka Representation Learning in a vector database like Weaviate\nWe're pleased to share that the Weaviate v3 TypeScript client is now stable!\nHow to select an embedding model for your search and retrieval-augmented generation system.\nA comprehensive overview of common information retrieval metrics, such as precision, recall, MRR, MAP, and NDCG.\nHow to implement a local Retrieval-Augmented Generation pipeline with Ollama language models and a self-hosted Weaviate vector database via Docker in\u00a0Python.\nWeaviate 1.25 is released! Updates include ...\nLearn about how Instabase leverages AI to streamline operations and enhance efficiency!\nLearn how to vectorize ~50 million objects and ingest into Weaviate using Modal!\nDive into using Weaviate for image recognition to find the \"needle in a haystack\"!\nHere is our recap of Google Cloud Next!\nTransforming data scattered across various sources into actionable insights, like searching or buildi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate Offering may include individual open-source software components, each of which has its own copyright and its own applicable license conditions. \u201cClaim\u201d means any claim, demand, suit, or proceeding. \u2018Affiliates\u2019 means an entity that directly or indirectly Controls, is Controlled by, or is under common Control with another entity."
              }
            ]
          },
          "url": "https://weaviate.io/service/weaviate-enterprise-agreement-nonus",
          "webPageMainText": "Last Updated: May, 2024\nSubject to the terms and conditions of this Agreement, Weaviate will make the Weaviate Offering available to Customer pursuant to this Agreement, any applicable Exhibits to this Agreement, and the applicable Order Form.\nThe Weaviate Offering may include individual open-source software components, each of which has its own copyright and its own applicable license conditions. These open-source software components are licensed under the terms of the applicable open-source license conditions and/or copyright notices.\nThe following terms, when used in this Agreement will have the following meanings:\n\u201cAffiliates\u201d means an entity that directly or indirectly Controls, is Controlled by, or is under common Control with another entity, so long as such Control exists. For the purposes of this definition, \u201cControl\u201d means beneficial ownership of 50% or more of the voting power or equity in an entity.\n\u201cClaim\u201d means any claim, demand, suit, or proceeding.\n\u201cClient Software\u201d mean"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.18 introduces Faster Filtering through Bitmap Indexing, HNSW-PQ, Cursor API, and more. Learn how to connect Weaviate to ChatGPT to generate customized responses. Learn about the different ranking models that are used for better search."
              }
            ]
          },
          "url": "https://weaviate.io/blog/page/6",
          "webPageMainText": "Videos on authentication: an overview, how to log in, how to set it up, and core concepts - including recommendations.\nLearn about Auto-GPT and how to give it long-term memory with Weaviate!\nLearn about the different ranking models that are used for better search.\nLearn how you can connect Weaviate to ChatGPT to generate customized responses.\nLearn about how to monitor Weaviate in production and observe key metrics.\nA gentle introduction to Large Language Models (LLMs) - how they work and what they learn.\nUsing the Weaviate Tile Encoder to compress vectors with Product Quantization.\nImplementing HNSW + Product Quantization (PQ) vector compression in Weaviate.\nWeaviate 1.18 introduces Faster Filtering through Bitmap Indexing, HNSW-PQ, Cursor API, and more! Learn all about it.\nDid you know that Weaviate can summarize information during retrieval? Learn how you can summarize your data to tackle the problem of information overload.\nLangChain is one of the most exciting new tools in AI. It "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This API client is compatible with Java 8 and beyond. The current Java client version is v4.7.0. The Java client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows. The suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviates instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/java#authentication",
          "webPageMainText": "The current Java client version is v4.7.0.\nThe package and import paths have been updated from technology.semi.weaviate to io.weaviate.\nSee the Migration Guide for more info.\nTo get the latest stable version of the Java client library, add this dependency to your project:\nThis API client is compatible with Java 8 and beyond.\nYou can use the client in your project as follows:\nFor more comprehensive information on configuring authentication with Weaviate, refer to the authentication page.\nThe Java client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows.\nThe suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviate instance.\nEach Weaviate instance in Weaviate Cloud (WCD) is pre-configured to act as a token issuer for OIDC authentication.\nSee our WCD authentication documentation for instructions on how to authenticate against WCD with your preferred Weaviate client.\nIf you"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This vector database benchmark is designed to measure and illustrate Weaviate's Approximate Nearest Neighbor (ANN) performance for a range of real-life use cases. The benchmark is open source, so you can reproduce the results yourself. For good starting point values and performance tuning advice, see HNSW Configuration Tips."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/benchmarks/ann#what-is-being-measured",
          "webPageMainText": "This vector database benchmark is designed to measure and illustrate Weaviate's Approximate Nearest Neighbor (ANN) performance for a range of real-life use cases.\nThis is not a comparative benchmark that runs Weaviate against competing vector database solutions. \nTo discuss trade-offs with other solutions, contact sales.\nTo make the most of this vector database benchmark, you can look at it from different perspectives:\nFor each benchmark test, we set these HNSW parameters:\nFor good starting point values and performance tuning advice, see HNSW Configuration Tips.\nFor each set of parameters, we've run 10,000 requests, and we measured the following metrics:\nBy request, we mean:\nAn unfiltered vector search across the entire dataset for the given test. All\nlatency and throughput results represent the end-to-end time that your\nusers would also experience. In particular, these means:\nThis benchmark is open source, so you can reproduce the results yourself.\nThis section contains datasets model"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#invertedindexconfig--indextimestamps",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Tokenization is the process of breaking text into smaller units, called tokens. This is an important step that impacts how text is processed in a variety of contexts. The choice of tokenization method will significantly impact the result of keyword search and filtering. This can cause it to either meet or miss the user's expectations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/tokenization/basics",
          "webPageMainText": "Tokenization is the process of breaking text into smaller units, called tokens. This is an important step that impacts how text is processed in a variety of contexts.\nConsider text like:\nThis text could be tokenized in a variety of ways. All of the following are perfectly valid tokenizations:\nMethods 1 and 2 are examples of word tokenization, while method 3 is an example of subword tokenization.\nThe choice of tokenization method will depend on the context in which the text is being used.\nThe choice of tokenization method will significantly impact the result of keyword search and filtering. This can cause it to either meet or miss the user's expectations.\nIn a database of television shows, you would expect a search for \"Superman\", or \"Clark\" to include the show \"Lois & Clark: The New Adventures of Superman\". Selecting the right tokenization method will ensure that this is the case.\nBut, in a database of email addresses, you would not expect a search for \"john@example.com\" to include \"jo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "At early-stage companies like Weaviate, teams are still small, so it\u2019s often difficult to justify both a dedicated Product Manager and a formal engineering team lead. A single person often takes the lead in both product and engineering decisions.Combining both roles into one is the best way we\u2019ve found to develop and iterate new ideas."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/the-case-of-product-engineering",
          "webPageMainText": "\nAt early-stage companies like Weaviate, teams are still small, so it\u2019s often difficult to justify both a dedicated Product Manager and a formal engineering team lead. However, early-stage companies also set a high engineering tempo, so strategic product decisions can often only be made by someone with a strong technical background. That\u2019s why in Weaviate case, a single person often takes the lead in both product and engineering decisions. This is not a compromise, it\u2019s a strategic choice.\nCombining both roles into one\u2014we call it \u201cProduct Engineering\u201d\u2014is the best way we\u2019ve found to develop and iterate new ideas, and to quickly get from a \u201clightbulb\u201d moment to product-market fit.\nBefore co-founding Weaviate, I worked at companies with more traditional structures, in which product managers and engineers were different people, from different backgrounds, doing their own things. In some places, PMs and engineers fostered good communications, and made decisions together without regard for h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#property-tokenization",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open source vector database that's purpose-built for AI. Weaviate cloud service is natively built on Google Cloud and scales using Google Kubernetes Engine. Integrations with Google AI Workbench and Vertex AI, including the latest Foundation Models like Gemini Pro and Ultra LLMs."
              }
            ]
          },
          "url": "https://weaviate.io/partners/gcp",
          "webPageMainText": "Weaviate on Google Cloud\nPowerful AI-native vector database. Simple, secure deployment on GCP.\nWeaviate is an open source vector database that's purpose-built for AI. Weaviate cloud service is natively built on Google Cloud and scales using Google Kubernetes Engine. Integrations with Google AI Workbench and Vertex AI, including the latest Foundation Models like Gemini Pro and Ultra LLMs, help developers build and deploy production-ready generative AI applications with less hassle.\nSub-second semantic search performance and ability to scale to handle billions of vectors and millions of tenants.\nNatively integrate with Gemini Pro and Ultra, PaLM, Vertex AI, and model providers like Cohere, OpenAI, Hugging Face, and more. Or, use custom models.\nWeaviate is available in the GCP marketplace and allows one-click container based scalable deployment inside the customers\u2019 tenant.\nWhether you\u2019re part of a traditional enterprise with an on-prem data footprint or a digital native, Weaviate can mee"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a free and open-source database and search engine. This unit explains what it is, and what it can do. You can then run Weaviate and perform vector searches yourself. At the end of the unit, you should be able to:use Weaviates to create your own projects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/wrap_up",
          "webPageMainText": "In this unit, we aimed to provide you with an overview of Weaviate.\nWe did this by covering what Weaviate is, and what it can do, before discussing what vector database and vector search are before going on to run Weaviate and perform vector searches yourself.\nNow, you should have a foundation of knowledge from which we can begin to learn more about Weaviate, including more details on how to build a database and perform queries. Before long, you will be creating your own projects using Weaviate.\nHaving finished this unit, you should be able to:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Keep your AI-native development skills fresh with self-paced courses offered through Weaviate Academy and DeepLearning.AI. With onboarding packages tailored to your needs, we\u2019ll make sure you\u2019re set up for success. We offer 24x7 enterprise support options for both Weaviates Cloud Services and open source users."
              }
            ]
          },
          "url": "https://weaviate.io/services/education-and-support",
          "webPageMainText": "Training courses, resources, and support options for builders of all levels. We\u2019re with you on your AI journey.\nRolling out a new database can be daunting. With onboarding packages tailored to your needs, we\u2019ll make sure you\u2019re set up for success with Weaviate.\nWe offer 24x7 enterprise support options for both Weaviate Cloud Services and open source users. If something goes wrong, we\u2019ll be there to help.\nKeep your AI-native development skills fresh with self-paced courses offered through Weaviate Academy and DeepLearning.AI.\nIn addition to our documentation, guides, and on-demand learning, we host live workshops and office hours virtually or in person. Learn more \nAttendee, DeepLearning.AI course\nWe've built these courses to help you build amazing things with Weaviate, faster.\nLinkedIn Learning\nZain Hasan's course offers an in-depth look at vector databases, highlighting their use in enhancing search accuracy and managing complex data through AI, with practical coding labs for real-wor"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This tutorial will show you how to import a large dataset (25k articles from Wikipedia) that already includes vectors. We will use this Simple English Wikipedia dataset hosted by OpenAI that includes vector embeddings. If you haven't yet, we recommend going through the Quickstart tutorial first to get the most out of this section."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/wikipedia",
          "webPageMainText": "This tutorial will show you how to import a large dataset (25k articles from Wikipedia) that already includes vectors (embeddings generated by OpenAI). We will,\nIf you haven't yet, we recommend going through the Quickstart tutorial first to get the most out of this section.\nBefore you start this tutorial, make sure to have:\nYou can delete any unwanted collection(s), along with the data that they contain.\nWhen you delete a collection, you delete all associated objects!\nBe very careful with deletes on a production database and anywhere else that you have important data.\nThis code deletes a collection and its objects.\nWe will use this Simple English Wikipedia dataset hosted by OpenAI (~700MB zipped, 1.7GB CSV file) that includes vector embeddings. These are the columns of interest, where content_vector is a vector embedding with 1536 elements (dimensions), generated using OpenAI's text-embedding-ada-002 model:\nIf you haven't already, make sure to download the dataset and unzip the file. Y"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This is a preview version of this unit. Some sections are not yet complete - such as videos and quiz questions. Please check back later for the full version. Feel free to provide any feedback through the comments below. Back to Mail Online home.back to the page you came from."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking/wrap_up",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nIn this unit, you have learned about chunking, which is a technique of splitting up longer texts into smaller pieces of text, or \"chunks\".\nWe covered how it can impact information retrieval using vector databases, and how it can affect the performance of retrieval augmented generation.\nThen, we then moved on to cover various chunking techniques including fixed-size chunking, variable-size chunking, and hybrid chunking. We also discussed key considerations when deciding on a chunking strategy, as well as some suggested starting points.\nThe unit was rounded off with a discussion of some points of consideration when chunking data. These included the length of text per search result, the input query length, the size of the database, the requirements "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A question that I get a lot is, \u201cWhy would you create an open-source business?\u201d That\u2019s understandable; I must seem like an inventor who refuses to patent his inventions or an entrepreneur giving products away for free. If you have trouble explaining how such business models work, try using an example of a business from outside the world of software."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/why-the-business-model-of-open-source-software-works",
          "webPageMainText": "\nA question that I get a lot is, \u201cWhy would you create an open-source business?\u201d\nThat\u2019s understandable; I must seem like an inventor who refuses to patent his inventions or an entrepreneur giving products away for free. If you\u2019re starting your own open-source business, you\u2019ll hear this question from the talent you\u2019re trying to hire, customers and investors, and maybe you\u2019ll even ask yourself the same question. If you have trouble explaining how such business models work, try using an example of a business from outside the world of software.\nOne such business is Momofuku, the restaurant empire of chef David Chang. If he had chosen a closed-source model, he would force kitchen employees to sign NDAs and make all his revenue selling food to restaurant customers. But instead, Momofuku restaurants typically have bar seating that looks directly into the kitchen. Chef Chang publishes his recipes in cookbooks and on his website; he demonstrates his techniques on cooking shows; Momofuku even se"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "How does Weaviate store data such that it can supports these queries? In this section, we take a look at some of the key components that allow Weaviates to perform these queries at speed. In particular, we'll take a looks at indexes and the schema, which acts as a blueprint for your data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports/data_structure",
          "webPageMainText": "You've seen some of the powerful queries that Weaviate enables. But how does Weaviate actually store data such that it can supports these queries?\nIn this section, we'll take a look at some of the key components that allow Weaviate to perform these queries at speed. In particular, we'll take a look at indexes, which are the backbone of Weaviate's data structure, and the schema, which acts as a blueprint for your data.\nAn index is a data structure that allows for efficient retrieval of data. In Weaviate, there are two main indexes: the inverted index and the vector index.\nThe inverted index is the kind of index that you may be familiar with. You can think of it as a reference table that for example allows you to quickly look up a term and find objects that contain that term.\nThe vector index allows for efficient retrieval of vectors based on similarity. This is the index that allows Weaviate to perform vector searches fast. Let's dig in a little more.\nAn inverted index deconstructs text"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#when-to-skip-indexing",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model. To use this module, you must enable it in your Docker Compose file. For production use cases, we recommend using other modules that use a more modern, transformer-based architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-contextionary#configure-semantic-indexing",
          "webPageMainText": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model.\nKey notes:\nAs a lightweight model, it is well suited for testing purposes.\nFor production use cases, we recommend using other modules that use a more modern, transformer-based architecture.\nThis module is not available on Weaviate Cloud.\nTo use text2vec-contextionary, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nContextionary:\nThis configuration enables text2vec-contextionary, sets it as the default vectorizer, and sets the parameters for the Contextionary Docker container.\nYou can configure how the module will behave in each class through the Weaviate schema.\nYou can set vectorizer behavior using the moduleConfig section under each class and property:\nIf you are using this module and are vectorizing the class or property name, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Retrieval Augmented Generation (RAG) incorporates external knowledge into a Large Language Model (LLM) to improve the accuracy of AI-generated content. Weaviate's design caters specifically to the demands of vector data, enabling unparalleled scalability and performance. This scalability is key in RAG applications, where the volume of data and the need for rapid retrieval is significant."
              }
            ]
          },
          "url": "https://weaviate.io/rag",
          "webPageMainText": "Reduce hallucination and make conversational apps more reliable, without compromising data privacy.\nRetrieval Augmented Generation (RAG) incorporates external knowledge into a Large Language Model (LLM) to improve the accuracy of AI-generated content. Weaviate's design caters specifically to the demands of vector data, enabling unparalleled scalability and performance. This scalability is key in RAG applications, where the volume of data and the need for rapid retrieval is significant. Weaviate maintains high performance at scale, ensuring that the LLMs are always fed with the most relevant and timely data.\nWeaviate can be self-hosted, or we can host and manage it for you within your own VPC environment.\nConnect to different LLMs with a single line of code. Iterate quickly as you find what suits your use case.\nDeliver accurate and contextual answers with powerful hybrid search under the hood.\nSimplifying RAG adoption - personalize, customize, and optimize with ease\nMultimodal Retrieval"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The code for the benchmarks can be found in this GitHub repo. You can find the following vector database performance benchmarks. The benchmarks were created to test the performance of a number of different databases. The benchmark results are based on a set of different data structures. For more information on the benchmarks, visit the GitHub repo for the code."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/benchmarks",
          "webPageMainText": "You can find the following vector database performance benchmarks:\nThe code for the benchmarks can be found in this GitHub repo.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collects some telemetry data. This data helps Weaviate to identify usage trends and improve our software for our users. You can disable telemetry at any time. If you have any questions or feedback, let us know in the user forum. Back to the page you came from."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/telemetry",
          "webPageMainText": "In order to better understand community needs, Weaviate collects some telemetry data. This data helps Weaviate to identify usage trends and improve our software for our users. Weaviate collects this information by default, but you can disable telemetry at any time.\nOn startup, the Weaviate server generates a unique instance ID. Every 24 ours the instance sends this information:\nWeaviate does not collect any other telemetry information.\nTo disable telemetry data collection, add this line to your system configuration file:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "BM25 (Best match 25) search returns objects that have the highest BM25F scores. To use BM25 keyword search, define a search string. The BM25 query string is tokenized before it is used to search for objects using the inverted index. Use offset to paginate the results."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/bm25#group-results",
          "webPageMainText": "Keyword search, also called \"BM25 (Best match 25)\" or \"sparse vector\" search, returns objects that have the highest BM25F scores.\nTo use BM25 keyword search, define a search string.\nThe response is like this:\nYou can retrieve the BM25F score values for each returned object.\nThe response is like this:\nA keyword search can be directed to only search a subset of object properties. In this example, the BM25 search only uses the question property to produce the BM25F score.\nThe response is like this:\nYou can weight how much each property affects the overall BM25F score. This example boosts the question property by a factor of 2 while the answer property remains static.\nThe response is like this:\nThe BM25 query string is tokenized before it is used to search for objects using the inverted index.\nYou must specify the tokenization method in the collection definition for each property.\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.25 is released! Updates include named vectors, server telemetry, backend improvements, performance enhancements. The new (v4) release of the Weaviate Python Client is - faster (gRPC), provides better IDE support and more type-safety. Check out the new release and let us know what you think!"
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/engineering",
          "webPageMainText": "We're pleased to share that the Weaviate v3 TypeScript client is now stable!\nWeaviate 1.25 is released! Updates include ...\nIn-depth technical breakdown of how binary quantization works and how to use it in Weaviate.\nBoosting Weaviate using SIMD-AVX512, Loop Unrolling and Compiler Optimizations\nA beta release of our new TypeScript client is now available! Help us make it better by trying it out and providing your feedback.\nWeaviate 1.24 is released! Updates include named vectors, server telemetry, backend improvements, performance enhancements.\nLearn how gRPC improves import and query speeds in Weaviate\nThe new (v4) release of the Weaviate Python Client is - faster (gRPC), provides better IDE support and more type-safety, and many other developer experience improvements. Check out the new release and let us know what you think!\nWeaviate 1.23 released with AutoPQ, flat indexing + Binary Quantization, OSS LLM support through Anyscale, and more!\nLearn about high-availability setups with W"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with Ollama's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/ollama",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nThe Ollama library allows you to easily run a wide range of models on your own device. Weaviate seamlessly integrates with the Ollama library, allowing users to leverage compatible models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\nWeaviate integrates with compatible Ollama models by accessing the locally hosted Ollama API.\n\nOllama's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with Ollama's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nOllama embedding integration page\n\nOllama's generative AI models can gener"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A Generative Feedback Loop is the idea of using a Large Language Model (LLM) to generate data, then using that data to drive a semantic search. This is an incredibly powerful use case that can enable a whole new kind of search experience. By providing data to an LLM, you have an opportunity to enrich, enhance or even summarize it."
              }
            ]
          },
          "url": "https://weaviate.io/blog/generative-feedback-loop-with-weaviate-and-spcs#implementing-a-generative-feedback-loop-with-weaviate",
          "webPageMainText": "\nYou can follow along the demo on the Weaviate SPCS Repo.\nAs described in my colleague Connor Shorten\u2019s blog post, a Generative Feedback Loop is the idea of using a Large Language Model (LLM) to generate data, then using that data to drive a semantic search. This is an incredibly powerful use case that can enable a whole new kind of search experience. By providing data to an LLM, you have an opportunity to enrich, enhance or even summarize it which can enable new opportunities to search through your data and provide better search results.\nIn a recent blog post from another colleague, Leonie Monigatti shows an example of doing this by summarizing user reviews for products, then using the summaries as a way to give users the highlights from a lot of review information. Amazon has recently started doing this for certain products, which helps users reduce time spent reading several reviews before making a decision.  \nIn this blog, we are going to take Leonie\u2019s example a step further and us"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "WCD has automated, daily backups. Clusters are provisioned for common usage scenarios. WCD monitors each instance to determine when a cluster needs to be resized. If you want to customize your cluster provisioning, contact our support team at support@weaviate.io to discus."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/faq#can-i-reset-or-change-my-account-password",
          "webPageMainText": "Frequently asked questions (FAQs) for WCD.\nYes. Go the WCD login page and click the \"Log in\" button. Then, click \"Forgot Password\". Enter your email address on the next screen. WCD sends a reset email to the address you enter.\nIf you do not receive a verification email, check your spam folder. If you still cannot find it, follow the steps to reset you password to get a new letter.\nYes. WCD has automated, daily backups. WCD also backs up your data before updating the version of Weaviate running on your cluster.\nYes. Click the \"Details\" button for your cluster. If a new version is available, click the \"Update!\" button when you have a suitable maintenance window. The button is only visible when there is a newer version available.\nNot currently. Clusters are provisioned for common usage scenarios. WCD monitors each instance to determine when a cluster needs to be resized.\nPossibly. If you want to customize your cluster provisioning, contact our support team at support@weaviate.io to discus"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-aws module allows Weaviate to access AWS Bedrock and AWS Sagemaker services. The module accepts parameters through the request header, collection configuration, or environment variables. To use the module, enable it in your Docker Compose file ( docker-compose.yml)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-aws#supported-models",
          "webPageMainText": "Starting in v1.22.5, AWS Bedrock is supported.\nStarting in v1.24.1, AWS Sagemaker is supported.\nThe text2vec-aws module allows Weaviate to access AWS Bedrock and AWS Sagemaker services.\nIf you need to run your own embedding service, use Sagemaker. Bedrock uses AWS models.\nThe module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways.\nWhere the same parameter can be set in multiple ways, setting it at query-time through the HTTP request header (if possible) will have the highest precedence.\nWe suggest you only set any given parameter in one place to avoid confusion.\nYou must provide access key based AWS credentials to use the API, including an AWS access key and a corresponding AWS secret access key. You can set them as environment variables, or provide them at query time.\nTo use text2vec-aws, enable it in your Docker Compose file (docker-compose.yml).\nThis configuration doe"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue. Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/filters#filter-structure",
          "webPageMainText": "Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion. The operator used for filtering is also called a where filter.\nA filter may consist of one or more conditions, which are combined using the And or Or operators. Each condition consists of a property path, an operator, and a value.\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\nFor example, this filter will only allow objects from the class Article with a wordCount that is GreaterThan than 1000.\nThe where filter is an algebraic object, which takes the following arguments:\nIf the operator is And or Or, the operands are a list of where filters.\nWeaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue.\nThe behavior for the Equal operator on multi-word textual properties in where filters depends on the tokenization of the property.\nSee the Schema p"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#variables-2",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Neople is a startup that uses generative artificial intelligence to create digital co-workers. Neople Assistants are uniformly integrated with the tools businesses already use to process customer support cases. The company\u2019s brain, or operating hub, is built on AWS with Weaviate as their vector database of choice."
              }
            ]
          },
          "url": "https://weaviate.io/case-studies/neople",
          "webPageMainText": "Learn how Neople Assistants transform customer service with Weaviate\nNeople is a startup that uses generative artificial intelligence (GenAI) to create digital co-workers, called Neople Assistants, that help businesses achieve their customer service goals. Neople Assistants are uniformly integrated with the tools businesses already use to process customer support cases. In order to deliver world-class support, these digital co-workers must process large amounts of information from a variety of sources before responding to a customer case, just like a human support agent would.\n The company\u2019s brain, or operating hub, is built on AWS with Weaviate as their vector database of choice for reliable, accurate and fast querying of company-specific knowledge. With a scalable and secure AI stack, Neople\u2019s powerful platform is setting the standard for trusted human-AI interaction and has the potential to revolutionize the way we approach work.\nAs Job Nijenhuis, co-founder and CTO, began building "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This Data Processing Agreement (\"Agreement\") forms part of the Contract for Services (\"Principal Agreement\"). The Agreement is intended to last until the end of the contract in May 2024. The Agreement includes a number of provisions relating to data processing and data storage. The agreement is not intended to be used for any other purpose."
              }
            ]
          },
          "url": "https://weaviate.io/dpa",
          "webPageMainText": "Last Updated: May 2024\nThis Data Processing Agreement (\"Agreement\") forms part of the Contract for Services (\"Principal Agreement\").\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate stores data objects in class-based collections. Each data object in Weaviate belongs to a collection and has one or more properties. Data objects are represented as JSON-documents. Objects normally include a vector that is derived from a machine learning model. The vector is also called an embedding or a vector embedding."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/data",
          "webPageMainText": "Each data object in Weaviate belongs to a collection and has one or more properties.\nWeaviate stores data objects in class-based collections. Data objects are represented as JSON-documents. Objects normally include a vector that is derived from a machine learning model. The vector is also called an embedding or a vector embedding.\nEach collection contains objects of the same class. The objects are defined by a common schema.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nImagine we need to store information about an author named Alice Munro. In JSON format the data looks like this:\nYou can also attach vector representations to your data objects. Vectors are arrays of numbers that are stored under the \"vector\" property.\nIn this example, the Alice Munro data object has a small vector. The vector is some information about Alice, maybe a story or an image, that a machine "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We'll use data from a popular quiz game show called Jeopardy!. The original dataset can be found here on Kaggle, but we'll use a small subset from it, just containing 100 rows. The name refers to each row or item (note: singular), so I called itJeopardyQuestion. Then, I need to define properties and types."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports/example",
          "webPageMainText": "It's time to put what we've learned into action! In this section, we will:\nWe are going to use data from a popular quiz game show called Jeopardy!.\nThe original dataset can be found here on Kaggle, but we'll use a small subset from it, just containing 100 rows.\nHere's a preview of a few rows of data.\nFor now, let's keep it simple by populating Weaviate with just the Round, Value, Question and Answer columns.\nCan you remember what the next steps should be?\nThe next step is to build a schema, making some decisions about how to represent our data in Weaviate.\nFirst of all, we'll need a name. The name refers to each row or item (note: singular), so I called it JeopardyQuestion. Then, I need to define properties and types.\nYou saw above that we'll be populating Weaviate with Round, Value, Question and Answer columns. We need names for Weaviate properties - these names are sensible, but we follow the GraphQL convention of capitalizing classes and leaving properties as lowercases, so the name"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "For best performance, we recommend using batching for insertion and deletion. For sending data objects to Weaviate in bulk, use the /v1/batch/objects endpoint. For the long-form beacon, you always need to specify the full beacon, including the referenceproperty name."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/batch",
          "webPageMainText": "For sending data objects to Weaviate in bulk.\nFor best performance, we recommend using batching for insertion and deletion. Also consider that:\nThe URL supports an optional consistency level query parameter:\nThe POST body requires the following field:\nFor batch adding cross-references between data objects in bulk.\nThe URL supports an optional consistency level query parameter:\nThe POST body is an array of elements with the following fields:\nFor backward compatibility, you can omit the collection name in the\nshort-form beacon format that is used for to. You can specify it as\nweaviate://localhost/{id}. This is, however, considered deprecated and will be\nremoved with a future release, as duplicate IDs across collections could mean that\nthis beacon is not uniquely identifiable. For the long-form beacon - used as part\nof from - you always need to specify the full beacon, including the reference\nproperty name.\nYou can use the HTTP verb DELETE on the /v1/batch/objects endpoint to delete all o"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/resources#vector-cache",
          "webPageMainText": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. While you design you system, keep in mind CPU and memory management. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role.\nYou can set environment variables to manage Weaviate's resource usage, as to prevent Weaviate from using all available resources. The following environment variables are available:\nLIMIT_RESOURCES: When set to true, Weaviate automatically limits its resource usage. It sets memory usage to 80% of the total memory and uses all but one CPU core. It overrides any GOMEMLIMIT values but respects GOMAXPROCS settings.\nGOMEMLIMIT: This sets the memory limit for the Go runtime, which should be around 10-20% of the total memory available for Weaviate. It controls the aggressiveness of the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We are thrilled that you want to contribute to Weaviate core. We strive to build an engaging community and we encourage you to participate, share your ideas and make friends. We recommend reading through the Contributors' getting started guide first. To get involved in our co"
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide",
          "webPageMainText": "\n\ud83c\udf89 First off, thank you for taking the time to contribute! \ud83c\udf89\nWe are delighted to have you here. We are thrilled that you want to contribute to Weaviate core, as together we can make Weaviate even better. We strive to build an engaging community and we encourage you to participate, share your ideas and make friends.\nIf you're using Weaviate or if you like the project, please \u2b50 this repository  to show your support!\nWe recommend reading through the Contributors' getting started guide first. That includes suggestions on different ways to contribute, as well as how you can make those contributions.\nThis guide also includes the following sections on specific areas. You can think of these as more technical, reference guides on each area for contributors.\nA lot of community chat happens on the Weaviate Community Slack, with longer-form discussions taking place on the forum\nMany members of our community help us by giving feedback, asking questions, or proposing ideas. To get involved in our co"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If not specified explicitly, the default distance metric in Weaviate iscosine. It can be set in the vectorIndexConfig field as part of the schema to any of the following types: larger distance values indicate lower similarity. If you're missing your favorite distance type and would like to contribute it, we'd be happy to review your PR."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/distances#distance-implementations-and-optimizations",
          "webPageMainText": "If not specified explicitly, the default distance metric in Weaviate is\ncosine. It can be set in the vectorIndexConfig field as part of the schema (example) to any of the following types:\nIn all cases, larger distance values indicate lower similarity. Conversely, smaller distance values indicate higher similarity.\nIf you're missing your favorite distance type and would like to contribute it to Weaviate, we'd be happy to review your PR.\nOn a typical Weaviate use case the largest portion of CPU time is spent calculating vector distances. Even with an approximate nearest neighbor index - which leads to far fewer calculations - the efficiency of distance calculations has a major impact on overall performance.\nYou can use the following overview to find the best possible combination of distance metric and CPU architecture / instruction set.\nIf you like dealing with Assembly programming, SIMD, and vector instruction sets we would love to receive your contribution for one of the combinations t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page has links to the developer release notes for the Weaviate core database and the client libraries. For descriptive notes on recent major releases, follow the links in the table of contents at the left of this page. For older releases, see the blog pages at Weaviates.io."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes#weaviate-core-release-summaries",
          "webPageMainText": "This page has links to the developer release notes for the Weaviate core database and the client libraries. To see release notes for a particular version, click on the version number.\nFor descriptive notes on recent major releases, follow the links in the table of contents at the left of this page. For descriptive notes on older releases, see the blog pages at Weaviate.io.\nFor links to the Weaviate Core releases, expand this section.\nFor links to the Python Client releases, expand this section.\nThe JavaScript client is no longer maintained. The TypeScript client accepts code written in JavaScript and TypeScript. Migrate your JavaScript client code to the TypeScript client.\nFor links to the TypeScript Client releases, expand this section.\nFor links to the JavaScript Client releases, expand this section.\nFor links to the Go Client releases, expand this section.\nFor links to the Java Client releases, expand this section.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Ollama's models allows you to access their models' capabilities directly from Weaviate. This integration requires a locally running Ollamas instance with your selected model available. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/ollama/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Ollama's models allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an Ollama embedding model, and Weaviate will generate embeddings for various operations using the specified model via your local Ollama instance. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nThis integration requires a locally running Ollama instance with your selected model available. Refer to the Ollama documentation for installation and model download instructions.\nYour Weaviate instance must be configured with the Ollama vectorizer integration (text2vec-ollama) module.\nThis integration is not available for Weaviate Cloud (WCD) serv"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has a robust, production-ready database that can scale as our users do. For example, many of our users already run Weaviate with multi-tenancy (introduced in version 1.20) to host thousands of active tenants or even more. One side effect of scaling is that as load increases on each node, it will take longer to start up."
              }
            ]
          },
          "url": "https://weaviate.io/blog/zero-downtime-upgrades",
          "webPageMainText": "\nLike the old saying goes, a chain is only as strong as its weakest link. For tech infrastructure products, the weak link can often be its uptime. Think about how big a deal it is when social networks, web apps or databases are not available.\nThis is why we at Weaviate really pride ourselves on having a robust, production-ready database that can scale as our users do. For example, many of our users already run Weaviate with multi-tenancy (introduced in version 1.20) to host thousands of active tenants or even more.\nOne side effect of scaling is that as load increases on each node, it will take longer to start up. While a fresh Weaviate instance typically starts up essentially instantaneously, a node with 1000s of tenants can take up over 1 minute.\nNode-level downtime is an unavoidable fact of life, since either hardware and software may necessitate restarts for maintenance and/or updates. But node-level downtime doesn\u2019t have to lead to user-level downtime and failed requests.\nHow, you "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Self-Supervised Learning has led to massive advances in generative modeling and representation learning. In this article, we will explain Span-based Unsupervised Dense Retriever (Spider), a recent breakthrough for Self- Supervised representation learning applied to text retrieval in search. The results Spider achieves are extremely exciting!"
              }
            ]
          },
          "url": "https://weaviate.io/blog/research-insights-spider",
          "webPageMainText": "\nThere is a lot of excitement around Deep Learning systems with new ML models being trained every day. However, they have been limited by the need for large labeled datasets, which leads us on a search for other solutions that could help us avoid that limitation.\nWe found interesting ideas in the Learning to Retrieve Passages without Supervision paper by Ori Ram, Gal Shachaf, Omer Levy, Jonathan Berant and Amir Globerson. The authors explore\nSelf-Supervised Learning \u2013 a class of learning algorithms that can bootstrap loss functions \u2013 as an alternative route to training new models without the need for human labeling!\nSelf-Supervised Learning has led to massive advances in generative modeling and representation learning. In this article, we will explain Span-based Unsupervised Dense Retriever (Spider), a recent breakthrough for Self-Supervised representation learning applied to text retrieval in search.\nThe results Spider achieves are extremely exciting! The headline is that Spider's Zer"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate TypeScript client supports TypeScript and JavaScript. Use the TypeScript v3 client for new projects. If your application is browser based, consider using the Type Script client v2. The v3 Client uses ES Modules and CommonJS compatibility. The client is version v3.0.5. See v3 packages for details."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript/typescript-v3#design-philosophy",
          "webPageMainText": "The TypeScript client is version v3.0.5. Use the TypeScript v3 client for new projects.\nThe Weaviate TypeScript client supports TypeScript and JavaScript.\nThe v3 client supports server side development (Node.js hosted). See v3 packages for details. If your application is browser based, consider using the TypeScript client v2.\nIf you are migrating a project from the Weaviate TypeScript client v2 to the v3 client, see the migration page for additional details.\nThis section details how install and configure the v3 TypeScript client.\nThe v3 client package has a new name, weaviate-client. Use npm to install the TypeScript client library package:\nThe v3 client uses ES Modules. Most of the sample code in the documentation also uses the ES Module style.\nIf your code requires CommonJS compatibility, use the CommonJS import style:\nEdit your project's configuration files to make these changes:\nThe v3 client provides helper functions to connect your application to your Weaviate instance.\nEmbedded "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.21 released with new operators, performance improvements, multi-tenancy improvements, and more. Learn about the six pillars outlining how Weaviate will evolve in 2023.Learn about the hardware, software and performance metric specifications behind our ~1B object import of the Sphere dataset."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/engineering/page/2",
          "webPageMainText": "The details behind how you can compress vectors using PQ with little loss of recall!\nHow hybrid search works, and under the hood of Weaviate's fusion algorithms.\nWeaviate 1.21 released with new operators, performance improvements, multi-tenancy improvements, and more!\nLearn about our latest open source demo and how we used Semantic and Generative Search to improve access to health\nWeaviate 1.20 released with multi-tenancy, PQ, search re-ranking, autocut, hybrid fusion algorithm ... take a look!\nLearn about the new native multi-tenancy feature\nLearn about how to monitor Weaviate in production and observe key metrics.\nLearn about the six pillars outlining how Weaviate will evolve in 2023.\nLearn about the hardware, software and performance metric specifications behind our ~1B object import of the Sphere dataset into Weaviate.\nThe Lock Striping pattern is a great way to solve race conditions without sacrificing performance. Lean about Weaviate's improvements.\nGo 1.19 introduced GOMEMLIMIT,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with the Meta ImageBind library allows you to access its capabilities directly from Weaviate. The ImageBind model supports multiple modalities (text, image, audio, video, thermal, IMU and depth)Configure a Weaviates vector index to use the ImageBind integration."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/imagebind/embeddings-multimodal",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with the Meta ImageBind library allows you to access its capabilities directly from Weaviate. The ImageBind model supports multiple modalities (text, image, audio, video, thermal, IMU and depth).\nConfigure a Weaviate vector index to use the ImageBind integration, and configure the Weaviate instance with a model image, and Weaviate will generate embeddings for various operations using the specified model in the ImageBind inference container. This feature is called the vectorizer.\nAt import time, Weaviate generates multimodal object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts queries of one or more modalities into embeddings.\n\nYour Weaviate instance must be configured with the ImageBind vectorizer integration (multi2vec-bind) module.\nThis integration is not available for Weaviate Cl"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-voyageai module enables Weaviate to obtain vectors using Voyage AI. To use it, you must enable it in your Docker Compose file ( docker-compose.yml) The module accepts parameters through the request header, collection configuration, or environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-voyageai",
          "webPageMainText": "The text2vec-voyageai module enables Weaviate to obtain vectors using Voyage AI.\nKey notes:\nThe module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways.\nWhere the same parameter can be set in multiple ways, setting it at query-time through the HTTP request header (if possible) will have the highest precedence.\nWe suggest you only set any given parameter in one place to avoid confusion.\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use text2vec-voyageai, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables text2vec-voyageai, sets it as the default vectorizer, and sets the API keys.\nYou can configure how the module will behave in each class through the Weaviate schema.\nThe f"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate TypeScript client supports TypeScript and JavaScript. Use the TypeScript v3 client for new projects. If your application is browser based, consider using the Type Script client v2. The v3 Client uses ES Modules and CommonJS compatibility. The client is version v3.0.5. See v3 packages for details."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript/typescript-v3#connect-to-weaviate",
          "webPageMainText": "The TypeScript client is version v3.0.5. Use the TypeScript v3 client for new projects.\nThe Weaviate TypeScript client supports TypeScript and JavaScript.\nThe v3 client supports server side development (Node.js hosted). See v3 packages for details. If your application is browser based, consider using the TypeScript client v2.\nIf you are migrating a project from the Weaviate TypeScript client v2 to the v3 client, see the migration page for additional details.\nThis section details how install and configure the v3 TypeScript client.\nThe v3 client package has a new name, weaviate-client. Use npm to install the TypeScript client library package:\nThe v3 client uses ES Modules. Most of the sample code in the documentation also uses the ES Module style.\nIf your code requires CommonJS compatibility, use the CommonJS import style:\nEdit your project's configuration files to make these changes:\nThe v3 client provides helper functions to connect your application to your Weaviate instance.\nEmbedded "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "With Weaviate you can query your data using vector similarity search, keyword search, or a mix of both with hybrid search. You can control what object properties and metadata to return. This page provides fundamental search syntax to get you started.You can get objects without specifying any parameters. This returns objects ordered by their UUID."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/basics#specify-the-fetched-properties",
          "webPageMainText": "With Weaviate you can query your data using vector similarity search, keyword search, or a mix of both with hybrid search. You can control what object properties and metadata to return.\nThis page provides fundamental search syntax to get you started.\nYou can get objects without specifying any parameters. This returns objects ordered by their UUID.\nThe output is like this:\n  Specify the information that you want your query to return. You can return object properties, object IDs, and object metadata.\nUse limit to set a fixed maximum number of objects to return.\nThe output is like this:\nTo start in the middle of your result set, define an offset. Set a limit to return objects starting at the offset.\nThe output is like this:\nTo paginate through the entire database, use a cursor instead of offset and limit.\nYou can specify which object properties to return.\nThe output is like this:\nYou can retrieve the object vector. (Also applicable where named vectors are used.)\nThe output is like this:\nY"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This 5-minute video provides an overview of all three workflows, with code examples shown in Python. When importing objects into Weaviate, you can choose to: import, export, or query. You can find the accompanying Jupyter notebook and data at this repository."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/vector-provision-options",
          "webPageMainText": "When importing objects into Weaviate, you can choose to:\nThis 5-minute video provides an overview of all three workflows, with code examples shown in Python.\nWe recommend that you go through the Quickstart tutorial before watching this video, or to make sure you are familiar with the basic of a schema, import, and query in Weaviate.\nYou can find the accompanying Jupyter notebook and data at this repository.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with GPT4All's models allows you to access their models' capabilities directly from Weaviate. The integration is only available for amd64/x86_64 architecture devices, as the gpt4all library currently does not support ARM devices, such as Apple M-series."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/gpt4all/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with GPT4All's models allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an GPT4All embedding model, and Weaviate will generate embeddings for various operations using the specified model via the GPT4All inference container. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nThis module is optimized for CPU using the ggml library, allowing for fast inference even without a GPU.\nCurrently, the GPT4All integration is only available for amd64/x86_64 architecture devices, as the gpt4all library currently does not support ARM devices, such as Apple M-series.\nYour Weaviate instance must be configured with the GPT4All "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The v4 Weaviate Python client library has landed in GA (general availability) form. The v4 client has a brand new API that is more powerful and easier to use. It still includes the existing (v3) API for now, so you can continue to use it without any changes."
              }
            ]
          },
          "url": "https://weaviate.io/blog/py-client-v4-release",
          "webPageMainText": "\nThe v4 Weaviate Python client library has landed in GA (general availability) form. The v4 client has a brand new API that is more powerful and easier to use \ud83c\udf89\ud83e\udd73. This is a big update, as reflected by the bump in the major version number.\nIt still includes the existing (v3) API for now, so you can continue to use it without any changes. But we do note and the v3 API is considered deprecated, and will be removed in the future (estimated ~6 months).\nIf you're keen to get on with it, just pip install it with:\nBut if you're curious about what's new, read on - there's a lot that we are excited about!\nThe v4 client does things a little differently than the v3 client. Two of the key ideas where it differs are:\nTake this query, for example:\nHere, you'll notice that the query:\nThis is because the v4 client is collection-based, and will return all properties (except blobs and references) by default. We think this makes the code more concise, and easier to use.\nAnd writing the queries is now also"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "To configure Weaviate in a Docker or a Kubernetes deployment, set these environment variables. For Boolean environment variables, \"on\", \"enabled\", \"1\", and \"true\" are interpreted as true. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/env-vars#general",
          "webPageMainText": "To configure Weaviate in a Docker or a Kubernetes deployment, set these environment variables\nFor Boolean environment variables, \"on\", \"enabled\", \"1\", and \"true\" are interpreted as true.\nAll other values are interpreted as false.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The cross-reference type is the graph element of Weaviate. It allows you to link to any number of instances of a given class. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/datatypes",
          "webPageMainText": "When creating a property, Weaviate needs to know what type of data you will give it. Weaviate accepts the following types:\nRefer to this section on how to configure the tokenization behavior of a text property.\nPrior to v1.19, Weaviate supported an additional datatype string, which was differentiated by tokenization behavior to text. As of v1.19, this type is deprecated and will be removed in a future release.\nUse text instead of string. text supports the tokenization options that are available through string.\nThe cross-reference type is the graph element of Weaviate: you can create a link from one object to another. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema. For example:\nThe cross-reference type objects are arrays by default. This allows you to link to any number of instances of a given class (including zero).\nIn the above example, our objects "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model. It encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware. The ONNX-enabled images can use ONNx Runtime for faster inference processing on CPUs."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-transformers#how-to-use",
          "webPageMainText": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model.\ntext2vec-transformers encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nTransformer model inference speeds are usually about ten times faster with GPUs. If you have a GPU, use one of the GPU enabled models.\nIf you use text2vec-transformers without GPU acceleration, imports or nearText queries may become bottlenecks. The ONNX-enabled images can use ONNX Runtime for faster inference processing on CPUs. Look for the -onnx suffix in the image name.\nAlternatively, consider one of the following options:\nThis module is not available on Weaviate Cloud.\nTo use text2vec-transformers, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to genera"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's documentation is built with a static site builder (Docusaurus) with data from our GitHub repository. If you spot any typos, errors, unclear explanations, missing references or anything that stands out, please let us know, and we can work on it together."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/getting-started/improving-docs",
          "webPageMainText": "Maintaining consistent, accurate and readable documentation is way to improve the user experience for everybody, including experienced users.\nThe truth is that while we try our best, mistakes happen (we are not perfect! \ud83d\ude05). And if you found something difficult to understand, others may have too, which presents an opportunity for improvement.\nSo if you spot any typos, errors, unclear explanations, missing references or anything that stands out, please let us know, and we can work on it together.\nWeaviate's documentation is built with a static site builder (Docusaurus) with data from our GitHub repository. Before you get started, we suggest you set up a local development environment first. This will allow you to preview any changes on your computer as you work on it.\nFor instructions on setting up the development environment, please take a look at this README file.\nOnce your local environment is set up, you can make your proposed changes, preview them locally, and submit them for review."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.16 introduced the Ref2Vec module. It offers the ability to vectorize a data object with its cross-references to other objects. The module currently holds the name ref2vec-centroid because it uses the average, or centroid vector, to represent the referencing object."
              }
            ]
          },
          "url": "https://weaviate.io/blog/ref2vec-centroid",
          "webPageMainText": "\nWeaviate 1.16 introduced the Ref2Vec module. In this article, we give you an overview of what Ref2Vec is and some examples in which it can add value such as recommendations or representing long objects.\nThe name Ref2Vec is short for reference-to-vector, and it offers the ability to vectorize a data object with its cross-references to other objects. The Ref2Vec module currently holds the name ref2vec-centroid because it uses the average, or centroid vector, of the cross-referenced vectors to represent the referencing object. The benefit of this approach is that the referencing object can be characterized from its actions and relationships as well as refined over time.\nIn one example, we could use Ref2Vec in a Weaviate database containing User and Product classes of objects to produce recommendations. Here, the Product class may include various types of vectorized items, such as shoes, or clothing, and a User could be vectorized by its relationships to Product instances. So a User who h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Anyscale's Endpoints allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. We would like to hear from you about your experiences with this integration. Please post your feedback in the comments section below."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/anyscale/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Anyscale's Endpoints APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use an Anyscale generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model and your Anyscale API key.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the Anyscale generative model to generate outputs.\n\nYour Weaviate instance must be configured with the Anyscale generative AI integration (generative-anyscale) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Anyscale API key to Weaviate for this integration. Go to Anyscale to sign up and obtain an API key.\nProvide the API key to Weaviate using one of the following methods:\nCo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Data Controller acknowledges and agrees that the list of subprocessors may be updated from time to time by the Data Processor in accordance with the terms of the Principal Agreement. Last Updated: May, 2024. The following subprocessers are authorized to process Personal Data: Google Cloud Platform (GCP) Google Workspace (formerly G Suite) HubSpot."
              }
            ]
          },
          "url": "https://weaviate.io/subprocessors",
          "webPageMainText": "Last Updated: May, 2024\nThe following subprocessors are authorized by the Data Controller to process Personal Data:\nGoogle Cloud Platform (GCP)\nPurpose: Cloud hosting services.\nLocation: EU-west4\nWebsite: https://cloud.google.com/\nSlack\nPurpose: Communication and collaboration platform.\nLocation: USA\nWebsite: https://slack.com/\nHubSpot\nPurpose: Customer support and relationship management.\nLocation: USA\nWebsite: https://www.hubspot.com/\nGoogle Workspace (formerly G Suite)\nPurpose: Email and collaboration tools.\nLocation: Global\nWebsite: https://workspace.google.com/\nThe Data Controller acknowledges and agrees that the list of subprocessors may be updated from time to time by the Data Processor in accordance with the terms of the Principal Agreement.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The gRPC API is faster than the REST API. Use it to improve import speeds. Batch imports are an efficient way to add multiple data objects and cross-references. To create a bulk import job, follow these steps:The following example adds objects to the MyCollection collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/import#tip-stream-data-from-large-files",
          "webPageMainText": "Batch imports are an efficient way to add multiple data objects and cross-references.\nTo create a bulk import job, follow these steps:\nThe following example adds objects to the MyCollection collection.\nThe gRPC API is faster than the REST API. Use the gRPC API to improve import speeds.\nThe Python client uses gRPC by default. See the client page for additional batch import configuration options.\nThe TypeScript client v3 uses gRPC by default.\nTo use the gRPC API with the Java client, add the setGRPCHost field to your client connection code. Update setGRPCSecured if you use an encrypted connection.\nTo use the gRPC API with the Go client, add the GrpcConfig field to your client connection code. Update Secured if you use an encrypted connection.\nTo use the gRPC API with the Spark connector, add the grpc:host field to your client connection code. Update grpc:secured if you use an encrypted connection.\nWeaviate generates an UUID for each object. Object IDs must be unique. If you set object ID"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Unbody's first line of code was written in 2016 as a headless CMS for Google Drive. The project kept growing, and fast forward to 2022, during our search for a better search engine, we stumbled upon Weaviate. What started as a simple test quickly led to a rather crazy decision: we migrated our entire content database to Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/blog/unbody-weaviate",
          "webPageMainText": "\nAs developers, we're constantly adapting to the evolution of technology, and nothing signifies this shift more than the transition to AI-first. It's a big move, similar to when the world went mobile-first, but it comes with unique challenges, especially in seamlessly integrating AI into apps and websites. But we've come a long way with Unbody to make this different, and here is our story:\n Wow this is amazing. We are implementing Weaviate into  @unbody_io . It has required us to make some major refactors in our architecture but it's worth it. Thank you for all this amazing work \ud83d\ude0a\nUnbody's first line of code was written in 2016 as a headless CMS for Google Drive. The project kept growing, and fast forward to 2022, during our search for a better search engine, we stumbled upon Weaviate. What started as a simple test quickly led to a rather crazy decision: we migrated our entire content database to Weaviate. This required a ground-up refactoring of our codebase, but actually, it was wort"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate converts a text corpus into a set of vectors - each object is given a vector that captures its 'meaning' Here, we will reproduce Weaviate's output vector using only an external API. We will see how the text vectorization process can be tweaked, before wrapping up by discussing a few considerations."
              }
            ]
          },
          "url": "https://weaviate.io/blog/pulling-back-the-curtains-on-text2vec",
          "webPageMainText": "\nYou probably know that Weaviate converts a text corpus into a set of vectors - each object is given a vector that captures its 'meaning'. But you might not know exactly how it does that, or how to adjust that behavior. Here, we will pull back the curtains to examine those questions, by revealing some of the mechanics behind text2vec's magic.\nFirst, we will reproduce Weaviate's output vector using only an external API. Then we will see how the text vectorization process can be tweaked, before wrapping up by discussing a few considerations also.\nI often find myself saying that Weaviate makes it fast and easy to produce a vector database from text. But it can be easy to forget just how fast and how easy it can make things.\nIt is true that even in the \u201cold days\u201d of say, five to ten years ago, producing a database with vector capabilities was technically possible. You simply had to (inhales deeply) develop a vectorization algorithm, vectorize the data, build a vector index, build a databas"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate offers an optional authentication scheme using API keys and OpenID Connect (OIDC), which can enable various authorizations levels. API key and OIDC authentication can be both enabled at the same time. Weaviate Cloud (WCD) instances are pre-configured for API key authentication."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/authentication",
          "webPageMainText": "Weaviate offers an optional authentication scheme using API keys and OpenID Connect (OIDC), which can enable various authorizations levels.\nWhen authentication is disabled, all anonymous requests will be granted access.\nIn this documentation, we cover all scenarios for your convenience:\nNote that API key and OIDC authentication can be both enabled at the same time.\nFor most use cases, the API key option offers a balance between security and ease of use. Give it a try first, unless you have specific requirements that necessitate a different approach.\nSee this page for how to set up values.yaml for authentication & authorization.\nWeaviate Cloud (WCD) instances are pre-configured for API key authentication.\nTo configure Weaviate for API key-based authentication, add the following environment variables to your configuration file.\nAn example docker-compose.yml file looks like this:\nThe example associates API keys and users.\nThere are two options for configuring the number of keys and users:"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In version 1.20, Weaviate introduced the ability to run reranking at the second stage. In this blog post, I will show you how to fine-tune Cohere\u2019s reranker model. To get started, weaviate developers simply need to add one line of code to their schema."
              }
            ]
          },
          "url": "https://weaviate.io/blog/fine-tuning-coheres-reranker",
          "webPageMainText": "\nSearch engines and retrieval augmented generation (RAG) applications rely heavily on retrieval accuracy. There are many techniques for achieving highly accurate retrieval. One of the most common patterns we\u2019ve seen is multi-stage search. Typically this is in two stages: 1. Gather the relevant objects with the first-stage retriever 2. Send the relevant objects to the reranker to improve the output. Adding reranking to the second-stage is a quick and effective method to boost search relevance.\nIn version 1.20, Weaviate introduced the ability to run reranking at the second stage. To get started, Weaviate developers simply need to add one line of code to their schema reranker-cohere:\nWeaviate developers also have the flexibility to choose two reranking models out of the box:\nNow you have a third option to pass in your fine-tuned reranker model! In this blog post, I will show you how to fine-tune Cohere\u2019s reranker model.\nIn May 2023, Cohere released their rerank endpoint. It enabled users "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A vector is a series of numbers like [1, 0] or [0.513, 0.155, ...] Vectors like these are used to capture meaning. Modern machine learning models such as GPT-x use vectors to represent some \"essence\", or \"meaning\" of objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/overview_vectors#how-do-numbers-represent-meaning",
          "webPageMainText": "We've covered that Weaviate is a vector database, and that a vector search is similarity-based. But, what is a vector?\nA vector in this context is just a series of numbers like [1, 0] or [0.513, 0.155, 0.983, ..., 0.001, 0.932]. Vectors like these are used to capture meaning.\nThis might seem like an odd concept. But in fact, you may have already used vectors to capture meaning without realizing it. If you have tried photo editing, or used MS Paint you might have encountered the RGB color system.\nThe RGB system uses groups of three numbers to represent colors. For example:\nIn these examples, each number can be thought of as a dial for how red, green or blue a color is.\nNow, imagine having hundreds, or even thousands, of these dials. That\u2019s how vectors are used to represent meaning. Modern machine learning models such as GPT-x, or those used with Weaviate, use vectors to represent some \"essence\", or \"meaning\" of objects. This can be done for any object type, such as text, code, images, v"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue. Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/filters#by-null-state",
          "webPageMainText": "Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion. The operator used for filtering is also called a where filter.\nA filter may consist of one or more conditions, which are combined using the And or Or operators. Each condition consists of a property path, an operator, and a value.\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\nFor example, this filter will only allow objects from the class Article with a wordCount that is GreaterThan than 1000.\nThe where filter is an algebraic object, which takes the following arguments:\nIf the operator is And or Or, the operands are a list of where filters.\nWeaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue.\nThe behavior for the Equal operator on multi-word textual properties in where filters depends on the tokenization of the property.\nSee the Schema p"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Multi-Data center (Multi-DC) replication enables you to have multiple copies of the data on multiple servers across more than one data center. This form of replication is not yet supported in v1.17 and v 1.18. If you are interested in this feature, upvote this GitHub issue."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/multi-dc",
          "webPageMainText": "Multi-Data center (Multi-DC) replication enables you to have multiple copies of the data on multiple servers across more than one data center. This form of replication is not yet supported in v1.17 and v1.18. The current version of replication is designed to support Multi-DC later on. If you are interested in this feature, upvote this GitHub issue.\nMulti-DC replication is beneficial if you have user groups spread over different geographical locations (e.g. Iceland and Australia). When you place nodes in different local regions of user groups, latency can be decreased.\nMulti-DC replication also comes with the additional benefit that data is redundant on more physical locations, which means that in the rare case of an entire  data center going down, data can still be served from another location.\nFor now, you can work under the assumption that all replica nodes are in the same  data center. The advantage of this is that network requests between nodes are cheap and fast. The downside is t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate demo sprint is aimed at onboarding engineers and machine learning practitioners to open-source. Participants with four pull requests accepted between October 1 - 31, 2023 will receive a unique digital reward. You can also contribute by adding your own Weaviate examples."
              }
            ]
          },
          "url": "https://weaviate.io/blog/hacktoberfest-2023",
          "webPageMainText": "\nAt Weaviate, we love open source! Join us in celebrating Hacktoberfest, a month-long celebration of open source!\nParticipants with four pull requests (PR) accepted between October 1 - 31, 2023 will receive a unique digital reward from Hacktoberfest.\nWelcome to our demo sprint!\nIt is aimed at onboarding engineers and machine learning practitioners to open-source. In our example use cases and demos page, we showcase what you can do with a vector database. Some of these demos have received more love than others recently, and we want to give them a little polish.\n\nThe gallery contains demos using Weaviate in different states. Here is an example of a demo project in a good state. While some may only need a little polish of the description (README.md file), others are e.g., a little older or can use a little makeover for the user interface.\nThe steps to your first Hacktoberfest PR are simple:\nYou can also contribute by adding your own Weaviate examples. If you have other great ideas for con"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.16 introduces New Filter Operators, Distributed Backups, Centroid Module, Node Status API, Azure-based OIDC, and more. Learn how to use build an image search application using the Img2vec-neural module in Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/blog/page/8",
          "webPageMainText": "Weaviate 1.16 introduces New Filter Operators, Distributed Backups, Centroid Module, Node Status API, Azure-based OIDC, and more. Lear all about it.\nThe Lock Striping pattern is a great way to solve race conditions without sacrificing performance. Lean about Weaviate's improvements.\nLearn how to use build an image search application using the Img2vec-neural module in Weaviate.\nVector search on disks: How does Vamana compare to HNSW?\nLearn about the various Sentence Transformers from Hugging Face!\nRunning ML Model Inference in production is hard. You can use Weaviate \u2013 a vector database \u2013 with Hugging Face Inference module to delegate the heavy lifting.\nTwo weeks after the 1.15 release, we have a patch (v1.15.1) release for you, which brings 15 bug fixes and 2 UX improvements.\nVector Databases can run semantic queries on multi-million datasets in milliseconds. How is that possible?\nWeaviate 1.15 introduces Cloud-native Backups, Memory Optimizations, faster Filtered Aggregations and Orde"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We\u2019re excited to share the details of our newly launched Weaviate Hero Program. Let\u2019s find out more about the program and how you can be a part of it. Click through the gallery to find out how to join the program. For more information on the program, visit WeaviatesHero.com."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/community",
          "webPageMainText": "We\u2019re excited to share the details of our newly launched Weaviate Hero Program! Let\u2019s find out more ...\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The reranker-transformers module enables using sentence transformers models as a second stage re-ranking for vector, bm25 and hybrid search results. It can be configured for any collection in the Schema. The re Rankers module is not available on the WCD."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/reranker-transformers",
          "webPageMainText": "The reranker-transformers module is not available on the WCD.\nAdd reranker-transformers to the ENABLE_MODULES environment variable.\nBelow is an example Docker Compose file, which will spin up Weaviate with the reranker-transformers module (as well as text2vec-openai).\nIt also configures reranker-transformers to use the cross-encoder/ms-marco-MiniLM-L-6-v2 model, with CUDA acceleration disabled.\nThe reranker-transformers module can be configured for any collection in the schema.\nIf there is only one reranker module enabled, you don't need to do anything. The reranker module will be used by default.\nWhere multiple reranker modules are enabled, you must specify the reranker module to be used for each collection. You can do this by adding the desired reranker in the moduleConfig section of the schema, even without any further settings.\nThe reranker-transformers module enables using sentence transformers models as a second stage re-ranking for vector, bm25 and hybrid search results.\nWith re"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Tested this with the new DALL-E-3 and it works! If you take words and pass them back in as prompts, the model can draw for you what the word means to it. For example: \"cagama gur gerano\" = \"a fantasy creature\""
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper13",
          "webPageMainText": "\nTIL that text2image diffusion models learn and use a secret language.\nTested this with the new DALL-E-3 and it works!\ud83e\udd2f\nRead a couple of papers and they mentioned that diffusion models when forced to output text generate images of gibberish words.\nIf you take those words and pass them back in as prompts, the model can draw for you what the word means to it.\nFor example: \"cagama gur gerano\" = \"a fantasy creature\"\nI tested this for the newly released DALL-E-3 model and, interestingly, even when told to generate English it still uses this secret learned language instead.\nBelow is a conversation about fantasy creatures between two farmers in this secret language.\nInitial prompt: \"Two farmers talking about vegetables, with english subtitles.\"\nAfter this just prompt the model with individual and word pairs to get images with secret words. I share examples below.\nPrompt: \"cagama gur gerano\"\n\n\ud83d\udd17 arXiv Link\n\ud83d\udcdc Download paper\nCheck out the Quickstart tutorial, and begin building amazing apps with "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud. Use WCD to simplify development and confidently deploy enterprise-ready AI applications. WCD is built on Weaviate core. They share the same technology, and offer the same great features."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs#bring-your-own-cloud",
          "webPageMainText": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud.\nWCD manages the infrastructure so you can focus on innovation. Use WCD to simplify development and confidently deploy enterprise-ready AI applications.\nWeaviate is more than just a vector database. Weaviate is a scalable, flexible platform. The core, open source project offers vector search, keyword, and hybrid search. It has a plugable architecture to connect with ML models and tools to help you build scalable AI applications.\nWCD is built on Weaviate core. They share the same technology, and offer the same great features. In addition, WCD handles the work of hosting your Weaviate instance. This gets you up and running fast and lets you focus on your application. WCD takes care of the operational details so you don't have to.\nThese pages document the WCD user interface (UI) and WCD specific operational features. For information about the Weaviate database, client APIs, third-party modules, and other features, see th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#technical-considerations",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Binary quantization(BQ) is a vector compression algorithm that allows you to trade-off between retrieval accuracy and memory requirements. To perform search current vector databases build massive vector indices and search over them in memory. This allows for real-time responses to queries however, compute costs can add up."
              }
            ]
          },
          "url": "https://weaviate.io/blog/binary-quantization",
          "webPageMainText": "\nTo perform search current vector databases build massive vector indices and search over them in memory. This allows for real-time responses to queries however, compute costs can add up. Binary quantization(BQ) is a vector compression algorithm that allows you to trade-off between retrieval accuracy and memory requirements.\nLets understand how this technique works by way of an analogy. Imagine every vector you want to store is a home address. The details of this home address allow you to precisely locate where someone lives including the country, state, city, street number, and even down to the house number. The price you pay for this pin-point accuracy is that each address takes up more memory to store, search and read. Similarly, to locate a vector in space you can think of each dimension as instructions on exactly how far to move along an axis. The sign of the number at that dimension tells you which direction to move and the magnitude of the number tells you how much to move in tha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In July, Weaviate hired its first People Operations Manager. People Operations is not just a 21st century name for \u201chuman resources\u201d It is not only operational but also strategic and employee-centric. The difference is marked by emphasizing \u201cpeople\u2019\u2014as in real, whole persons."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/i-recently-onboarded-myself-introducing-people-operations",
          "webPageMainText": "\nIn July I joined Weaviate as our first People Operations Manager. That\u2019s not just a 21st century name for \u201chuman resources\u201d, which was traditionally focused on administrative tasks and often seemed to assume that employee retention was a given. The difference is marked by emphasizing \u201cpeople\u201d\u2014as in real, whole persons.\nWhile People Operations still provides some administrative functions that have not changed much since more conventional days, the main focus has now shifted: today, People Operations is not only operational but also strategic and employee-centric. My goal as People Operations Manager is to build a foundation that can enable and sustain the business, while fostering a high engagement and performing environment. All this leads to additional responsibilities, some of which did not exist before:\nAt Weaviate we go beyond the traditional HR approach by taking responsibility for each employee\u2019s experience, engagement and well-being across the entire period that they\u2019re with us"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate stores data objects in class-based collections. Each data object in Weaviate belongs to a collection and has one or more properties. Data objects are represented as JSON-documents. Objects normally include a vector that is derived from a machine learning model. The vector is also called an embedding or a vector embedding."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/data#lazy-shard-loading",
          "webPageMainText": "Each data object in Weaviate belongs to a collection and has one or more properties.\nWeaviate stores data objects in class-based collections. Data objects are represented as JSON-documents. Objects normally include a vector that is derived from a machine learning model. The vector is also called an embedding or a vector embedding.\nEach collection contains objects of the same class. The objects are defined by a common schema.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nImagine we need to store information about an author named Alice Munro. In JSON format the data looks like this:\nYou can also attach vector representations to your data objects. Vectors are arrays of numbers that are stored under the \"vector\" property.\nIn this example, the Alice Munro data object has a small vector. The vector is some information about Alice, maybe a story or an image, that a machine "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "For more information related to one of the documents below, please reach out to hello@weaviate.io. For more information about the Weaviate App, please visit the App Store's App Store page. The App Store is now available in the U.S. and Canada."
              }
            ]
          },
          "url": "https://weaviate.io/service",
          "webPageMainText": "For more information related to one of the documents below, please reach out to hello@weaviate.io.\nContributors\nCustomers\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#batch-imports",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In May 2023, we published an initial vision for Generative Feedback Loops. We have since extended our experiments from AirBnB listings to Amazon products. Both of these applications illustrate the ability of generative AI to enhance our data. With the emergence of DSPy, we are now entering a new era of control."
              }
            ]
          },
          "url": "https://weaviate.io/blog/hurricane-generative-feedback-loops",
          "webPageMainText": "\nBack in May 2023, we published an initial vision for Generative Feedback Loops, which we have defined to describe saving the outputs of generative AI systems back into databases for future use. We have since extended our experiments from AirBnB listings to Amazon products, even running every component of a Generative Feedback Loop within Snowpark Container Services. Both of these applications illustrate the ability of generative AI to enhance our data. With the emergence of DSPy, we are now entering a new era of control with generative AI systems and are able to create even more compelling examples of Generative Feedback Loops.\nWhen we initially published our predictions for Generative Feedback Loops, we presented Ben Thompson\u2019s Aggregation Theory to describe some of the impacts of this technology. Aggregation Theory describes how \u201ccompanies that win the user experience can generate a virtuous cycle where their ownership of consumers/users attracts suppliers which improves the user ex"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A Generative Feedback Loop is the idea of using a Large Language Model (LLM) to generate data, then using that data to drive a semantic search. This is an incredibly powerful use case that can enable a whole new kind of search experience. By providing data to an LLM, you have an opportunity to enrich, enhance or even summarize it."
              }
            ]
          },
          "url": "https://weaviate.io/blog/generative-feedback-loop-with-weaviate-and-spcs",
          "webPageMainText": "\nYou can follow along the demo on the Weaviate SPCS Repo.\nAs described in my colleague Connor Shorten\u2019s blog post, a Generative Feedback Loop is the idea of using a Large Language Model (LLM) to generate data, then using that data to drive a semantic search. This is an incredibly powerful use case that can enable a whole new kind of search experience. By providing data to an LLM, you have an opportunity to enrich, enhance or even summarize it which can enable new opportunities to search through your data and provide better search results.\nIn a recent blog post from another colleague, Leonie Monigatti shows an example of doing this by summarizing user reviews for products, then using the summaries as a way to give users the highlights from a lot of review information. Amazon has recently started doing this for certain products, which helps users reduce time spent reading several reviews before making a decision.  \nIn this blog, we are going to take Leonie\u2019s example a step further and us"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/backups",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud is designed to support organizations of all sizes. We can build a tailored plan based on your deployment, training, and support needs. With an enterprise subscription, customers have access to a variety of support and training options to accelerate adoption and success. We manage everything for you in a dedicated instance in Weaviates Cloud."
              }
            ]
          },
          "url": "https://weaviate.io/services",
          "webPageMainText": "Our Services are designed to support organizations of all sizes from prototype to production. Whether you\u2019re a fast-moving startup or a well-established enterprise, we have flexible options to meet your needs.\nWe offer a variety of cloud services and subscriptions to help our customers and open source community deliver valuable solutions. We can build a tailored plan based on your deployment, training, and support needs.\nWe manage everything for you in the Weaviate Cloud.\nBuilding and prototyping with seamless scaling and flexible pay-as-you-go pricing.\nWe manage everything for you in a dedicated instance in Weaviate Cloud.\nDeploying large-scale production use cases without the complexities of self-management.\nChoose a fully-managed solution or 24/7 support within your VPC.\nRunning workflows within your Virtual Private Cloud (VPC).\nWith an enterprise subscription, customers have access to a variety of support and training options to accelerate adoption and success.\nGoogle Cloud Platfor"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "BM25 (Best match 25) search returns objects that have the highest BM25F scores. To use BM25 keyword search, define a search string. The BM25 query string is tokenized before it is used to search for objects using the inverted index. Use offset to paginate the results."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/bm25#autocut",
          "webPageMainText": "Keyword search, also called \"BM25 (Best match 25)\" or \"sparse vector\" search, returns objects that have the highest BM25F scores.\nTo use BM25 keyword search, define a search string.\nThe response is like this:\nYou can retrieve the BM25F score values for each returned object.\nThe response is like this:\nA keyword search can be directed to only search a subset of object properties. In this example, the BM25 search only uses the question property to produce the BM25F score.\nThe response is like this:\nYou can weight how much each property affects the overall BM25F score. This example boosts the question property by a factor of 2 while the answer property remains static.\nThe response is like this:\nThe BM25 query string is tokenized before it is used to search for objects using the inverted index.\nYou must specify the tokenization method in the collection definition for each property.\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open-source vector database. The key difference is that they can perform tasks based on similarity. Using this type of search requires you to identify terms that may be relevant. Weaviate can also be used to store and retrieve data in a variety of ways."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/intro_weaviate",
          "webPageMainText": "Weaviate is an open-source vector database. But what does that mean? Let's unpack it here.\nWeaviate is a fantastic tool for retrieving the information you need, quickly and accurately. It does this by being an amazing vector database.\nYou may be familiar with traditional databases such as relational databases that use SQL. A database can catalog, store and retrieve information. A vector database can carry out these tasks also, with the key difference being that they can perform these tasks based on similarity.\nImagine that you are searching a relational database containing articles on cities, to retrieve a list of \"major\" European cities. Using SQL, you might construct a query like this:\nWhich would return cities that contained any of these strings (major, important, prominent, ... etc) in the wiki_summary column.\nThis works well in many circumstances. However, there are two significant limitations with this approach.\nUsing this type of search requires you to identify terms that may ha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "For new projects, we recommend using the generative-openai module. This uses older models such as gpt-3.5-turbo-instruct. The Question and Answer (Q&A) OpenAI module is a Weaviate module for answer extraction from data. This module can be used in GraphQL Get{...} queries."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/qna-openai",
          "webPageMainText": "For new projects, we recommend using the generative-openai module instead of qna-openai. This uses older models such as gpt-3.5-turbo-instruct which is older than model such as gpt-4 used in generative-openai.\nAdditionally, the generative-openai module is more versatile and can be used for a wider range of use cases, not limited to question answering. Since gpt-3.5-turbo-instruct is not necessarily strictly trained for question answering, there are limited use cases where qna-openai is the best choice.\nThe module usage instructions may vary based on whether you are using OpenAI directly or Azure OpenAI. Please make sure that you are following the right instructions for your service provider.\nFor example, the following may vary:\nThe Question and Answer (Q&A) OpenAI module is a Weaviate module for answer extraction from data. It uses an OpenAI completions endpoint to try and extract an answer from the most relevant docs.\nThis module can be used in GraphQL Get{...} queries, as a search op"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If you have Python 3.8 or higher installed, you can skip the remainder of this section. Another good way to install Python is to install pyenv. This will allow you to manage multiple versions of Python on your system. A virtual environment allows you to isolate various Python projects from each other."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/set_up_python",
          "webPageMainText": "Follow this short guide to make sure that you are set up to use Weaviate with the Python client.\nOpen a terminal window (e.g. bash, zsh, Windows PowerShell, Windows Terminal), and run:\nIf that did not work, you may need to use python3 instead of python:\nIf you have Python installed, you should see a response like Python 3.11.8. If you Python 3.8 or higher installed, you can skip the remainder of this section.\nTo install, follow the instructions for your system on Python.org.\nOnce you have Python installed, check the version again to confirm that you have a recommended version installed.\nAnother good way to install Python is to install pyenv. This will allow you to manage multiple versions of Python on your system. You can find instructions on how to install pyenv here.\nA virtual environment allows you to isolate various Python projects from each other. This is useful because it allows you to install dependencies for each project without affecting the others.\nWe recommend using venv to "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate can be deployed in the following ways:When adding data objects to Weaviate, you have two choices: If you are using a vectorizer module, your choices will depend on your input medium/modality, as well as whether you would prefer a local or API-based vectorizer. Remember, domain-specific and real-world performance may vary."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/starter-guides/which-weaviate",
          "webPageMainText": "Weaviate can be configured and deployed in many different ways. Generally, the two first decisions to make in using Weaviate involve:\nThis page helps you to find the right combination for your needs.\nWeaviate can be deployed in the following ways:\nWhen adding data objects to Weaviate, you have two choices:\nIf you are using a vectorizer module, your choices will depend on your input medium/modality, as well as whether you would prefer a local or API-based vectorizer.\nGenerally speaking, an API-based vectorizer will be more convenient to use, but will incur additional costs. On the other hand, a local vectorizer will be lower cost, but may require specialized hardware (such as a GPU) to run at comparable speeds.\nFor text, this open-source benchmark provides a good overview of the performance of different vectorizers. Remember, domain-specific and real-world performance may vary.\nAs a starting point, we recommend the following setups for different use cases.\nIf you are evaluating Weaviate"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate can automatically replicate data across nodes in the background in a cluster with multiple server nodes. Database replication improves reliability, scalability, and/or performance. The user can control trade-offs between consistency and availability through tunable consistency. Weaviate adopts two different replication architectures for schema consistency and data consistency."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture#cap-theorem",
          "webPageMainText": "Weaviate can automatically replicate data across nodes in the background in a cluster with multiple server nodes. This enables a variety of use cases. For example, if a node goes down, another node can shoulder the load without loss of availability or data. Database replication improves reliability, scalability, and/or performance.\nThe user can control trade-offs between consistency and availability through tunable consistency.\nWeaviate adopts two different replication architectures for schema consistency and data consistency.\nNote that regardless of whether data is replicated, the schema is always replicated across all nodes.\nIn this Replication Architecture section, you will find information about:\n\nDatabase replication refers to keeping a copy of the same data point on multiple nodes of a cluster, which in turn creates a distributed database. A distributed database consists of multiple nodes, all of which can contain a copy of the data. So if one node (server) goes down, users can s"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with the Hugging Face Transformers library allows you to access their CLIP models' capabilities directly from Weaviate.Configure a Weaviates vector index to use the CLIP integration. The model provider integration pages are new and still undergoing improvements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings-multimodal#available-models",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with the Hugging Face Transformers library allows you to access their CLIP models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use the CLIP integration, and configure the Weaviate instance with a model image, and Weaviate will generate embeddings for various operations using the specified model in the CLIP inference container. This feature is called the vectorizer.\nAt import time, Weaviate generates multimodal object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts queries of one or more modalities into embeddings.\n\nYour Weaviate instance must be configured with the CLIP vectorizer integration (multi2vec-clip) module.\nThis integration is not available for Weaviate Cloud (WCD) serverless instances, as it requires spinning up a container with the Hugging Fac"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate can expose Prometheus-compatible metrics for monitoring. A standard Prometheus/Grafana setup can be used to visualize metrics on various dashboards. Metrics are typically scraped into a time-series database, such as Prometheus. Weaviate will expose the metrics at <hostname>:2112/metrics."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/monitoring#obtainable-metrics",
          "webPageMainText": "Weaviate can expose Prometheus-compatible metrics for monitoring. A standard\nPrometheus/Grafana setup can be used to visualize metrics on various\ndashboards.\nMetrics can be used to measure request latencies, import\nspeed, time spent on vector vs object storage, memory usage, application usage,\nand more.\nTo tell Weaviate to collect metrics and expose them in a Prometheus-compatible\nformat, all that's required is to set the following environment variable:\nBy default, Weaviate will expose the metrics at <hostname>:2112/metrics. You\ncan optionally change the port to a custom port using the following environment\nvariable:\nMetrics are typically scraped into a time-series database, such as Prometheus.\nHow you consume metrics depends on your setup and environment.\nThe Weaviate examples repo contains a fully pre-configured setup using\nPrometheus, Grafana and some example\ndashboards.\nYou can start up a full-setup including monitoring and dashboards with a single\ncommand. In this setup the follow"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud. Use WCD to simplify development and confidently deploy enterprise-ready AI applications. WCD is built on Weaviate core. They share the same technology, and offer the same great features."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs",
          "webPageMainText": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud.\nWCD manages the infrastructure so you can focus on innovation. Use WCD to simplify development and confidently deploy enterprise-ready AI applications.\nWeaviate is more than just a vector database. Weaviate is a scalable, flexible platform. The core, open source project offers vector search, keyword, and hybrid search. It has a plugable architecture to connect with ML models and tools to help you build scalable AI applications.\nWCD is built on Weaviate core. They share the same technology, and offer the same great features. In addition, WCD handles the work of hosting your Weaviate instance. This gets you up and running fast and lets you focus on your application. WCD takes care of the operational details so you don't have to.\nThese pages document the WCD user interface (UI) and WCD specific operational features. For information about the Weaviate database, client APIs, third-party modules, and other features, see th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate Cloud (WCD) query application ( query app) is a browser-based GraphQL IDE. Use the query app to work interactively with your WCD clusters. The query app can also connect to other Weaviates instances if you have the proper authorization credentials."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/console",
          "webPageMainText": "The Weaviate Cloud (WCD) query application (query app) is a browser-based GraphQL IDE. Use the query app to work interactively with your WCD clusters.\n\nGraphiQL is built into the query app. GraphiQL provides many features that make GraphQL easier to use interactively:\nTo open the query app, connect to your WCD WCD Dashboard.\nIn the left-hand menu, click the Query app icon.\nThe query app connects directly to your WCD clusters. The query app can also connect to other Weaviate instances if you have the proper authorization credentials.\nIn this example, the WCD Dashboard is connected to an external instance as well as the two WCD instances.\nThe GraphQL console can be used to query any of the three instances.\nClick the Query button for a cluster to open a console window connected to that cluster.\nAlternatively, the query window includes a drop-down menu at the top of the screen which can be used to choose the desired instance.\nThe query app connects to WCD instances, sandboxes and serverles"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Embedded Weaviate is a new deployment model that runs a Weaviates instance from your application code. It creates a permanent datastore in the location set in your persistence_data_path. The next time the client runs, it starts a new instance of Embedded weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/embedded#file-url",
          "webPageMainText": "Embedded Weaviate is experimental software. APIs and parameters may change.\nEmbedded Weaviate is a new deployment model that runs a Weaviate instance from your application code rather than from a stand-alone Weaviate server installation.\nWhen Embedded Weaviate starts for the first time, it creates a permanent datastore in the location set in your persistence_data_path. When your client exits, the Embedded Weaviate instance also exits, but the data persists . The next time the client runs, it starts a new instance of Embedded Weaviate. New Embedded Weaviate instances use the data that is saved in the datastore.\nWhen you exit the client, the Embedded Weaviate instance also exits.\nTo pass additional configuration details to your embedded instance, use a custom connection:\nTo configure Embedded Weaviate, set these variables in your instantiation code or pass them as parameters when you invoke your client. You can also pass them as system environment variables. All parameters are optional.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.17 introduces Replication, Hybrid Search, BM25, Faster Startup and Imports and more. Learn about the hardware, software and performance metric specifications behind our ~1B object import of the Sphere dataset into Weaviate. Get an intuitive understanding of what exactly vector embeddings are and how they're used in semantic search."
              }
            ]
          },
          "url": "https://weaviate.io/blog/page/7",
          "webPageMainText": "Recent advances in AI are breathing new life into podcasting! The Whisper speech-to-text model is a game-changer!\nMachine learning models can create beautiful and novel images. Learn how Diffusion Models work and how you could make use of them.\nGet an intuitive understanding of what exactly vector embeddings are, how they're generated, and how they're used in semantic search.\nEver wonder how Weaviate turns objects into vectors, behind-the-scenes? Find out in this post!\nLearn about the new hybrid search feature that enables you to combine dense and sparse vectors to deliver the best of both search methods.\nLearn about the hardware, software and performance metric specifications behind our ~1B object import of the Sphere dataset into Weaviate.\nWeaviate 1.17 introduces Replication, Hybrid Search, BM25, Faster Startup and Imports and more. Learn all about it.\nCohere announced the release of the text-understanding multilingual model. Learn how to use it in Weaviate.\nLearn how to import and "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This example imports the movie data into our collection. We use the requests library to load the data from the source. The text data is then converted to a Pandas DataFrame. The images are extracted from the Zip file. Then, we create a collection object (with client.collections.get) so we can interact with the collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_collections/import_data",
          "webPageMainText": "This example imports the movie data into our collection.\nThe code:\nWe use the requests library to load the data from the source, in this case a JSON file containing text data and a Zip file containing posters. The text data is then converted to a Pandas DataFrame for easier manipulation and the images are extracted from the Zip file.\nThen, we create a collection object (with client.collections.get) so we can interact with the collection.\nThe batch object is a context manager that allows you to add objects to the batcher. This is useful when you have a large amount of data to import, as it abstracts away the complexity of managing the batch size and when to send the batch.\nThis example uses the .dynamic() method to create a dynamic batcher, which automatically determines and updates the batch size during the import process. There are also other batcher types, like .fixed_size() for specifying the number of objects per batch, and .rate_limit() for specifying the number of objects per min"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "CNN.com will feature iReporter photos in a weekly Travel Snapshots gallery. Please submit your best shots of the U.S. for next week. Visit CNN.com/Travel each week for a new gallery of snapshots. Visit http://www.dailymail.co.uk/travel/features/travellers-take-pictures-of-the-united-kingdom.html#storylink=cpy. We'll feature some of the best shots in next week's gallery."
              }
            ]
          },
          "url": "https://weaviate.io/developers/tags/installation",
          "webPageMainText": "Overview\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This tutorial shows you how to use the Spark Connector to import data into Weaviate from Spark. We will install the python weaviate-client and also run Spark locally. By the end of this tutorial, you'll be able to see how to you can import your data into Apache Spark."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/spark-connector",
          "webPageMainText": "This tutorial is designed to show you an example of how to use the Spark Connector to import data into Weaviate from Spark.\nBy the end of this tutorial, you'll be able to see how to you can import your data into Apache Spark and then use the Spark Connector to write your data to Weaviate.\nWe recommend reading the Quickstart tutorial first before tackling this tutorial.\nWe will install the python weaviate-client and also run Spark locally for which we need to install the python pyspark package. Use the following command in your terminal to get both:\nFor demonstration purposes this tutorial runs Spark locally. See the Apache Spark docs or consult your cloud environment for installation and deploying a Spark cluster and choosing a language runtime other than Python.\nWe will also need the Weaviate Spark connector. You can download this by running the following command in your terminal:\nFor this tutorial, you will also need a Weaviate instance running at http://localhost:8080. This instance"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We have spun up a Weaviate instance in our Kubernetes cluster. The service is not yet accessible from the outside world. We will look at how to access the service, and how to configure it to suit your needs. Run minikube tunnel to expose the service to theoutside world."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/deployment/k8s/access_weaviate",
          "webPageMainText": "We have now spun up a Weaviate instance in our Kubernetes cluster. So what's next? In this section, we will look at how to access the Weaviate service, and how to configure it to suit your needs.\nAlthough our Weaviate service is happily running, it is not yet accessible from the outside world. This is because we have not exposed the service to the outside world. Let's do that now.\nRun the following command:\nYou will recall that we configured the weaviate service as a LoadBalancer type in our Helm chart. So, when we run minikube tunnel, it will expose the service to the outside world - or at least, to our local machine.\nYou will see a message like:\nAt this point you will be asked for your password. Enter it and the tunnel will be established. Note that closing the terminal or stopping the process will close the tunnel, making the services inaccessible again.\nminikube tunnel creates a route between your local machine and the Minikube cluster. This allows services within your Minikube clu"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The multi2vec-clip module enables Weaviate to obtain vectors locally from text or images using a CLIP model. It encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware. As of Weaviates v1.24.2, you can use multiple inference containers."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-clip",
          "webPageMainText": "The multi2vec-clip module enables Weaviate to obtain vectors locally from text or images using a CLIP model.\nmulti2vec-clip encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use multi2vec-clip, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nAs of Weaviate v1.24.2, you can use multiple inference containers with multi2vec-clip. This allows you to use different models for different collections by setting the inferenceUrl in the collection configuration.\nThis configuration enables multi2vec-clip, sets it as the default vectorizer, and sets the parameters for the Docker container, including setting it to use multi2vec-clip:sentence"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Hybrid search feature was introduced in Weaviate 1.17. It uses sparse and dense vectors to represent the semantic meaning and context of search queries and documents. Sparse vectors have mostly zero values with only a few non-zero values. Dense embeddings are generated from algorithms like BM25 and SPLADE."
              }
            ]
          },
          "url": "https://weaviate.io/blog/hybrid-search-explained",
          "webPageMainText": "\nHybrid search is a technique that combines multiple search algorithms to improve the accuracy and relevance of search results. It uses the best features of both keyword-based search algorithms with vector search techniques. By leveraging the strengths of different algorithms, it provides a more effective search experience for users.\nThe Hybrid search feature was introduced in Weaviate 1.17. It uses sparse and dense vectors to represent the semantic meaning and context of search queries and documents.\nIn this blog post, you will learn about the implementation of hybrid search in Weaviate and how to use it.\nSparse and dense vectors are calculated with distinct algorithms. Sparse vectors have mostly zero values with only a few non-zero values, while dense vectors mostly contain non-zero values. Sparse embeddings are generated from algorithms like BM25 and SPLADE. Dense embeddings are generated from machine learning models like\nGloVe and Transformers.\nNote, the current implementation of h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate seamlessly integrates with the GPT4All library, allowing users to leverage compatible models directly within the Weaviate database. These integrations empower developers to build sophisticated AI-driven applications with ease. The model provider integration pages are new and still undergoing improvements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/gpt4all",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nThe GPT4All library allows you to easily run a wide range of models on your own device. Weaviate seamlessly integrates with the GPT4All library, allowing users to leverage compatible models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\nWeaviate integrates with compatible GPT4All models by accessing the locally hosted GPT4All API.\n\nGPT4All's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with GPT4All's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nGPT4All embedding integration page\nThese integrations enable develop"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.22 is already available on Weaviate Cloud - so try it out! Nested properties let you work with an address value that has number, street, and city` properties of its own. Object and object[] join the available list of data types."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/release_1_22",
          "webPageMainText": "Weaviate 1.22 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f relating to this release:\n\n1.22 is already available on Weaviate Cloud - so try it out!\nFor more details, keep scrolling \u2b07\ufe0f!\n\n1.22 welcomes new members to the Weaviate data type family, with object and object[] joining the available list.\nThis allows you to store nested objects directly in Weaviate as property values. In other words, you can store them without having to flatten the object or use cross-references to other Weaviate classes.\nThis is particularly useful for storing data that is not easily represented in a flat structure. For example, nested properties let you work with an address value that has number, street, and city` properties of its own.\nAn example class definition is shown below, where a Nested class has a parent property with an object datatype. Because the parent property is an object, it can have its own properties (nestedProperties), such as child in this example, which is a text datatype.\nAn example obje"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This vector database benchmark is designed to measure and illustrate Weaviate's Approximate Nearest Neighbor (ANN) performance for a range of real-life use cases. The benchmark is open source, so you can reproduce the results yourself. For good starting point values and performance tuning advice, see HNSW Configuration Tips."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/benchmarks/ann#results",
          "webPageMainText": "This vector database benchmark is designed to measure and illustrate Weaviate's Approximate Nearest Neighbor (ANN) performance for a range of real-life use cases.\nThis is not a comparative benchmark that runs Weaviate against competing vector database solutions. \nTo discuss trade-offs with other solutions, contact sales.\nTo make the most of this vector database benchmark, you can look at it from different perspectives:\nFor each benchmark test, we set these HNSW parameters:\nFor good starting point values and performance tuning advice, see HNSW Configuration Tips.\nFor each set of parameters, we've run 10,000 requests, and we measured the following metrics:\nBy request, we mean:\nAn unfiltered vector search across the entire dataset for the given test. All\nlatency and throughput results represent the end-to-end time that your\nusers would also experience. In particular, these means:\nThis benchmark is open source, so you can reproduce the results yourself.\nThis section contains datasets model"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate uses the Raft consensus algorithm for schema replication, implemented with Hashicorp's raft library. A schema change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. This architecture ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/cluster-architecture",
          "webPageMainText": "This page describes how the nodes or clusters in Weaviate's replication design behave.\nIn Weaviate, schema replication and data replication are separate. For the schema, Weaviate uses the Raft consensus algorithm with strong consistency. For data replication, Weaviate uses a leaderless design with eventual consistency.\nWeaviate uses the Raft consensus algorithm for schema replication, implemented with Hashicorp's raft library.\nRaft ensures that schema changes are consistent across the cluster. A schema change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. Once a majority of nodes have acknowledged the change, the leader commits the change to the log. The leader then notifies the followers, which apply the change to their logs.\nThis architecture ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures.\nAs a result, a Weaviate cluster will include a leader node that"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This example uses the .dynamic() method to create a dynamic batcher, which automatically determines and updates the batch size during the import process. There are also other batcher types, like .fixed_size() for specifying the number of objects per batch. The data is converted from a string to the correct data types for Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_collections/import_data",
          "webPageMainText": "This example imports the movie data into our collection.\nThe code:\nWe use the requests library to load the data from the source, in this case a JSON file. The data is then converted to a Pandas DataFrame for easier manipulation.\nThen, we create a collection object (with client.collections.get) so we can interact with the collection.\nThe batch object is a context manager that allows you to add objects to the batcher. This is useful when you have a large amount of data to import, as it abstracts away the complexity of managing the batch size and when to send the batch.\nThis example uses the .dynamic() method to create a dynamic batcher, which automatically determines and updates the batch size during the import process. There are also other batcher types, like .fixed_size() for specifying the number of objects per batch, and .rate_limit() for specifying the number of objects per minute.\nThe data is converted from a string to the correct data types for Weaviate. For example, the release_d"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use the after operator to retrieve all objects from a Weaviate instance. The after operator retrieves objects of a class based on the order of ids. You can pass the id of the last retrieved object as a cursor to start the next page. The offset parameter is a flexible way to page results as it allows use with parameters like sort."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/objects",
          "webPageMainText": "Use the after operator.\nList data objects in reverse order of creation. The data will be returned as an array of objects.\nA: This Aggregate query will output a total object count in a class.\nWithout any restrictions (across classes, default limit = 25):\nWith optional query params:\nYou can use limit and offset for paging results.\nThe offset parameter is a flexible way to page results as it allows use with parameters such as sort. It is limited by the value of QUERY_MAXIMUM_RESULTS which sets the maximum total number of objects that can be listed using this parameter.\nGet the first 10 objects:\nGet the second batch of 10 objects:\nGet the next batch of 10 objects:\nYou can use the after operator to retrieve all objects from a Weaviate instance . The after operator (\"Cursor API\") retrieves objects of a class based on the order of ids. You can pass the id of the last retrieved object as a cursor to start the next page.\nIt is not possible to use the after operator without specifying a class.\nF"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C. The strength of consistency can be determined by applying the following conditions:The data schema in Weaviates is strongly consistent."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/consistency#tunable-write-consistency",
          "webPageMainText": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match.\nSchema consistency is extremely important, as the schema defines the structure, or the blueprint, of the data. For this reason, Weaviate uses a strong consistency protocol and Raft consensus algorithm for schema replication.\nData objects, on the other hand, are eventually consistent, which means that all nodes will eventually contain the most updated data if the data is not updated for a while. Weaviate uses a leaderless design with eventual consistency for data replication.\nThis difference reflects the trade-off inherent in consistency and availability, as described in the CAP Theorem. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C.\nThe strength of consistency can be determined by applying the following conditions:\nThe data schema in Weaviate is strongly consistent. Once you use Weaviate, the data schema is rarely chang"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Retrieval Augmented Generation (RAG) applications search for relevant sources and create a personalized answer. RAG applications use provided data sources instead of the general knowledge Large Language Models (LLMs) are trained on. We wanted to make it easy for anyone to get into RAG, without all the hassle of setting things up."
              }
            ]
          },
          "url": "https://weaviate.io/blog/verba-open-source-rag-app",
          "webPageMainText": "\nHave you ever wished that you could ask a question and get a personalized, relevant answer without having to dig through pages of search results? That's exactly what Retrieval Augmented Generation (RAG) lets you do. RAG applications search for relevant sources and create a personalized answer, using provided data sources instead of the general knowledge Large Language Models (LLMs) are trained on.\nBut as cool as RAG is, creating a functional application can be overwhelming. There's a lot to learn about implementation, from choosing the right AI models for the use case to organizing your data to get the answers you need. While there are tools like LangChain and LlamaIndex that make designing a prototype easier, there hasn\u2019t been a simple, ready-to-use open source RAG tool that anyone can pick up and use, with no tech expertise required.\nThat's why we created Verba, the Golden RAGtriever. We wanted to make it easy for anyone to get into RAG, without all the hassle of setting things up o"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue. Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/filters#special-cases",
          "webPageMainText": "Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion. The operator used for filtering is also called a where filter.\nA filter may consist of one or more conditions, which are combined using the And or Or operators. Each condition consists of a property path, an operator, and a value.\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\nFor example, this filter will only allow objects from the class Article with a wordCount that is GreaterThan than 1000.\nThe where filter is an algebraic object, which takes the following arguments:\nIf the operator is And or Or, the operands are a list of where filters.\nWeaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue.\nThe behavior for the Equal operator on multi-word textual properties in where filters depends on the tokenization of the property.\nSee the Schema p"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Help developers build and scale AI-powered applications more easily with an open source, developer-friendly platform and ecosystem. Weaviate is available as a self-hosted database, a managed service, or a Kubernetes package in your VPC. Use proprietary data to securely interact with ML models. Back up as often as needed with zero downtime."
              }
            ]
          },
          "url": "https://weaviate.io/platform",
          "webPageMainText": "Purpose-built for a new breed of software applications.\nHelp developers build and scale AI-powered applications more easily with an open source, developer-friendly platform and ecosystem.\nBuild and iterate faster with integrations for 20+ ML models and frameworks. Quickly adopt and test new models as the ecosystem evolves.\nImprove semantic understanding and accuracy to deliver better insights. Leverage both vector search and BM25 keyword search without any extra overhead.\nRun where you want, how you want. Weaviate is available as a self-hosted database, a managed service, or a Kubernetes package in your VPC.\nLearn more about Trust and Security with Weaviate\nMerge different search algorithms and re-rank results accordingly.\nLearn more\nApply complex filters across large datasets in milliseconds.\u00a0\nLearn more\nUse proprietary data to securely interact with ML models.\nLearn more\nEasily generate new vector embeddings or bring your own.\nLearn more\nBack up as often as needed with zero downtime."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Creating an inclusive culture in remote work settings. Creating a remote-first Solution Engineering team. Why the business model of open-source software works. Creating great talks.Building an open- source brand. On being a remote first company. On creating a great remote team. On building a great team. on being a Remote First Company."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/page/3",
          "webPageMainText": "Creating an inclusive culture in remote work settings\nCreating a remote-first Solution Engineering team\nWhy the business model of open-source software works\nCreating great talks\nBuilding an open-source brand\nOn being a remote-first company\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#configure-semantic-indexing",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.23 released with AutoPQ, flat indexing + Binary Quantization, OSS LLM support through Anyscale, and more. An end-to-end generative feedback loop demo using Weaviate, Ollama, Mistral and Snowflake\u2019s Snowpark Container Services."
              }
            ]
          },
          "url": "https://weaviate.io/blog/page/3",
          "webPageMainText": "An end-to-end generative feedback loop demo using Weaviate, Ollama, Mistral and Snowflake\u2019s Snowpark Container Services!\nThe new (v4) release of the Weaviate Python Client is - faster (gRPC), provides better IDE support and more type-safety, and many other developer experience improvements. Check out the new release and let us know what you think!\nWhat you need to consider when using the Weaviate vector database with non-English languages, such as Hindi, Chinese, or Japanese.\nWe look at how to build Multimodal applications in TypeScript and dive into everything that needs to happen in between.\nA reflection on 2023 from team Weaviate!\nWeaviate 1.23 released with AutoPQ, flat indexing + Binary Quantization, OSS LLM support through Anyscale, and more!\nA picture is worth a thousand words, so why just stop at retrieving textual context!? Learn how to perform multimodal RAG!\nRecap the first Weaviate visit to Amazon re:Invent in Las Vegas\nLearn about high-availability setups with Weaviate, wh"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#create-a-collection",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/assets/files/weaviate-module-diagram-7f76a5296b5fd7f9d6efefa9f4721891.svg",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#bm25-with-where-filter",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#1-configure-an-initial-schema-without-pq",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The img2vec-neural module enables Weaviate to obtain vectors locally using a resnet50 model. It encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware. For new projects, we recommend using the multi2vec -clip module instead. This uses CLIP models, which uses a more modern model architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/img2vec-neural#nearimage-search",
          "webPageMainText": "For new projects, we recommend using the multi2vec-clip module instead of img2vec-neural. This uses CLIP models, which uses a more modern model architecture than resnet models used in img2vec-neural. CLIP models are also multi-modal, meaning they can handle both images and text and therefore applicable to a wider range of use cases.\nThe img2vec-neural module enables Weaviate to obtain vectors locally images using a resnet50 model.\nimg2vec-neural encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use img2vec-neural, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nThis configuration enables img2vec-neural, sets it as the default v"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has been developing a gRPC API and integrating it into our solutions. These are big changes, but we're confident the benefits are worth it. For one, the latest Weaviate solutions are much faster than our pre-gRPC solutions, which were using REST + GraphQL."
              }
            ]
          },
          "url": "https://weaviate.io/blog/grpc-performance-improvements",
          "webPageMainText": "\nSpeed is good.\nLet\u2019s face it - we\u2019ve all been frustrated by slow services or apps. So we appreciate how important speed is for an infrastructure product like Weaviate, which is used to power amazing services and apps. And that\u2019s why over the last few months, we\u2019ve been developing a gRPC API and integrating it into our solutions, starting with the Python client library.\nThese are big changes, but we're confident the benefits are worth it. For one, the latest Weaviate solutions are simply much faster than our pre-gRPC solutions, which were using REST + GraphQL. Take a look at these results (lighter bars: gRPC, darker bars: REST + GraphQL):\n\nThe chart really speaks for itself (although - we\u2019ll expand on that and more below). And since these changes are under the hood, you won\u2019t even really see which calls use gRPC, vs those that use REST or REST+GraphQL. It will simply be a function of using a client and server pair that relies on gRPC.\nBut many of you are probably curious to dig deeper."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_searches",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#hybrid-with-where-filter",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Hugging Face's Transformers library can be used with a wide range of models for natural language processing. Weaviate seamlessly integrates with the Transformers library, allowing users to leverage compatible models directly within the Weaviates database. These integrations empower developers to build sophisticated AI-driven applications with ease."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/transformers",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nHugging Face's Transformers library can be used with a wide range of models for natural language processing. Weaviate seamlessly integrates with the Transformers library, allowing users to leverage compatible models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\nWeaviate integrates with compatible Hugging Face Transformers models by spinning them up in containers. This allows users to host their own models and use them with Weaviate.\n\nTransformers-compatible embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with Hugging Face Transformers' embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate generates vector embeddings at the object level. XXX2vec modules are configured to produce a vector for each object. For instance text2vec-* modules can generate vectors from text objects. To produce the string to be vectorized from each object, Weaviate follows the schema configuration for the relevant class."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules",
          "webPageMainText": "This section includes reference guides for retriever & vectorizer modules. As their names suggest, XXX2vec modules are configured to produce a vector for each object.\nWeaviate generates vector embeddings at the object level (rather than for individual properties). For instance text2vec-* modules can generate vectors from text objects. To produce the string to be vectorized from each object, Weaviate follows the schema configuration for the relevant class.\nUnless specified otherwise in the schema, the default behavior is to:\nWhere Weaviate is configured with a vectorizer, it will only obtain a new vector if an object update changes the underlying text to be vectorized.\nWeaviate includes the following modules for re-ranking the data objects in a result set:\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use an ID to retrieve an object. If the id doesn't exist, Weaviate returns a 404 error. When multi-tenant datasets are enabled, the tenant name is required. If an object with a given id exists without retrieving it, make a HEAD request to the /v1/objects/ REST endpoint."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/read#get-an-object-by-id",
          "webPageMainText": "Instead of querying your database, you can use an ID to retrieve individual objects.\nCollections act like namespaces, so two different collections could have duplicate IDs between them.\n\n\nPrior to Weaviate v1.14 you can manipulate objects without specifying the collection name. This method is deprecated. It will be removed in Weaviate v2.0.0.\nStarting in v1.20, you can have multi-tenant datasets. When multi-tenancy is enabled, the tenant name is required.\nAlways include the collection name, and, when enabled, the tenant name.\nUse an ID to retrieve an object. If the id doesn't exist, Weaviate returns a 404 error.\nObject vectors can be retrieved by specifying its return.\nWhere named vectors are used, you can retrieve one or more of them by specifying their names.\nTo efficiently check if an object with a given id exists without retrieving it, make a HEAD request to the /v1/objects/ REST endpoint, or use the following client code:\nIf you have any questions or feedback, let us know in the u"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn about high-availability setups with Weaviate, which can allow upgrades and other maintenance with zero downtime. An introduction to creating generative feedback loops with LLMs in Weaviates. A discussion on data privacy and privacy-preserving machine learning for LLMs. An overview of LlamaIndex, the LLM framework."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/how-to/page/2",
          "webPageMainText": "We look at how to build Multimodal applications in TypeScript and dive into everything that needs to happen in between.\nA picture is worth a thousand words, so why just stop at retrieving textual context!? Learn how to perform multimodal RAG!\nLearn about high-availability setups with Weaviate, which can allow upgrades and other maintenance with zero downtime. \nLearn how to build an application using Weaviate and Confluent\nLearn about our latest open source demo and how we used Semantic and Generative Search to improve access to health\nLearn how to make testing less of a chore with Embedded Weaviate, and other tips for better automated testing.\nAn introductory overview of LlamaIndex, the LLM framework\nThe Weaviate server can be run locally directly from client code\nA discussion on data privacy and privacy-preserving machine learning for LLMs\nDemo on how to ingest PDFs into Weaviate using Unstructured.\nAn introduction to creating generative feedback loops with LLMs in Weaviate.\nA show-an"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Spell Check module is a Weaviate module for checking spelling in raw texts in GraphQL query inputs. Using the Python spellchecker library, the module analyzes text, gives a suggestion and can force an autocorrection. The module can be added as a service to the Docker Compose file."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/other-modules/spellcheck",
          "webPageMainText": "The Spell Check module is a Weaviate module for checking spelling in raw texts in GraphQL query inputs. Using the Python spellchecker library, the module analyzes text, gives a suggestion and can force an autocorrection.\nThe Spell Check module can be added as a service to the Docker Compose file. You must have a text vectorizer like text2vec-contextionary or text2vec-transformers running. An example Docker Compose file for using the text-spellcheck module with the text2vec-contextionary is here:\nVariable explanations:\nUse the spellchecker module to verify at query time that user-provided search queries are spelled correctly and even suggest alternative, correct spellings. Filters that accept query text include:\nThere are two ways to use this module: spell checking, and autocorrection.\nThe module provides a new GraphQL _additional property which can be used to check (but not alter) the provided queries.\nThe result is contained in a new GraphQL _additional property called spellCheck. It "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Inverted indices are used often in document retrieval systems and search engines. They allow fast full-text search and fast key-based search instead of brute-force. This fast data retrieval comes with the only cost of slight increase of processing time when a new data object is added, since the data object will indexed and stored in an inverted way."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/performance#costs-of-queries-and-operations",
          "webPageMainText": "Weaviate uses two types of data indexing. Next to the vector indexes that are created and powers the semantic search capability, there is also the inverted index.\nThe inverted index is essentially what powers all the GraphQL where filters, where vectors or semantics are needed to find results. With inverted indexes, contents or data object properties such as words and numbers are mapped to its location in the database. This is the opposite of the more traditional forward index, which maps from documents to its content.\nInverted indices are used often in document retrieval systems and search engines, because it allows fast full-text search and fast key-based search instead of brute-force. This fast data retrieval comes with the only cost of slight increase of processing time when a new data object is added, since the data object will indexed and stored in an inverted way, rather than only storing the index of the data object. In the database (Weaviate), there is a big lookup table which"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with the Hugging Face Transformers library allows you to access their models' capabilities directly from Weaviate.Configure a Weaviates vector index to use the Transformers integration. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings#weaviate-configuration",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with the Hugging Face Transformers library allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use the Transformers integration, and configure the Weaviate instance with a model image, and Weaviate will generate embeddings for various operations using the specified model in the Transformers inference container. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the Hugging Face Transformers vectorizer integration (text2vec-transformers) module.\nThis integration is not available for Weaviate Cloud (WCD) serverless instances, as it requires spinning up a container with the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In many use cases, retrieving objects from a Weaviate instance may be the most common operation. A basic, standalone, Get query might look as follows:What results do you expect? See if you can retrieve a list of passages most closely related to the input query."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_1/get",
          "webPageMainText": "Make sure to complete the Weaviate Academy Preparation mini-unit before starting this unit to make sure that you can run the client library and connect to the demo Weaviate instance without issues.\n\nBelow, you will see code snippets that do not include client instantiation details. Before running these snippets, make sure to instantiate the client as shown below.\nIn many use cases, retrieving objects from a Weaviate instance may be the most common operation.\nFor example, a user may want to retrieve a list of passages most closely related to the input query, or they may wish to retrieve a list of images which are most similar to another image. It is even possible to retrieve a set of images that best match a given passage.\nIn Weaviate, such operations to retrieve objects are performed using the Get function.\nA basic Get function looks as follows:\nNow let's try out some concrete Get queries.\nA basic, standalone, Get query might look as follows:\nWhat results do you expect? See if you can "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Filters can be used to precisely refine search results. You can filter by properties as well as metadata, and you can combine multiple filters with and or or conditions to further narrow down the results. This example finds entries in \"Movie\" based on their similarity to the query vector, only from those released after 2010."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_searches/filters",
          "webPageMainText": "Filters can be used to precisely refine search results. You can filter by properties as well as metadata, and you can combine multiple filters with and or or conditions to further narrow down the results.\nThis example finds entries in \"Movie\" based on their similarity to the query vector, only from those released after 2010. It prints out the title and release year of the top 5 matches.\nThis query is identical to that shown earlier for vector search, but with the addition of a filter. The filters parameter here takes an instance of the Filter class to set the filter conditions. The current query filters the results to only include those with a release year after 2010.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Dynamic indexing is an experimental feature. Use with caution."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/vector-index#asynchronous-indexing",
          "webPageMainText": "Vector indexes facilitate efficient, vector-first data storage and retrieval.\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nAvailable starting in v1.25. Dynamic indexing is an experimental feature. Use with caution.\nUse these parameters to configure the index type and their properties. They can be set in the collection configuration.\nGenerally, the hnsw index type is recommended for most use cases. The flat index type is recommended for use cases where the data the number of objects per index is low, such as in multi-tenancy cases."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The model can identify different types of hallucination and mark which words they come from. It also suggests edits to improve factuality. The model has a fine-grained hallucination detection accuracy 46.5% while it's binary acc.{hallucination, no hallucination} is 79%."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper19",
          "webPageMainText": "\nTrain a model that consists of a Retreiver and a Language Model:  \nCreate a synthetic hallucination dataset of 35k C = context, y=incorrect output, y=annotated fixed output -> (C, y, y) \nMagic Synthetic Dataset Creation: \nStart off with Llama2-Chat 7B to initialize Medit and then train on (C, y, y\u2217) \nMedit takes in (C, y) as input and learns to predict the edited outputs with tags to represent error type y\u2217 using standard language modeling objective.\nThe model, once trained, can identify different types of hallucination and mark which words they come from - it also suggests edits to improve factuality.\nThe model has a fine-grained hallucination detection accuracy 46.5% while it's binary acc.{hallucination, no hallucination} is 79%.\nFor comparison ChatGPT has a fine-grained hallucination detection acc. of 21.5% (59% binary acc) w/o RAG and 26%(68.5% binary hall detect) w/ RAG\n\ud83d\udcbbCode\n\ud83d\udd37Data\n\ud83c\udfd7\ufe0fModel\n\ud83d\udd17 arXiv Link\n\ud83d\udcdc Download paper\nCheck out the Quickstart tutorial, and begin building amazing"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets. The fusion method and the relative weights are configurable. The search rankings are part of the object metadata. Weaviate uses the score to order the search results. To see the object rankings, set the explain score field in your query."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/hybrid#autocut",
          "webPageMainText": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets.\nThe fusion method and the relative weights are configurable.\nCombine the results of a vector search and a keyword search. The search uses a single query string.\nThe output is like this:\nA hybrid search on a collection that has named vectors must specify a target vector. Weaviate uses the query vector to search the target vector space.\nThe output is like this:\nTo see the object rankings, set the explain score field in your query. The search rankings are part of the object metadata. Weaviate uses the score to order the search results.\nThe output is like this:\nHybrid search results can favor the keyword component or the vector component. To change the relative weights of the keyword and vector components, set the alpha value in your query.\nThe output is like this:\nRelative Score Fusion is the default fusion method starting in v1.24.\nThe output is like this:\nFor a discussion of"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default values in values.yaml may be sufficient. Make sure to set your desired Weaviate version. The yaml file is extensively documented to help you align the configuration with your setup. The configuration file is setup for:See the resource requ requeur for more information."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/kubernetes#authentication-and-authorization",
          "webPageMainText": "Make sure to set your desired Weaviate version.\nThis can be done through either explicitly setting it as part of the values.yaml or through overwriting the default as outlined in the deployment step below.\nIf you are looking for a complete end-to-end tutorial on the topic, see the Weaviate Academy course, Weaviate on Kubernetes. The course is an end-to-end tutorial on how to use MiniKube to deploy Weaviate on Kubernetes.\nTo obtain and install the Weaviate chart on your Kubernetes cluster, take the following steps:\nAdd the Weaviate helm repo that contains the Weaviate helm chart\nGet the default values.yaml configuration file from the Weaviate helm chart:\nThe default values in values.yaml may be sufficient. However, we recommend reviewing:\nIn the values.yaml\nfile you can tweak the configuration to align it with your\nsetup. The yaml file is extensively documented to help you align the\nconfiguration with your setup.\nOut of the box, the configuration file is setup for:\nSee the resource requ"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has more than 25K members in our Community, and we are still growing rapidly. Our Community is active across the web and in real life. We see engagement in channels like LinkedIn, Twitter, Github, Slack, Discourse, and StackOverflow, as well as at conferences, meetups, and hackathons."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-community-hero",
          "webPageMainText": "\nWe\u2019re excited to share the details of our newly launched Weaviate Hero Program! Let\u2019s use this opportunity to shed some light on Weaviate's core Community values, what our Weaviate Hero program is all about, why we launched it, what it takes to become a Weaviate Hero, and why we purposely spell Community with a capital C.\nWith the rise of LLMs and Generative AI last year, Weaviate\u2019s Community grew exponentially. This is amazing and an essential aspect for us as an open-source technology company.\nToday, we have more than 25K members in our Community, and we are still growing rapidly.\n\nOur Community is active across the web and in real life. We see engagement in channels like LinkedIn, Twitter, Github, Slack, Discourse, and StackOverflow, as well as at conferences, meetups, and hackathons. In all places community members:\nGrowing a community and engaging on different levels is one part of the picture. What strikes us most is something else - the underlying culture. We describe the Weavi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#filesystem",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A 'grouped task' generation wil perform RAG queries on a set of retrieved objects. This is useful when you want to transform the set of objects as a whole, with one prompt. You can also pass on a list of properties to be used, as the grouped_properties parameter. This can be useful to reduce the amount of data passed on."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_rag/grouped_task",
          "webPageMainText": "A 'grouped task' generation wil perform RAG queries on the set of retrieved objects. This is useful when you want to transform the set of objects as a whole, with one prompt.\nThis example finds entries in \"Movie\" based on their similarity to the input vector. Then, instructs the large language model to find commonalities between them.\nThe generated text, and each of the results are then printed out to the console.\nFor grouped_task queries, you simply pass on the prompt to the grouped_task parameter. This will instruct Weaviate to pass on the:\nto the large language model.\nYou can also pass on a list of properties to be used, as the grouped_properties parameter. This can be useful to reduce the amount of data passed on to the large language model and omit irrelevant properties.\nA RAG query with the grouped_task parameter will return a response with an additional generated attribute. This attribute will contain the generated output for the set of objects.\nIf you have any questions or feed"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this article, we look at how the use of GraphQL can be used to create a better user experience. We also look at the benefits of using this language to help people understand their data. We hope this article will help you understand how to use GraphQL in your own life."
              }
            ]
          },
          "url": "https://weaviate.io/blog/graphql-api-design",
          "webPageMainText": "\nChoosing a good API, its design and development, is a crucial but time-consuming process, especially if you want to develop one in an ongoing software development project.\nWeaviate uses the API query language GraphQL. GraphQL enables efficient development and provides high user experience (UX) for data interaction.\nIn this article we explain how the use of GraphQL leverages the UX of Weaviate, and how we approach the design of this API.\n\nWeaviate is an open-source Vector Database: for understandable knowledge representation, enabling semantic search and automatic classification. Weaviate does not only store data, but also its (automatically derived) context, consisting of linguistic information and relations to other concepts. The result is a network of knowledge, or a graph of data.\nOne core question is: How do we interact with this new type of data storage? Interacting with big data, enriched with contextual information, might sound even more overwhelming than interacting with a tra"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "GraphQL uses 'metadata' to retrieve data. The fields id, vector, certainty, distance, featureProjection and classification are available by default. Additional properties may be available for each query, depending on the query type as well as enabled Weaviate modules. For examples, see the related how to page."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-properties",
          "webPageMainText": "Various 'additional properties', also called 'metadata', can be retrieved in queries.\nThe fields id, vector, certainty, distance, featureProjection and classification are available by default.\nFurther additional properties may be available for each query, depending on the query type as well as enabled Weaviate modules.\nNote that only the id is available from cross-referenced objects.\nIn GraphQL queries, all additional properties to be retrieved can be set through the reserved _additional{} property.\nEach of the client libraries may handle this differently. See the examples below.\nAn example query getting the UUID and the distance.\nUse the id field to fetch the object UUID.\nUse the vector field to fetch the vector representation of the data object\nThe generate field can be used to perform a generative search.\nA generate query will cause corresponding additional result fields to be available, such as singleResult, groupedResult and error.\nFor examples, see the related how-to page.\nThe re"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page describes the code-level architecture of media2vec. The module architecture is dependent on the respective module. A module is essentially any struct that implements a specific Golang interface. The main interface is a really small one - a module essentially only has to provide a Name() string and Init(...) error method."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-modules/architecture",
          "webPageMainText": "This page describes the code-level architecture. The high-level architecture\ndepends on the respective module. For example, media2vec modules typically\nuse a microservice pattern to offload model inference into a separate\ncontainer, see this example for the text2vec-transformers high-level\narchitecture.\nA module is essentially any struct that implements a specific Golang interface.\nTo keep module development comfortable, we have decided that the main interface\nis a really small one. A module essentially only has to provide a Name()\nstring and Init(...) error method.\nIf your struct implements this small\ninterface\nit is already a valid Weaviate Module.\nAlthough a valid module, the above example provides little value to the user -\nit can't do anything. We cannot predict which capability a module will provide\nand don't want to force every module developer to implement hundreds of methods -\nonly to have 95 of them return \"not implemented\".\nThus, we have decided to make each capability a sma"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has a basic RESTful API which offers CRUD support on all data objects. The clients automatically determine if they should call the RESTful or GraphQL API. You can also choose to call the APIs themselves. The Open API specs for the current Weaviate version number can be found here."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy",
          "webPageMainText": "Weaviate has a basic RESTful API which offers CRUD support on all data objects. The clients automatically determine if they should call the RESTful or GraphQL API. You can also choose to call the APIs themselves.\nThe Open API specs for the current Weaviate version number can be found here.\nEach endpoint has its individual page:\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.15.1 has been released. This release includes two big community contributions from Aakash Thatte and Dasith Edirisinghe. We hope to see many more big and small contributions in the coming months and years. Read below to learn more about each of these points in more detail."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-15-release#cloud-native-backups",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.15, which is packed with great features, significant performance improvements, new distance metrics and modules, and many smaller improvements and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\nWe have published a patch release v1.15.1.\nTo learn more check the Weaviate 1.15.1 patch release blog.\n\n\ud83d\ude00We are extremely happy about this release, as it includes two big community contributions from Aakash Thatte and Dasith Edirisinghe. Over the last few weeks, they collaborated with our engineers to make their contributions.\n\ud83d\ude80Aakash implemented the two new distance metrics, while Dasith contributed by implementing the two new Weaviate modules.\n  \ud83d\udc55We will send some Weaviate t-shirts to Aakash and Dasith soon.\n\ud83e\udd17We hope to see many more big and small contributions in the coming months and years. #CommunityRocks\n\nCreating and restoring "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has open-sourced the complete English language Wikipedia corpus backup in Weaviate. The dataset used is the \"truthy\" version of October 9th, 2021. After processing it contains 11.348.257 articles, 27.377.159 paragraphs, and 125.447.595 graph cross-references."
              }
            ]
          },
          "url": "https://weaviate.io/blog/semantic-search-with-wikipedia-and-weaviate",
          "webPageMainText": "\nTo conduct semantic search queries on a large scale, one needs a vector database to search through the large number of vector representations that represent the data. To show you how this can be done, we have open-sourced the complete English language Wikipedia corpus backup in Weaviate. In this article, I will outline how we've created the dataset, show you how you can run the dataset yourself, and present search strategies on how to implement similar vector and semantic search solutions in your own projects and how to bring them to production.\nThe Wikipedia dataset used is the \"truthy\" version of October 9th, 2021. After processing it contains 11.348.257 articles, 27.377.159 paragraphs, and 125.447.595 graph cross-references. Although a bigger machine (see below) is needed for importing the data, the serving is done on a 12 CPU, 100 GB RAM, 250Gb SSD Google Cloud VM with 1 x NVIDIA Tesla P4. The ML-models used are multi-qa-MiniLM-L6-cos-v1 and bert-large-uncased-whole-word-masking-f"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with Hugging Face Hub's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps. These integrations empower developers to build sophisticated AI-driven applications with ease."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/huggingface",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nHugging Face offers a wide range of models for natural language processing. Weaviate seamlessly integrates with Hugging Face's Inference API, allowing users to leverage Hugging Face Hub's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nHugging Face Hub's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with Hugging Face Hub's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nHugging Face embedding integration page\nThese integrations enable developers to leverage Hugging Face's powerful models directly within Weavi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate\u2019s usage numbers are through the roof, and so are your feedback and requests for what you\u2019re still missing from Weaviate. In early 2023 we even saw the addition of the generative-openai module (with other generative modules to come). We want to give you even more flexibi."
              }
            ]
          },
          "url": "https://weaviate.io/blog/what-to-expect-from-weaviate-in-2023",
          "webPageMainText": "\nWithout a doubt, 2022 has been the most exciting year for Weaviate so far. The company and the product have grown tremendously, and we are incredibly excited about 2023. Weaviate\u2019s usage numbers are through the roof, and so are your feedback and requests for what you\u2019re still missing from Weaviate.\nIn this blog post, I will introduce you to the six pillars outlining how Weaviate will get even better in 2023. Weaviate development is highly dynamic \u2013 we don\u2019t waterfall-plan for the entire year \u2013 but nevertheless, we want to give you the best possible overview of what to expect in the coming year.\n\nWeaviate\u2019s strong and growing module ecosystem gives you plenty of flexibility. Whether you use Weaviate as a pure vector search engine or with the addition of vectorizer, reader, and generator modules, you can always configure it to your liking. In early 2023 we even saw the addition of the generative-openai module (with other generative modules to come).\nWe want to give you even more flexibi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Gorilla is a new direction for LLMs, API Co-pilots achieved by fine-tuning LLMs to use a particular set of APIs. Weaviate has many APIs that help developers get running with production grade Retrieval-Augmented Generation. Before LLMs or human developers can access the power of Weaviates, they must learn the syntax."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-gorilla-part-1",
          "webPageMainText": "\nFollowing the new wave of excitement created by ChatGPT, AI hackers and researchers around the world quickly realized you could take LLMs even further by connecting them with tools. Tools are computations or services external to the LLM, such as a weather API, calculators, databases, and many others. These tools are interfaced to the LLM through API requests and responses. Gorilla is a new direction for LLMs, API Co-pilots achieved by fine-tuning LLMs to use a particular set of APIs. Weaviate has many APIs that help developers get running with production grade Retrieval-Augmented Generation! However, before LLMs, or human developers can access the power of Weaviate, they must learn the syntax. In this article, we present how we fine-tuned the LlaMA 7B open-source LLM to translate natural language commands into the Weaviate GraphQL Search APIs!\nAs a quick primer to GraphQL, \u201cGraphQL is a query language for your API, and a server-side runtime for executing queries using a type system yo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This API client is compatible with Java 8 and beyond. The current Java client version is v4.7.0. The Java client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows. The suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviates instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/java#oidc-authentication",
          "webPageMainText": "The current Java client version is v4.7.0.\nThe package and import paths have been updated from technology.semi.weaviate to io.weaviate.\nSee the Migration Guide for more info.\nTo get the latest stable version of the Java client library, add this dependency to your project:\nThis API client is compatible with Java 8 and beyond.\nYou can use the client in your project as follows:\nFor more comprehensive information on configuring authentication with Weaviate, refer to the authentication page.\nThe Java client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows.\nThe suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviate instance.\nEach Weaviate instance in Weaviate Cloud (WCD) is pre-configured to act as a token issuer for OIDC authentication.\nSee our WCD authentication documentation for instructions on how to authenticate against WCD with your preferred Weaviate client.\nIf you"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The v3 Python library is available on PyPI.org. The client is developed and tested for Python 3.7 and higher. The current Python client version is v4.6.5. The v3 client is not to be used with with the gRPC API that was introduced in Weaviate 1.22."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python/python_v3",
          "webPageMainText": "The current Python client version is v4.6.5\nThis document relates to the v3 client. We recommend you upgrade to the v4 client if possible. The v3 client is still available for backwards compatibility, and receive with bug fixes and security updates, but it will be updated with new Weaviate features, and may be subset sometime in the second half of 2024.\nWe also have a migration guide for moving from v3 client to the v4.\nThe v3 client is not to be used with with the gRPC API that was introduced in Weaviate 1.22. You can still use Weaviate 1.22 and newer with the v3 client, however it will not take advantage of improvements made with the gRPC API. For the gRPC API, use the v4 client.\nThe v3 Python library is available on PyPI.org. The package can be installed using pip. The client is developed and tested for Python 3.7 and higher.\nNow you can use the client in your Python scripts as follows:\nOr, with additional arguments such as those below:\nFor more comprehensive information on configur"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#invertedindexconfig",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The cross-reference type is the graph element of Weaviate. It allows you to link to any number of instances of a given class. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/datatypes#datatype-cross-reference",
          "webPageMainText": "When creating a property, Weaviate needs to know what type of data you will give it. Weaviate accepts the following types:\nRefer to this section on how to configure the tokenization behavior of a text property.\nPrior to v1.19, Weaviate supported an additional datatype string, which was differentiated by tokenization behavior to text. As of v1.19, this type is deprecated and will be removed in a future release.\nUse text instead of string. text supports the tokenization options that are available through string.\nThe cross-reference type is the graph element of Weaviate: you can create a link from one object to another. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema. For example:\nThe cross-reference type objects are arrays by default. This allows you to link to any number of instances of a given class (including zero).\nIn the above example, our objects "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#fusion-algorithms",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In 1.25 we\u2019re introducing the dynamic vector index. This will initially create a flat index to be used and once the number of objects exceeds a certain threshold (by default 10,000 objects) it will dynamically switch you over to an HNSW index. Here is how you can configure Weaviate to use a dynamic index."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/release_1_25",
          "webPageMainText": "Weaviate 1.25 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nConfiguring Weaviate and not sure if you have enough objects to justify building a full HNSW index or to stick to a flat index? We\u2019ve got good news for you: In 1.25 we\u2019re introducing the dynamic vector index!\nPreviously you\u2019d have to decide at the outset if you wanted a flat or HNSW index. The flat index was ideal for use cases with a small object count where brute force nearest neighbors search was viable and would provide lower memory overhead and good latency. As the object count increased the flat index would become prohibitively slow and this is what the HNSW index would solve.\nWith 1.25 you can now configure Weaviate to use a dynamic index. This will initially create a flat index to be used and once the number of objects exceeds a certain threshold (by default 10,000 objects) it will dynamically switch you over to an HNSW index.\nHere is how you can configure Weaviate to use a dynamic index:\nThis is a one-way dynamic sw"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "ChatGPT can now interact with the world of other apps we use in our everyday lives. The plugins announcement is a game-changer, arguably even more important than the 4.0 upgrade to the underlying GPT model itself. Some are explaining plugins as the \u201ceyes and ears\u201d of LLMs to help products like ChatGPT interact more naturally with users."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-retrieval-plugin",
          "webPageMainText": "\nLast week OpenAI announced plugins for ChatGPT and all of a sudden everyone\u2019s favorite chatbot can now interact with the world of other apps we use in our everyday lives! The plugins announcement is a game-changer, arguably even more important than the 4.0 upgrade to the underlying GPT model itself.\nSo what are ChatGPT plugins? Some are explaining plugins as the \u201ceyes and ears\u201d of LLMs to help products like ChatGPT interact more naturally with users by knowing of and integrating with other apps such as Zapier, Uber Eats, Duolingo, and many more. I would argue that plugins are much more than just the \u201ceyes and ears\u201d of ChatGPT.  Hear me out.\nUntil now ChatGPT was a tool that we could converse with and it would \u201cimagine\u201d creative stories, help us learn, summarize for us, write for us, and explain to us. The interface ChatGPT could use to interact with us was limited to a tab on our browser. But now, imbued with the power of plugins, ChatGPT can actually do much more than just \u201ctalk\u201d, it"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Sphere is an open-source dataset recently released by Meta. It is a collection of 134 million documents (broken up into 906 million 100-word snippets) It is one of the largest knowledge bases that can help solve knowledge-intensive natural language tasks. The potential for this large of a dataset is awe-inspiring."
              }
            ]
          },
          "url": "https://weaviate.io/blog/sphere-dataset-in-weaviate",
          "webPageMainText": "\nSphere is an open-source dataset recently released by Meta. It is a collection of 134 million documents (broken up into 906 million 100-word snippets). It is one of the largest knowledge bases that can help solve knowledge-intensive natural language tasks such as question-answering, fact-checking, and much more.\nSimply stated, Sphere aims to act as a \"universal, uncurated and unstructured source of knowledge.\" This means that the next time you have a question like: \"Was McDonald's, the food chain, founded by the same Ol' McDonald who had a farm?\" Sphere will have the relevant knowledge to answer your question and point you toward a relevant article. The potential for this large of a dataset is awe-inspiring and the applications one can dream up are limitless - from combating fake news on social media platforms to helping locate your next dream vacation spot.\nAdditionally, Sphere is ideal for hybrid vector search at scale since it is one of the few large scale datasets where vectors ar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Core uses a typical Test Pyramid approach. The tests are grouped into the following three levels:Unit tests test the smallest possible unit, mostly a struct in golang. Unit tests are designed to validate the business logic and not the internals.Integration tests test anything that crosses a boundary."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/tests#test-pyramid",
          "webPageMainText": "Weaviate Core follows a typical Test Pyramid approach. As Weaviate itself contains no graphical user interface (GUI), the highest level tests test the user journeys at an API level.\nThe tests are grouped into the following three levels:\nUnit tests test the smallest possible unit, mostly one \"class\" (usually a struct in golang) with its methods. Unit tests are designed to validate the business logic and not the internals.\nUnit tests are stateless and do not depend on any external programs or runtime other than the Golang-built tools. (Note: We do make use of the stretchr/testify packages. However, they are installed with any other code-level dependency and don't require running dedicated software).\nThis makes tests fast to execute, easy to adapt and easy to run with third-party tools like code watchers.\nIntegration tests test anything that crosses a boundary. A boundary could be the dependence on an external party (e.g. a third-party database) or an independent custom tool, such as the "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The cross-reference type is the graph element of Weaviate. It allows you to link to any number of instances of a given class. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/datatypes#datatype-geocoordinates",
          "webPageMainText": "When creating a property, Weaviate needs to know what type of data you will give it. Weaviate accepts the following types:\nRefer to this section on how to configure the tokenization behavior of a text property.\nPrior to v1.19, Weaviate supported an additional datatype string, which was differentiated by tokenization behavior to text. As of v1.19, this type is deprecated and will be removed in a future release.\nUse text instead of string. text supports the tokenization options that are available through string.\nThe cross-reference type is the graph element of Weaviate: you can create a link from one object to another. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema. For example:\nThe cross-reference type objects are arrays by default. This allows you to link to any number of instances of a given class (including zero).\nIn the above example, our objects "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#create-backup",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A modality is a mode in which something exists or is experienced or expressed. In this article, we'll look at how to build Multimodal applications in TypeScript. We leveraged metadata and attached text to these more complex modalities and essentially created a new form of search."
              }
            ]
          },
          "url": "https://weaviate.io/blog/multimodal-search-in-typescript",
          "webPageMainText": "\nFor a lot of people, Multimodal AI and its derivatives are strong contenders for technology of the year. The promises of Multimodal applications of artificial intelligence are exciting and speak to behavioural changes in media consumption and general interaction with the internet. I'm here to show you how you can get a piece of the pie. In this article, we\u2019ll look at how to build Multimodal applications in TypeScript and dive into everything that needs to happen in between.\nA modality is a particular mode in which something exists or is experienced or expressed.\nHistorically, search has been over text, emphasizing the relevance of keyword search. This type of search was focused on matching text search terms to large datasets of text and returning the most relevant. This was the single modality; text search through data and get back text.\nEven with the onset of multimedia; images, videos and audio. We leveraged metadata and attached text to these more complex modalities and essentially"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In January, OpenAI released two new embedding models. These models are trained with the Matryoshka Representation Learning technique. It lets developers trade off performance and cost in embeddings. This article shows how to use the newly released models with the Weaviate vector database."
              }
            ]
          },
          "url": "https://weaviate.io/blog/openais-matryoshka-embeddings-in-weaviate",
          "webPageMainText": "\nIn January, OpenAI released two new embedding models: text-embedding-3-small and text-embedding-3-large. These models are trained with the Matryoshka Representation Learning technique, which lets developers trade off performance and cost in embeddings.\nSince then, we\u2019ve discussed Matryoshka embeddings in various formats, such as in our 89th Weaviate podcast episode, Matryoshka Embeddings with Aditya Kusupati, Zach Nussbaum, and Zain Hasan, and in our Weaviate paper review, Matryoshka Representation Learning.\nThis article briefly covers the fundamentals of Matryoshka Representation Learning and shows how to use the newly released OpenAI\u2019s Matryoshka embedding models with the Weaviate vector database.\nMatryoshka Representation Learning\u00a0is a technique used in training embedding models. It allows you to trade off a small amount of accuracy in exchange for much smaller embedding sizes. Thus, you can store more information at a lower cost and search for it faster.\nThe embeddings are shorten"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate\u2019s Enterprise Cloud solution provides the power of Weaviate on dedicated resources, ensuring consistent, high-speed results without the complexities of self-management. Your data and operations are isolated within a dedicated tenant, boosting security, consistency, and performance. All the features of the AI-native vector database, with enhanced data isolation."
              }
            ]
          },
          "url": "https://weaviate.io/services/enterprise-cloud",
          "webPageMainText": "Tailored for businesses seeking high performance, Weaviate\u2019s Enterprise Cloud solution provides the power of Weaviate on dedicated resources, ensuring consistent, high-speed results without the complexities of self-management.\nYour data and operations are isolated within a dedicated tenant\u2014 boosting security, consistency, and performance.\nEnsure your resources are available when you need them and optimized to support your applications.\nEnhanced security, continuous monitoring, and guaranteed adherence to industry standards and best practices.\nDirector of Engineering in Legal Tech \nWe help you run large-scale production workloads, without the complexities of self-management.\nAll the features of the AI-native vector database, with enhanced:\nReduce the guesswork with pre-scoped dimensions, storage, query, and latency parameters.\nData isolation keeps your data (and your customers\u2019 data) safe, and helps with security and compliance.\nHelp to support and guide your team, and optimize your pro"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with OpenAI's APIs allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. The integration is enabled by default on Weaviated Cloud (WCD) serverless instances. You must provide a valid OpenAI API key to Weaviates for this integration."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/openai/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with OpenAI's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use an OpenAI generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model and your OpenAI API key.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the OpenAI generative model to generate outputs.\n\nYour Weaviate instance must be configured with the OpenAI generative AI integration (generative-openai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid OpenAI API key to Weaviate for this integration. Go to OpenAI to sign up and obtain an API key.\nProvide the API key to Weaviate using one of the following methods:\nConfigure a Weaviate collect"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Ollama's models allows you to access their models' capabilities directly from Weaviate. This integration requires a locally running Ollamas instance with your selected model available. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/ollama/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Ollama's models allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use an Ollama generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model via your local Ollama instance.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the Ollama generative model to generate outputs.\n\nThis integration requires a locally running Ollama instance with your selected model available. Refer to the Ollama documentation for installation and model download instructions.\nYour Weaviate instance must be configured with the Ollama generative AI integration (generative-ollama) module.\nThis integration is not available for Weaviate Cloud (WCD) serverless instances, as it requires a locally running"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate provides a Helm chart that you can use to deploy Weaviate on Kubernetes. This section will show you how to use the Helm chart to deploy the app on a Kuberne cluster. We will use this chart to create a configuration file for the Weaviates app."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/deployment/k8s/setup_weaviate",
          "webPageMainText": "Now that you have a Kubernetes cluster, you can deploy Weaviate on it. This section will show you how to deploy Weaviate on Kubernetes using Helm.\nAs mentioned earlier, Helm is a package manager for Kubernetes. It uses a packaging format called charts.\nA Helm chart is a collection of files that describe a set of Kubernetes resources. It is the equivalent of a package in other package managers, such as pip or npm.\nWeaviate provides a Helm chart that you can use to deploy Weaviate on Kubernetes. So, we will use this Helm chart to deploy Weaviate on your Kubernetes cluster.\nFirst, add the Weaviate Helm repository to your Helm installation. This will make the Weaviate Helm chart available to you.\nIf you have previously added the weaviate Helm repository, run this to update it to the latest version.\nYou should periodically update the Helm repositories to ensure that you have the latest information about available charts.\nNext, generate a configuration file (values.yaml) for the Weaviate Hel"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Cohere's APIs allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. The integration is enabled by default on Weaviated Cloud (WCD) serverless instances. You must provide a valid Cohere API key to Weaviates for this integration."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/cohere/reranker",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Cohere's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use a Cohere reranker model, and Weaviate will use the specified model and your Cohere API key to rerank search results.\nThis two-step process involves Weaviate first performing a search and then reranking the results using the specified model.\n\nYour Weaviate instance must be configured with the Cohere reranker integration (reranker-cohere) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Cohere API key to Weaviate for this integration. Go to Cohere to sign up and obtain an API key.\nProvide the API key to Weaviate using one of the following methods:\nConfigure a Weaviate collection to use a Cohere reranker model as follows:\nYou can specify one of"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page shows how to create a Weaviate instance using Docker. If you have created a cloud instance of Weaviates, you can skip this page and continue with Communicate with Weaviated. You can provide the API keys for these services to WeAViate at instantiation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/setup_weaviate/create_instance/create_docker",
          "webPageMainText": "If you have created a cloud instance of Weaviate, you can skip this page and continue with Communicate with Weaviate.\nHere, you will create a Weaviate instance using Docker.\nInstall Docker on your machine. We recommend following the official Docker installation guide.\nCreate a new directory and navigate to it in your terminal. Then, create a new file called docker-compose.yml and add the following content:\nRun the following command to start Weaviate:\nOnce the instance is created, you can access it at http://localhost:8080.\nTo connect to the Weaviate instance, use the connect_to_local function.\nSome Weaviate modules can use inference APIs for vectorizing data or large language model integration. You can provide the API keys for these services to Weaviate at instantiation.\nThis course uses Cohere, so you can provide the Cohere API key to Weaviate through headers={\"X-Cohere-Api-Key\": <YOUR_KEY>} as shown below:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You can retrieve information about individual nodes in a Weaviate cluster. The query can be for the entire cluster, or for a particular collection. The nodes endpoint returns an array of nodes. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/nodes",
          "webPageMainText": "You can retrieve information about individual nodes in a Weaviate cluster. The query can be for the entire cluster, or for a particular collection.\nThe nodes endpoint returns an array of nodes. The nodes have the following fields:\nThe following command will retrieve summary information about all nodes in the cluster:\nExample output:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud. Use WCD to simplify development and confidently deploy enterprise-ready AI applications. WCD is built on Weaviate core. They share the same technology, and offer the same great features."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs#configuration",
          "webPageMainText": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud.\nWCD manages the infrastructure so you can focus on innovation. Use WCD to simplify development and confidently deploy enterprise-ready AI applications.\nWeaviate is more than just a vector database. Weaviate is a scalable, flexible platform. The core, open source project offers vector search, keyword, and hybrid search. It has a plugable architecture to connect with ML models and tools to help you build scalable AI applications.\nWCD is built on Weaviate core. They share the same technology, and offer the same great features. In addition, WCD handles the work of hosting your Weaviate instance. This gets you up and running fast and lets you focus on your application. WCD takes care of the operational details so you don't have to.\nThese pages document the WCD user interface (UI) and WCD specific operational features. For information about the Weaviate database, client APIs, third-party modules, and other features, see th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " vector databases and vector libraries allow you to efficiently search through your vectors. They both use the Approximate Nearest Neighbor (ANN) algorithm to search through vectors in a tiny fraction of the time. You can learn more about this topic from \"Why Vectors Search is so Fast\""
              }
            ]
          },
          "url": "https://weaviate.io/blog/vector-library-vs-vector-database",
          "webPageMainText": "\nIn the world of Vector Search, we use vector embeddings \u2013 generated by Machine Learning models \u2013 to represent data objects (text, images, audio, etc.). The key idea here is that embeddings that are semantically similar to each other have a smaller distance between them.\nWe can use vector distance functions like euclidean distance or cosine distance to determine if these objects are similar to other objects in the collection. However, to do this we need to compare the distances between the query vector and every vector in the collection. This type of calculation can be difficult to scale to millions or billions of vectors.\nThis is why we have Vector Databases and Vector Libraries. They both use the Approximate Nearest Neighbor (ANN) algorithm to search through vectors in a tiny fraction of the time. You can learn more about this topic from \"Why Vectors Search is so Fast.\"\nSo, if both vector databases and vector libraries allow you to efficiently search through your vectors. What are th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with OpenAI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps. The model provider integration pages are new and still undergoing improvements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/openai",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nOpenAI offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with OpenAI's APIs, allowing users to leverage OpenAI's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nOpenAI's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with OpenAI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nOpenAI embedding integration page\n\nOpenAI's generative AI models can generate human-like text based on given prompts and contexts.\nWeaviate's generative AI integration enables u"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Jina AI's APIs allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/jinaai/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Jina AI's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an Jina AI embedding model, and Weaviate will generate embeddings for various operations using the specified model and your Jina AI API key. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the Jina AI vectorizer integration (text2vec-jinaai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Jina AI API key to Weaviate for this integration. Go to Jina AI to sign up and obtain an API key.\nProvide the API key to Weaviate using on"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate hosts and manages our database within your existing cloud environment, leveraging your cloud's native services. Our solution integrates seamlessly with AWS, GCP, and Azure, ensuring optimized performance and security. Our BYOC architecture capitalizes on managed Kubernetes, ensuring scalability and resilience."
              }
            ]
          },
          "url": "https://weaviate.io/services/byoc",
          "webPageMainText": "Weaviate hosts and manages our database within your existing cloud environment, leveraging your cloud's native services. Our solution integrates seamlessly with AWS, GCP, and Azure, ensuring optimized performance and security.\nOur BYOC architecture capitalizes on managed Kubernetes, ensuring scalability and resilience.\nWeaviate manages application-level security, provisioning, configuration, upgrades and patches with 24/7 monitoring and support. The customer ensures secure configuration of the broader cloud environment and access controls.\nWe release regular updates and critical patches using progressive roll out strategies to reduce disruption and ensure stability.\nLior Harel, CTO & Co-Founder, Staircase.ai\nTake advantage of all the best vector search and RAG techniques while ensuring your data stays safe within your own cloud environment.\nAll the features of the AI-native vector database, with enhanced:\nImages are scanned against known vulnerability databases before deployment.\nWe co"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "GraphQL uses 'metadata' to retrieve data. The fields id, vector, certainty, distance, featureProjection and classification are available by default. Additional properties may be available for each query, depending on the query type as well as enabled Weaviate modules. For examples, see the related how to page."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-properties#rerank",
          "webPageMainText": "Various 'additional properties', also called 'metadata', can be retrieved in queries.\nThe fields id, vector, certainty, distance, featureProjection and classification are available by default.\nFurther additional properties may be available for each query, depending on the query type as well as enabled Weaviate modules.\nNote that only the id is available from cross-referenced objects.\nIn GraphQL queries, all additional properties to be retrieved can be set through the reserved _additional{} property.\nEach of the client libraries may handle this differently. See the examples below.\nAn example query getting the UUID and the distance.\nUse the id field to fetch the object UUID.\nUse the vector field to fetch the vector representation of the data object\nThe generate field can be used to perform a generative search.\nA generate query will cause corresponding additional result fields to be available, such as singleResult, groupedResult and error.\nFor examples, see the related how-to page.\nThe re"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's classification features allows you to classify data objects based on their vector. Text2vec-contextionary is enabled, contextual classification can also be used. Classification can triggered to run in the background with a POST request, and the GET method can be used to view its status."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/classification",
          "webPageMainText": "Weaviate's classification features allows you to classify data objects based on their vector.\nNote that knn classification requires the target property to be included in the schema before importing the data. If you want to add a property to the schema after importing data, you will need to re-import the data).\nIf text2vec-contextionary is enabled, contextual classification can also be used.\nClassification can triggered to run in the background with a POST request, and the GET method can be used to view its status.\nThe Python client v4 API does not yet support classification tasks. Please use the client's v3 API for this.\nThe endpoint will return information about the started classification. The response will include the classification id.\nClassification jobs can take some time to complete. With the Weaviate clients, you can:\nA GET request can return the status, results and metadata of a previously created classification:\nThe classification id should be passed to the request. This id is"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's v1.17 release introduces replication. Replication enables you to set up your Weaviate environment in a cluster with multiple server nodes. Adding extra database nodes can serve more users simultaneously. Database replication enables zero downtime upgrades, because of no downtime upgrades."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-17-release",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.17, which brings a set of great features, performance improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\n\nWeaviate's v1.17 release introduces replication. Replication enables you to set up your Weaviate environment in a cluster with multiple server nodes. Weaviate will automatically replicate data across nodes in the background.\nThis enables a variety of use cases. For example, if a Weaviate node goes down, another node can shoulder the load without losing availability or data. Data in Weaviate will thus have a higher availability for its users.\nSecondly, Replication can improve the throughput of read requests, as you can use all additional nodes to spread the load of queries. Adding extra database nodes can serve more users simultaneously.\nThirdly, database replication enables zero downtime upgrades, because o"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) instance or a local Docker instance is fine for this course. If you're not sure which to choose, we recommend starting with a WCD instance. For this unit, you can choose to create a Weaviate cloud (W CD) instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/setup_weaviate/create_instance",
          "webPageMainText": "For this unit, you can choose to create a Weaviate Cloud (WCD) instance or a local Docker instance.\nEither option is fine for this course. If you're not sure which to choose, we recommend starting with a WCD instance.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate brings together cutting-edge AI technologies and service providers. Technology providers integrate with Weaviate's powerful AI capabilities to provide enhanced value to their customers. Managed service providers and consultancies leverage Weaviates to build, manage, and scale AI applications."
              }
            ]
          },
          "url": "https://weaviate.io/partners",
          "webPageMainText": "Weaviate Partners\nGrow with Weaviate! We bring together cutting-edge AI technologies and service providers to deliver transformational solutions for organizations worldwide.\nAn industry-leading group of technology providers integrate with Weaviate's powerful AI capabilities to provide enhanced value to their customers.\nManaged service providers and consultancies leverage Weaviate to build, manage, and scale AI applications for their customers.\nInterested in learning more about the Weaviate Partner Program?Fill out the form below to connect with us.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#neartext",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " authorization plugin allows Weaviate to provide differentiated access to users based on their authentication status. Along with allowing or disallowing anonymous access, it can differentiate between a user who is in the admin list, or on the read-only list. It is not currently possible to assign only some rights to a specific user."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/authorization",
          "webPageMainText": "The authorization plugin allows Weaviate to provide differentiated access to users based on their authentication status. Along with allowing or disallowing anonymous access, Weaviate can differentiate between a user who is in the admin list, or on the read-only list.\nThe admin list relies on the configured Authentication Schema to correctly identify\nthe user. On each request, a check against a pre-configured admin list is done.\nIf the user is contained in this list, they get all permissions. If they aren't,\nthey get none. It is not currently possible to assign only some rights to a specific user.\nOther than a list of admins, it is also possible to specify a list of read-only users.\nThose users have permissions on all get and list operations, but no other\npermissions.\nIf a subject is present on both the admin and read-only list, Weaviate will\nthrow an error on startup due to the invalid configuration.\nSee this page for how to set up values.yaml for authentication & authorization.\nConfig"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate offers multiple vector search \"operators\" through which you can carry out vector searches. The nearVector operator can be used to look for objects which are the most similar to an explicitly provided vector. The vector value is passed using the vector argument as shown below."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_1/vector_parameters",
          "webPageMainText": "Weaviate offers multiple vector search \"operators\", through which you can carry out vector searches. Typically, our users use one of nearVector, nearObject or near<Media> methods (e.g. nearText). We will review those methods one by one in this section.\nThe nearVector operator can be used to look for objects which are the most similar to an explicitly provided vector.\nThe vector value is passed using the vector argument as shown below.\nThe vector shown below is truncated. If you would like to run the cell yourself, you can see the full vector below.\n[0.023932384327054024, -0.014095712453126907, 0.013304559513926506, -0.01155742909759283, -0.01147831417620182, 0.015321999788284302, -0.025013625621795654, -0.04198386147618294, 0.0006061387248337269, -0.008940030820667744, 0.013475975953042507, 0.0021558923181146383, 0.008148877881467342, -0.0022696207743138075, 0.014623147435486317, 0.0010969009017571807, 0.032199934124946594, -0.016746075823903084, 0.007700557820498943, 0.014293501153588"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The bottleneck in knowledge work has been our rate of information discovery and consumption. Weaviate, as a vector database, can help with information cataloging and discovery. But did you know that weaviate can also summarize information during retrieval? Our summarizer module (sum-transformers) can be added to a Weaviates instance to do exactly that."
              }
            ]
          },
          "url": "https://weaviate.io/blog/solution-to-tl-drs#bonus-tldr-version-edited",
          "webPageMainText": "\n(Note: You can skip to the TL;DR version below \ud83d\ude09)\nHow often do you find yourself facing a wall of text in an email, a report, or a paper, and letting out a sigh? Nobody enjoys hacking their way through boring, dense prose. Especially if it's just to see if the information is even relevant.\nIn this day and age, this is a more common problem than ever. For a while now, the bottleneck in knowledge work has been our rate of information discovery and consumption. So how do we solve this problem?\nYou probably already know that Weaviate, as a vector database, can help with information cataloging and discovery. But did you know that Weaviate can also summarize information during retrieval?\nOur summarizer module (sum-transformers) can be added to a Weaviate instance to do exactly that.\nAnd as a bonus, we will also show you how to use our new generative module (generative-openai) to do the same thing as well.\nBy the end, you will see how you can use Weaviate to reduce the amount of TL;DRs (too "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.24 is here! Here are the release highlights. Named vectors make your collections richer and more versatile. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-24-release#named-vectors",
          "webPageMainText": "Weaviate 1.24 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nNamed vectors make your collections richer and more versatile.\nStarting in 1.24, collections can have multiple named vectors. Each vector is independent. Each vector has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to fine tune interactions with your data.\nIn earlier versions, objects in your collections are limited to one vector. Now, you can vectorize meta data like titles and descriptions so that it is available for vector search. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata. A single object in a collection can have multiple named vectors.\nYou don't have to use multiple vectors in your collections, but if you do, adjust your queries to specify which vector you want to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate uses the Raft consensus algorithm for schema replication. This is a leader-based consensus algorithm, where a leader node is responsible for schema changes. Use of Raft ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/motivation",
          "webPageMainText": "On this page you will find four use cases which motivate replication for Weaviate. Each of them serves a different purpose and, as a result, may require different configuration.\nHigh availability of a database means that the database is designed to operate continuously without service interruptions. That means that the database system should be tolerant to failures and errors, which should be handled automatically.\nThis is solved by replication, where redundant nodes can handle requests when other nodes fail.\nWeaviate considers schema operations critical, so it has a strongly consistent schema.\nFrom Weaviate v1.25, Weaviate uses the Raft consensus algorithm for schema replication. This is a leader-based consensus algorithm, where a leader node is responsible for schema changes. Use of Raft ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures.\nPrior to Weaviate v1.25, Weaviate used a leaderless design with two-phase commit for"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The latest Weaviate Python client library can be installed using pip. The client library is tested on Python 3.8 and later. The latest major version is v4 (e.g. 4.x.x). If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/setup_weaviate/client",
          "webPageMainText": "The latest Weaviate Python client library can be installed using pip. The client library is tested on Python 3.8 and later. Install it using the following command:\nThe latest major version is v4 (e.g. 4.x.x). You can check the version like so:\nFrom Python, you can load the Weaviate client library like so:\nThe client provides sets of helper classes (e.g. under weaviate.classes) and functions to make it easier to interact with Weaviate.\nNext, we'll show you how create a Weaviate instance and connect to it.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative-openai performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance. The module works in two steps: You can use the Generative OpenAI module with non-OpenAI upstream modules. You need to input both a query and a prompt."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/generative-openai",
          "webPageMainText": "The module usage instructions may vary based on whether you are using OpenAI directly or Azure OpenAI. Please make sure that you are following the right instructions for your service provider.\nFor example, the following may vary:\ngenerative-openai performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance.\nThe module works in two steps:\nYou can use the Generative OpenAI module with non-OpenAI upstream modules. For example, you could use text2vec-cohere or text2vec-huggingface to vectorize and query your data, but then rely on the generative-openai module to generate a response.\nThe generative module can provide results for:\nYou need to input both a query and a prompt (for individual responses) or a task (for all responses).\ngenerative-openai requires an API key from OpenAI or Azure OpenAI.\nYou only need to provide one of the two keys, depending on which service (OpenAI or Azure OpenAI) you are using.\nYou can provide your API key in two ways:\nDur"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate team went to our first ever AWS re:Invent in November. The focus of the event was Generative AI. We also got great feedback on our open-source RAG app, Verba. Check out our intro video or dive right in to our GitHub repo!"
              }
            ]
          },
          "url": "https://weaviate.io/blog/reinvent-2023",
          "webPageMainText": "\nThis November the Weaviate team went to our first ever AWS re:Invent! Over 50,000 people from around the world came together to learn about the latest developments in cloud technology and to share what they\u2019ve been building with the AWS developer community. Let\u2019s dive into our highlight reel!\nThis year\u2019s re:Invent focus theme was Generative AI and everyone seemed to be talking about it. In the sessions our team attended, we noticed a particular emphasis on Retrieval Augmented Generation (RAG).\nInitially when people came to our booth on Monday, roughly 40% of people knew about RAG. By the last day, nearly everyone that talked to us knew what it was because so many different sessions had covered the topic.\n\nWe also got tons of great feedback on our open-source RAG app, Verba, which we used to demo Weaviate. It\u2019s something you can use to quickly build RAG apps that fit your use case. Check out our intro video or dive right in to our GitHub repo!\n\nIt was great hearing about the different "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn how to use Weaviate to retrieve objects based on their similarity. Use various query types such as an input text, vector, or object. You will also compare vector search with keyword search to compare and contrast the two techniques, before learning how to combine the two."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/examples_1",
          "webPageMainText": "Let's take a look at a few more examples of what you can do with Weaviate.\nFirst, we will try vector searches by searching through our demo database. You will learn how to use Weaviate to retrieve objects based on their similarity, using various query types such as an input text, vector, or object.\nYou will also compare vector search with keyword search to compare and contrast the two techniques, before learning how to combine the two techniques through the use of filters.\nFor our first example, let's search our demo dataset. It contains a small sample of questions from the quiz show Jeopardy!.\nImagine that you're running a quiz night, and you want to get some questions about \"animals in movies\". In a traditional database you could look for word matches, perhaps something like:\nThis is a difficult query to write. Even worse, you would probably have to add the names of specific animals to the query as well.\nThe Weaviate query is much more intuitive. See what happens when we run the foll"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open source project that is hosted on GitHub. GitHub uses issues to request features and to track projects. Weaviate uses your feedback to plan future releases. If an issue is important to you, upvote it to let us know. Alternatively, join our forum to discuss the roadmap in more detail."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/roadmap#backlog",
          "webPageMainText": "Weaviate is an open source project that is hosted on GitHub. GitHub uses issues to request features and to track projects. This page highlights some of the issues that Weaviate is working on for upcoming releases. \nWeaviate uses your feedback to plan future releases. If an issue is important to you, upvote it to let us know. To upvote an issue, click the  icon in GitHub. The backlog lists some open issues. If you have other suggestions, open a new issue.\nTo join a discussion on GitHub, click on the issue title, and then add a comment in the discussion section. Alternatively, join our forum to discuss the roadmap in more detail.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The TypeScript client v3 supports Node.js server based development. To develop a browser based application, use the v2 client. If you have older code that uses the JavaScript client, update to the v3 client. The v2 version is still available in npm, however you should not use it to begin new projects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript",
          "webPageMainText": "The TypeScript client supports code that is written in TypeScript or JavaScript.\nThe TypeScript client v3 supports Node.js server based development. It does not support browser based web client development. To develop a browser based application, use the v2 client.\nThe v3 client is the current TypeScript client. If you have code written for the v2 client, you should migrate it to v3.\nThe v2 client version is still available in npm, however you should not use it to begin new projects.\nIf you have suggestions or comments on how to improve the new client, let us know:\nThe v3 TypeScript client replaces the v2 JavaScript only client. The JavaScript client is no longer supported. If you have older code that uses the JavaScript client, update to the TypeScript client.\nThese charts show the Weaviate client releases associated with Weaviate core releases.\nSee the client change logs on GitHub.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.24 is here! Here are the release highlights. Named vectors make your collections richer and more versatile. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-24-release#simplified-docker-configuration",
          "webPageMainText": "Weaviate 1.24 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nNamed vectors make your collections richer and more versatile.\nStarting in 1.24, collections can have multiple named vectors. Each vector is independent. Each vector has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to fine tune interactions with your data.\nIn earlier versions, objects in your collections are limited to one vector. Now, you can vectorize meta data like titles and descriptions so that it is available for vector search. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata. A single object in a collection can have multiple named vectors.\nYou don't have to use multiple vectors in your collections, but if you do, adjust your queries to specify which vector you want to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.24 is here! Here are the release highlights. Named vectors make your collections richer and more versatile. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-24-release#backend-improvements",
          "webPageMainText": "Weaviate 1.24 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nNamed vectors make your collections richer and more versatile.\nStarting in 1.24, collections can have multiple named vectors. Each vector is independent. Each vector has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to fine tune interactions with your data.\nIn earlier versions, objects in your collections are limited to one vector. Now, you can vectorize meta data like titles and descriptions so that it is available for vector search. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata. A single object in a collection can have multiple named vectors.\nYou don't have to use multiple vectors in your collections, but if you do, adjust your queries to specify which vector you want to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#specify-a-vectorizer",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Pagination is not a cursor-based implementation. This has the following implications: The autocut function limits results based on discontinuities in the result set. The query stops returning results after the specified number of jumps. The Get and Explore functions support offset. For more details, see performance considerations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-operators#cursor-with-after",
          "webPageMainText": "Functions such as limit, autocut, and sort modify queries at the class level.\nThe limit argument restricts the number of results. These functions support limit:\nTo return sets of results, \"pages\", use offset and limit together to specify a sub-set of the query response.\nFor example, to list the first ten results, set limit: 10 and offset: 0. To display the next ten results, set offset: 10. To continue iterating over the results, increase the offset again. For more details, see performance considerations\nThe Get and Explore functions support offset.\nPagination is not a cursor-based implementation. This has the following implications:\nThe autocut function limits results based on discontinuities in the result set. Specifically, autocut looks for discontinuities, or jumps, in result metrics such as vector distance or search score.\nTo use autocut, specify how many jumps there should be in your query. The query stops returning results after the specified number of jumps.\nFor example, conside"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You have successfully deployed Weaviate on your Kubernetes cluster. What you could explore, then, is how to adapt these examples to a multi-node case with replication and/or sharding. If you are interested in the architecture behind replication and sharding, please check out the following resources."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/deployment/k8s/next_steps",
          "webPageMainText": "Congratulations. You have successfully deployed Weaviate on your Kubernetes cluster, and scaled it to a multi-node setup. \ud83c\udf89\nYou can now explore the following resources to learn more about Weaviate and how to use it:\nWe have the following beginner courses available for Python:\nAnd for TypeScript/JavaScript:\nWhat you could explore, then, is how to adapt these examples to a multi-node case with replication and/or sharding.\nIf you are interested in the architecture behind replication and sharding, please check out the following resources:\nThen, check out the section on resource planning to estimate how much resources each node of a particular size might be able to handle, and how to plan your cluster accordingly.\nIf you have replication configured, you can apply tunable consistency concepts to read/write operations as well as queries.\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on s"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#oversearch-with-relativescorefusion",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A new paper from Tencent and Carnegie Mellon asked:. What text chunk size should we use in our RAG workflows? How does chunk size impact retrieval recall? Are bigger chunks better? Smaller chunks but keep more top-k? They found that instead of using 100-word passage or sentence-level chunking it's best create Propositions - concise, distinct and self-contained expressions of factoids."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper10",
          "webPageMainText": "\n\u2753What text chunk size should we use in our RAG workflows? How does chunk size impact retrieval recall? Are bigger chunks better? Smaller chunks but keep more top-k?\n\ud83d\udcdcThe new paper from Tencent and Carnegie Mellon(https://arxiv.org/abs/2312.06648) asked:\n\u23e9In Short: They found that instead of using 100-word passage or sentence-level chunking it's best create Propositions - concise, distinct and self-contained expressions of factoids. \nPropositions are generated by a finetuned LLM - which takes in paragraphs as input and is instructed to generate propositions.(blue in the image)\nGoing to try this out with the current\n@weaviate_io\nworkflows.\n\ud83d\udcd1The details:\nQnA RAG Improvements: +5.9, +7.8,+5.8, +4.9, +5.9, and +6.9 EM@100(exact match using 100 words) for SimCSE, Contriever, DPR, ANCE, TAS-B, and GTR.\nPassage Retrieval Perf. : Improvement of Recall@20 is +10.1% and +2.2% for unsupervised and supervised retrievers resp.\nPropositions have the following properties:\na. unique: a distinct piece "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "How does Weaviate store data such that it can supports these queries? In this section, we take a look at some of the key components that allow Weaviates to perform these queries at speed. In particular, we'll take a looks at indexes and the schema, which acts as a blueprint for your data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports/data_structure#inverted-index",
          "webPageMainText": "You've seen some of the powerful queries that Weaviate enables. But how does Weaviate actually store data such that it can supports these queries?\nIn this section, we'll take a look at some of the key components that allow Weaviate to perform these queries at speed. In particular, we'll take a look at indexes, which are the backbone of Weaviate's data structure, and the schema, which acts as a blueprint for your data.\nAn index is a data structure that allows for efficient retrieval of data. In Weaviate, there are two main indexes: the inverted index and the vector index.\nThe inverted index is the kind of index that you may be familiar with. You can think of it as a reference table that for example allows you to quickly look up a term and find objects that contain that term.\nThe vector index allows for efficient retrieval of vectors based on similarity. This is the index that allows Weaviate to perform vector searches fast. Let's dig in a little more.\nAn inverted index deconstructs text"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate Go client is compatible with Go 1.16+. The client doesn't support the old Go modules system. The current Go client version is v4.14.0. The suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviates instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/go#change-logs",
          "webPageMainText": "The current Go client version is v4.14.0.\nThe Weaviate Go client is compatible with Go 1.16+.\nThe client doesn't support the old Go modules system. Create a repository for your code before you import the Weaviate client.\nCreate a repository:\nTo get the latest stable version of the Go client library, run the following:\nThis example establishes a connection to your Weaviate instance and retrieves the schema.:\nFor more comprehensive information on configuring authentication with Weaviate, refer to the authentication page.\nThe Go client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows.\nThe suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviate instance.\nEach Weaviate instance in Weaviate Cloud (WCD) is pre-configured to act as a token issuer for OIDC authentication.\nSee our WCD authentication documentation for instructions on how to authenticate against WCD with your pr"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate supports two types of indices. One of Weaviate's core strengths is combining the ANN index with an inverted index. Only those algorithms which support CRUD can be used in Weaviates. The system is plug-and-playable so that we can always add other algorithms in the future."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/indexing",
          "webPageMainText": "Weaviate supports two types of indices.\nYou can configure indices in Weaviate per class. One of Weaviate's core strengths is combining the ANN index with an inverted index.\nSome things to bear in mind:\nWhat's important to know, is that the \"A\" in ANN (i.e., the \"approximate\") comes with a trade-off. That is, the index is approximate and, therefore not always 100% accurate. This is what the experts mean when they talk about the \"recall of the algorithm.\"\nThere are different ANN algorithms, you can find a nice overview of them on this website. Only those algorithms which support CRUD can be used in Weaviate (we want that sweet database UX) and Weaviate's ANN system is completely plug-and-playable so that we can always add other algorithms in the future.\nLet's take a look a few ANN settings in an example schema.\n(note that we've removed some JSON that's irrelevant to the topic at hand).\nAs shown above, there are quite a few configurable parameters available for an ANN index. Modifying the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn about the vision of the AI-First Database Ecosystem, which drives the R&D of the databases of the future. Learn about bi-encoder and cross- Encoder machine learning models, and why combining them could improve the vector search experience. Learn what makes Weaviate unique."
              }
            ]
          },
          "url": "https://weaviate.io/blog/page/9",
          "webPageMainText": "Learn about bi-encoder and cross-encoder machine learning models, and why combining them could improve the vector search experience.\nLearn what is new in Weaviate 1.14, the most reliable and observable Weaviate release yet!\nLearn about the vision of the AI-First Database Ecosystem, which drives the R&D of the databases of the future.\nSemantic search on Wikipedia dataset with Weaviate \u2013 vector database.\nWhat Weaviate users should know about Docker & Containers.\nWeaviate v1.2 introduced support for transformers (DistilBERT, BERT, RoBERTa, Sentence-BERT, etc) to vectorize and semantically search through your data.\nHow the vector database Weaviate overcomes the limitations of popular Approximate Nearest Neighbor (ANN) libraries.\nAny kind of data storage architecture needs an API. Learn how and why Weaviate picked GraphQL.\nWeaviate is an open-source vector database with a built-in NLP model called the Contextionary. Learn what makes Weaviate unique.\nLearn how the AI-first vector database We"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with Voyage AI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/voyageai",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nVoyage AI offers a wide range of models for natural language processing. Weaviate seamlessly integrates with Voyage AI's APIs, allowing users to leverage Voyage AI's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nVoyage AI's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with Voyage AI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nVoyage AI embedding integration page\n\nVoyage AI's reranker models are designed to improve the relevance and ranking of search results.\nThe Weaviate reranker integration allows u"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The v3 Python library is available on PyPI.org. The client is developed and tested for Python 3.7 and higher. The current Python client version is v4.6.5. The v3 client is not to be used with with the gRPC API that was introduced in Weaviate 1.22."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python/python_v3#batching",
          "webPageMainText": "The current Python client version is v4.6.5\nThis document relates to the v3 client. We recommend you upgrade to the v4 client if possible. The v3 client is still available for backwards compatibility, and receive with bug fixes and security updates, but it will be updated with new Weaviate features, and may be subset sometime in the second half of 2024.\nWe also have a migration guide for moving from v3 client to the v4.\nThe v3 client is not to be used with with the gRPC API that was introduced in Weaviate 1.22. You can still use Weaviate 1.22 and newer with the v3 client, however it will not take advantage of improvements made with the gRPC API. For the gRPC API, use the v4 client.\nThe v3 Python library is available on PyPI.org. The package can be installed using pip. The client is developed and tested for Python 3.7 and higher.\nNow you can use the client in your Python scripts as follows:\nOr, with additional arguments such as those below:\nFor more comprehensive information on configur"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "How to select an embedding model for your search and retrieval-augmented generation system. A comprehensive overview of common information retrieval metrics, such as precision, recall, MRR, MAP, and NDCG. How to use OpenAI's embedding models trained with Matryoshka Representation Learning in a vector database like Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/concepts",
          "webPageMainText": "How to use OpenAI's embedding models trained with Matryoshka Representation Learning in a vector database like Weaviate\nHow to select an embedding model for your search and retrieval-augmented generation system.\nA comprehensive overview of common information retrieval metrics, such as precision, recall, MRR, MAP, and NDCG.\nHybrid Search for curious Web Developers with the new Weaviate TypeScript client and Next.js\nHurricane is a web application to demonstrate Generative Feedback Loops with blog posts.\nExplore enterprise use cases heavily used by our customers adopting generative AI features, search capabilities, and RAG with Weaviate vector database.\nVerba is an open source Retrieval Augmented Generation (RAG) application built using a modular, customizable architecture that makes it easy for anyone to use AI methods to get personalized answers on their own data. \nLearn how gRPC improves import and query speeds in Weaviate\nThe new (v4) release of the Weaviate Python Client is - faster "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Chunking is the pre-processing step of splitting texts into smaller pieces of texts, i.e. \"chunks\" It can have a significant impact on the performance of vector databases, and outputs of language models. This is a preview version of this unit. Some sections are not yet complete - such as videos and quiz questions. Check back later for the full version."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking/introduction#for-optimal-retrieval-augmented-generation-rag",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nChunking is the pre-processing step of splitting texts into smaller pieces of texts, i.e. \"chunks\".\nYou know by now that a vector database stores objects by corresponding vectors to capture their meaning. But just how much text does each vector capture the meaning of? Chunking defines this. Each chunk is the unit of information that is vectorized and stored in the database.\nConsider a case where the source text comprises a set of books. A chunking method could conceivably split the text into a set of chapters, paragraphs, sentences, or even words, into chunks.\nWhile this is a simple concept, it can have a significant impact on the performance of vector databases, and outputs of language models.\nLet's go back to the above example, building a vecto"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The img2vec-neural module enables Weaviate to obtain vectors locally using a resnet50 model. It encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware. For new projects, we recommend using the multi2vec -clip module instead. This uses CLIP models, which uses a more modern model architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/img2vec-neural",
          "webPageMainText": "For new projects, we recommend using the multi2vec-clip module instead of img2vec-neural. This uses CLIP models, which uses a more modern model architecture than resnet models used in img2vec-neural. CLIP models are also multi-modal, meaning they can handle both images and text and therefore applicable to a wider range of use cases.\nThe img2vec-neural module enables Weaviate to obtain vectors locally images using a resnet50 model.\nimg2vec-neural encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use img2vec-neural, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nThis configuration enables img2vec-neural, sets it as the default v"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Whisper speech-to-text model is a game-changer! It can transcribe podcasts with astonishing accuracy, allowing us to index them into Weaviate! I have been hosting the Weaviates podcast for a little over a year with 34 published episodes and am super excited to tell you how this will completely revamp our podcast."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-podcast-search",
          "webPageMainText": "\nRecent advances in AI are breathing new life into podcasting! The Whisper speech-to-text model is a game-changer! It can transcribe podcasts with astonishing accuracy, allowing us to index them into Weaviate!\nI have been hosting the Weaviate podcast for a little over a year with 34 published episodes and am super excited to tell you how this will completely revamp our podcast, as well as the details behind how to build something like this for yourself.\nPodcasts are easy to consume, we can listen to podcasts as we drive to work, take a walk, or play a video game. However, despite their convenience, podcasts have lacked a crucial aspect that other knowledge base mediums have - the ability to easily reference and search past content.\nSo let\u2019s dive into how to build it, see some queries, and then come back to how this will change podcasting!\nOpenAI has taken a swing at unleashing the potential of AI technology, breaking open a pi\u00f1ata of new applications. Among the bounty of treats spillin"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a persistent and fault-tolerant database. This page gives you an overview of how objects and vectors are stored within Weaviate and how an inverted index is created at import time. Each class in Weaviates user-defined schema leads to the creation of an index internally. An index is a wrapper type comprised of one or many shards."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/storage#logical-storage-units-indices-shards-stores",
          "webPageMainText": "Weaviate is a persistent and fault-tolerant database. This page gives you an overview of how objects and vectors are stored within Weaviate and how an inverted index is created at import time.\nThe components mentioned on this page aid Weaviate in creating some of its unique features:\nEach class in Weaviate's user-defined schema leads to the creation of an index internally. An index is a wrapper type that is comprised of one or many shards. Shards within an index are self-contained storage units. Multiple shards can be used to distribute the load among multiple server nodes automatically.\nEach shard houses three main components:\nWeaviate doesn't rely on any third-party databases. The three components of a shard are all housed within Weaviate. This means that there are no runtime dependencies to other services and all components will scale equally with Weaviate.\nSince version v1.5.0, the object and inverted store are implemented using an LSM-Tree approach. This means that data can be ing"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/meta",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/schema/get/schema/%7BclassName%7D/shards",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Pagination is not a cursor-based implementation. This has the following implications: The autocut function limits results based on discontinuities in the result set. The query stops returning results after the specified number of jumps. The Get and Explore functions support offset. For more details, see performance considerations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-operators",
          "webPageMainText": "Functions such as limit, autocut, and sort modify queries at the class level.\nThe limit argument restricts the number of results. These functions support limit:\nTo return sets of results, \"pages\", use offset and limit together to specify a sub-set of the query response.\nFor example, to list the first ten results, set limit: 10 and offset: 0. To display the next ten results, set offset: 10. To continue iterating over the results, increase the offset again. For more details, see performance considerations\nThe Get and Explore functions support offset.\nPagination is not a cursor-based implementation. This has the following implications:\nThe autocut function limits results based on discontinuities in the result set. Specifically, autocut looks for discontinuities, or jumps, in result metrics such as vector distance or search score.\nTo use autocut, specify how many jumps there should be in your query. The query stops returning results after the specified number of jumps.\nFor example, conside"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Our mission at Weaviate is to change the way the world looks at the world. To do this, we need to change how we see the world around us. We need to look beyond our own borders and into those of others. We must also look beyond ourselves and into the future."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/page/4",
          "webPageMainText": "Our mission at Weaviate\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets. The fusion method and the relative weights are configurable. The search rankings are part of the object metadata. Weaviate uses the score to order the search results. To see the object rankings, set the explain score field in your query."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/hybrid#group-results",
          "webPageMainText": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets.\nThe fusion method and the relative weights are configurable.\nCombine the results of a vector search and a keyword search. The search uses a single query string.\nThe output is like this:\nA hybrid search on a collection that has named vectors must specify a target vector. Weaviate uses the query vector to search the target vector space.\nThe output is like this:\nTo see the object rankings, set the explain score field in your query. The search rankings are part of the object metadata. Weaviate uses the score to order the search results.\nThe output is like this:\nHybrid search results can favor the keyword component or the vector component. To change the relative weights of the keyword and vector components, set the alpha value in your query.\nThe output is like this:\nRelative Score Fusion is the default fusion method starting in v1.24.\nThe output is like this:\nFor a discussion of"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The multi2vec-bind module enables Weaviate to use the ImageBind model to vectorize data at import time. To use the module, you must enable it in your Docker Compose file (e.g. docker-compose.yml) The module requires a significant amount of memory to run."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind",
          "webPageMainText": "The multi2vec-bind module enables Weaviate to use the ImageBind model to vectorize data at import time.\nKey notes:\nmulti2vec-bind allows Weaviate to generate vectors data containing any number of the following modalities:\nThis module is not available on Weaviate Cloud.\nThe multi2vec-bind module requires a significant amount of memory to run. You may need to increase the memory limit for the multi2vec-bind container to 12 GB or more, such as through Docker Desktop's settings. You can additionally set a limit on your Docker Compose file as shown below, however your Docker Desktop memory limit must be equal to or higher than the limit set in the Docker Compose file.\nTo use multi2vec-bind, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nThis module will benefit greatly from GPU usage. Make sure to enable CUDA if you h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This is a preview version of this unit. Some sections are not yet complete - such as videos and quiz questions. Please check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below. Now that you've learned about what chunking is, and why it is important, you are ready to start looking at practical chunking techniques."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking/how_1",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nNow that you've learned about what chunking is, and why it is important, you are ready to start looking at practical chunking techniques. Here, we start by looking at fixed-size chunking techniques, including some example implementations.\nAs the name suggests, fixed-size chunking refers to the process of splitting texts into chunks of a fixed size, or at least based on size. Using fixed size chunking, you might split an article into a set of chunks of 100 words each, or a set of 200 characters each.\nThis may be the most common chunking technique due to its simplicity and effectiveness.\nFixed-size chunking is implemented by splitting texts into chunks of a fixed number of units. The units may be composed of words, characters, or even tokens, and t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.18 brings a set of great features, performance improvements, and fixes. This release introduces a compact, modern data structure to Weaviate called \u201cRoaring bitmaps\u201d The new Roaring bitmap indexing dramatically speeds up filtered searches. It provides up to 1000(!) times faster performance in some cases."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/older-releases/release_1_18",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.18, which brings a set of great features, performance improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\n\n\nThis release introduces a compact, modern data structure to Weaviate called \u201cRoaring bitmaps\u201d that will replace the internals of the inverted index. The new Roaring bitmap indexing dramatically speeds up filtered searches, and we\u2019ve seen it provide up to 1000(!) times faster performance in some cases.\nAt Weaviate, we've been on a journey to keep up with the growing needs of our users. As more and more vectors are added to Weaviate instances, the \"allow list\" of pre-filtered items can reach tens, or hundreds of millions of objects. This can result in long retrieval times that are far from ideal from a user perspective. The introduction of Roaring Bitmaps is another step that will help us and our users scale"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Chunking is essential for working with longer texts in vector databases. This unit covers how to use it as well as tips and best practices. This section hosts short, standalone units that you can read independently of any other topics. Weaviate offers many search types ( vector, keyword and hybrid), and options."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone",
          "webPageMainText": "This section hosts short, standalone units that you can read independently of any other topics.\nWeaviate offers many search types (vector, keyword and hybrid), and options. Let's discuss some good, baseline search strategies.\nChunking is essential for working with longer texts in vector databases. This unit covers how to use it as well as tips and best practices.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The cross-reference type is the graph element of Weaviate. It allows you to link to any number of instances of a given class. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/datatypes#datatype-blob",
          "webPageMainText": "When creating a property, Weaviate needs to know what type of data you will give it. Weaviate accepts the following types:\nRefer to this section on how to configure the tokenization behavior of a text property.\nPrior to v1.19, Weaviate supported an additional datatype string, which was differentiated by tokenization behavior to text. As of v1.19, this type is deprecated and will be removed in a future release.\nUse text instead of string. text supports the tokenization options that are available through string.\nThe cross-reference type is the graph element of Weaviate: you can create a link from one object to another. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema. For example:\nThe cross-reference type objects are arrays by default. This allows you to link to any number of instances of a given class (including zero).\nIn the above example, our objects "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "It is also possible to add a cross-reference property to an existing collection definition. This requires adding reference properties in both directions, and adding two cross-references per object pair. Use cross- references to establish directional relationships between collections. Use the reference property in the collection definition before adding cross-References to it."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/cross-references",
          "webPageMainText": "Use cross-references to establish directional relationships between collections.\nNotes:\nInclude the reference property in the collection definition before adding cross-references to it.\nIt is also possible to add a cross-reference property to an existing collection definition.\nSpecify a cross-reference when creating an object.\nSpecify the required id and properties for the source and the target.\nThis requires adding reference properties in both directions, and adding two cross-references per object pair (from A -> to B and from B -> to A).\nCreate the JeopardyCategory collection:\nCreate the JeopardyQuestion collection including the reference property to JeopardyCategory:\nModify JeopardyCategory to add the reference to JeopardyQuestion:\nAnd add the cross-references:\nWeaviate allows creation of multiple cross-references from one source object.\nCross-references can be read as part of the object.\nDeleting a cross-reference with the same parameters used to define the cross-reference.\nWhat ha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this section, we will explore data import, including details of the batch import process. We will discuss points such as how vectors are imported, what a batch import is, how to manage errors, and some advice on optimization. Before you start this tutorial, you should follow the steps in the tutorials to have:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/import#to-batch-or-not-to-batch",
          "webPageMainText": "In this section, we will explore data import, including details of the batch import process. We will discuss points such as how vectors are imported, what a batch import is, how to manage errors, and some advice on optimization.\nBefore you start this tutorial, you should follow the steps in the tutorials to have:\nWe will use the dataset below. We suggest that you download it to your working directory.\nDownload jeopardy_tiny.json\nAs mentioned in the schema tutorial, the schema specifies the data structure for Weaviate.\nSo the data import must map properties of each record to those of the relevant class in the schema. In this case, the relevant class is Question as defined in the previous section.\nEach Weaviate data object is structured as follows:\nMost commonly, Weaviate users import data through a Weaviate client library.\nIt is worth noting, however, that data is ultimately added through the RESTful API, either through the objects endpoint or the batch endpoint.\nAs the names suggest, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#hnsw-with-product-quantizationpq",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You can interact with Weaviate by using the GraphQL or RESTful API directly, or with one of the available client libraries. For the most seamless and language-native experience, we recommend using the client for your preferred programming language. There also exist community clients that were prepared by our wonderful community members."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries",
          "webPageMainText": "You can interact with Weaviate by using the GraphQL or RESTful API directly, or with one of the available client libraries.\nCurrently, Weaviate supports:\nYou can perform all Weaviate requests with any of these clients. For the most seamless and language-native experience, we recommend using the client for your preferred programming language.\nThere also exist community clients that were prepared by our wonderful community members. These clients are not maintained by the core Weaviate team, but by the community members themselves. To contribute to these clients, contact the maintainers directly.\nIf you want to contribute a client, or to request a particular client, let us know in the forum\nWhen querying Weaviate you can choose to write your queries in GraphQL and send the raw GraphQL query to Weaviate, or you can write the query natively to the client language you are using.\nFor example, if you were using the Weaviate Python client:\nYields the same result as:\nAdditional to complete refle"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This is a preview version of this unit. Some sections are not yet complete - such as videos and quiz questions. We'll ingest multiple sections of a book using different chunking methods before comparing how search performs. In this section, we'll use multiple entire chapters of the Pro Git book, in total containing 14 sections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking/example_chunking",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nIn the preceding sections, you've learned about chunking, and how to do it, using fixed size chunks or variable size chunks.\nIn this section and next, we'll show you holistic examples of chunking in action. We'll ingest multiple sections of a book using different chunking methods before comparing how search performs.\nYou've already seen examples of chunking with a section of the Pro Git book*. In this section, we'll use multiple entire chapters of the book, in total containing 14 sections.\nHere, we retrieve the source data from the Pro Git book, using the requests library. We will save each section as a separate object, containing some metadata (chapter title and filename) as well as the text.\nThe details here aren't important, as the source coul"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C. The strength of consistency can be determined by applying the following conditions:The data schema in Weaviates is strongly consistent."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/consistency#schema",
          "webPageMainText": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match.\nSchema consistency is extremely important, as the schema defines the structure, or the blueprint, of the data. For this reason, Weaviate uses a strong consistency protocol and Raft consensus algorithm for schema replication.\nData objects, on the other hand, are eventually consistent, which means that all nodes will eventually contain the most updated data if the data is not updated for a while. Weaviate uses a leaderless design with eventual consistency for data replication.\nThis difference reflects the trade-off inherent in consistency and availability, as described in the CAP Theorem. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C.\nThe strength of consistency can be determined by applying the following conditions:\nThe data schema in Weaviate is strongly consistent. Once you use Weaviate, the data schema is rarely chang"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate provides a ticketing system operated by the Weaviate technical team. Support tickets can be opened 24x7. Customer will work with Weaviates support personnel during the investigation of Support Tickets as reasonably needed and in a timely manner. Customer shall not provide access to any personally identifiable information for purposes of the Agreement."
              }
            ]
          },
          "url": "https://weaviate.io/weaviate-support-terms",
          "webPageMainText": "Weaviate shall provide the following Support to Customer for the licensed products:\nWeaviate provides a ticketing system operated by the Weaviate technical team that brings product expertise. Support tickets can be opened 24x7.\nIncidents and questions should be reported through the user interface as documented on our website. Tickets should include:\nCustomer will work with Weaviate support personnel during the investigation of Support Tickets as reasonably needed and in a timely manner. Weaviate does not require and Customer shall not provide access to any personally identifiable information for purposes of the Agreement.\nOur Slack community is available for everyone to discuss and share insights, although it is not an official channel for support.\nWeaviate\u2019s online documentation includes technical and user documentation, API reference documents, troubleshooting techniques, relevant conceptual articles, tutorials, and external integration examples.\nNote: All (24/7) cases must be follow"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-cohere module enables Weaviate to obtain vectors using Cohere. The module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways. We suggest you only set any given parameter in one place to avoid confusion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-cohere#how-to-use",
          "webPageMainText": "The text2vec-cohere module enables Weaviate to obtain vectors using Cohere.\nKey notes:\nThe module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways.\nWhere the same parameter can be set in multiple ways, setting it at query-time through the HTTP request header (if possible) will have the highest precedence.\nWe suggest you only set any given parameter in one place to avoid confusion.\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use text2vec-cohere, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables text2vec-cohere, sets it as the default vectorizer, and sets the API keys.\nYou can configure how the module will behave in each class through the Weaviate schema.\nThe following "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with OctoAI's APIs allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/octoai/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with OctoAI's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an OctoAI embedding model, and Weaviate will generate embeddings for various operations using the specified model and your OctoAI API key. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the OctoAI vectorizer integration (text2vec-octoai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid OctoAI API key to Weaviate for this integration. Go to OctoAI to sign up and obtain an API key.\nProvide the API key to Weaviate using one of t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You have completed this introductory course on Weaviate. You may be interested in exploring our documentation or the Academy for more advanced courses. We are constantly improving our documentation, so keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/next_steps",
          "webPageMainText": "Congratulations! You have completed this introductory course on Weaviate.\nNow that you have completed this course, you may be interested in exploring our documentation or the Academy for more advanced courses.\nSome of our more popular resources include:\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn).\nSee you soon! \ud83d\udc4b\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate seamlessly integrates with Microsoft Azure's APIs, allowing users to leverage OpenAI's models directly within the Weaviate database. These integrations empower developers to build sophisticated AI-driven applications with ease. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/openai-azure",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nMicrosoft Azure offers a wide range of OpenAI models for natural language processing and generation. Weaviate seamlessly integrates with Microsoft Azure's APIs, allowing users to leverage OpenAI's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nAzure OpenAI's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with Azure OpenAI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nAzure OpenAI embedding integration page\n\nAzure OpenAI's generative AI models can generate human-like text based on given prompts and context"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "WCD has automated, daily backups. Clusters are provisioned for common usage scenarios. WCD monitors each instance to determine when a cluster needs to be resized. If you want to customize your cluster provisioning, contact our support team at support@weaviate.io to discus."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/faq",
          "webPageMainText": "Frequently asked questions (FAQs) for WCD.\nYes. Go the WCD login page and click the \"Log in\" button. Then, click \"Forgot Password\". Enter your email address on the next screen. WCD sends a reset email to the address you enter.\nIf you do not receive a verification email, check your spam folder. If you still cannot find it, follow the steps to reset you password to get a new letter.\nYes. WCD has automated, daily backups. WCD also backs up your data before updating the version of Weaviate running on your cluster.\nYes. Click the \"Details\" button for your cluster. If a new version is available, click the \"Update!\" button when you have a suitable maintenance window. The button is only visible when there is a newer version available.\nNot currently. Clusters are provisioned for common usage scenarios. WCD monitors each instance to determine when a cluster needs to be resized.\nPossibly. If you want to customize your cluster provisioning, contact our support team at support@weaviate.io to discus"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector quantization reduces the memory footprint of the vector index by compressing the vector embeddings. Weaviate currently offers two vector quantization techniques:Product quantization is a multi-step quantization technique that is available for use with hnsw indexes in Weaivate. In neural networks, quantification reduces the values of the weights or activations of the model stored as a 32-bit floating-point number (4 bytes) to a lower precision number, such as an 8-bit integer."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-quantization#binary-quantization",
          "webPageMainText": "Vector quantization reduces the memory footprint of the vector index by compressing the vector embeddings, and thus reduces deployment costs and improves the speed of the vector similarity search process.\nWeaviate currently offers two vector quantization techniques:\nIn general, quantization techniques reduce the memory footprint by representing numbers with lower precision numbers, like rounding a number to the nearest integer. In neural networks, quantization reduces the values of the weights or activations of the model stored as a 32-bit floating-point number (4 bytes) to a lower precision number, such as an 8-bit integer (1 byte).\nProduct quantization is a multi-step quantization technique that is available for use with hnsw indexes in Weaivate.\nPQ reduces the size of each vector embedding in two steps. First, it reduces the number of vector dimensions to a smaller number of \"segments\", and then each segment is quantized to a smaller number of bits from the original number of bits ("
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Hybrid search in Weaviate combines keyword (BM25) and vector search to leverage both exact term matching and semantic context. By merging results within the same system, developers can build intuitive search applications faster. Blend vector, keyword, and multimodal techniques to deliver accurate, contextual search with less complexity."
              }
            ]
          },
          "url": "https://weaviate.io/hybrid-search",
          "webPageMainText": "Blend vector, keyword, and multimodal techniques to deliver accurate, contextual search with less complexity.\nWhile vector search is fundamental for AI-powered applications, traditional keyword search is still important for use cases where precision matters. Hybrid search in Weaviate combines keyword (BM25) and vector search to leverage both exact term matching and semantic context. By merging results within the same system, developers can build intuitive search applications faster.\nExtract value from any data modality, including documents, images, audio files, and videos.\nBuild and iterate faster with built-in vectorizer, multimodal, and multilingual models.\nOptimize performance and costs with filtering, multi-tenancy, and vector compression.\nDiscover the benefits of combining keyword and vector searches and implement hybrid search in your application.\nUnlocking the Power of Hybrid Search\nA Web Developers Guide to Hybrid Search\nBuilding an AI-Powered Shopping Copilot with Weaviate\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/resources#limit-available-resources",
          "webPageMainText": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. While you design you system, keep in mind CPU and memory management. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role.\nYou can set environment variables to manage Weaviate's resource usage, as to prevent Weaviate from using all available resources. The following environment variables are available:\nLIMIT_RESOURCES: When set to true, Weaviate automatically limits its resource usage. It sets memory usage to 80% of the total memory and uses all but one CPU core. It overrides any GOMEMLIMIT values but respects GOMAXPROCS settings.\nGOMEMLIMIT: This sets the memory limit for the Go runtime, which should be around 10-20% of the total memory available for Weaviate. It controls the aggressiveness of the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A hybrid search combines results from a keyword search and a vector search. tokenization impacts the keyword search part of a hybrid search, while the vector search part is not impacted by tokenization. We will use a similar method as in the previous section, with a difference being that we will now perform a keywordSearch instead of a filter."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/tokenization/searches",
          "webPageMainText": "You saw how tokenization affects filters. They impact keyword searches in a similar, but not identical, way. In this section, we'll see how different tokenization methods impact search results.\nA hybrid search combines results from a keyword search and a vector search. Accordingly, tokenization impacts the keyword search part of a hybrid search, while the vector search part is not impacted by tokenization.\nWe will not separately discuss hybrid searches in this course. However, the impact on keyword searches discussed here will apply to the keyword search part of a hybrid search.\nWe will use a similar method as in the previous section, with a difference being that we will now perform a keyword search instead of a filter.\nA keyword search ranks results using the BM25f algorithm. As a result, the impact of tokenization on keyword searches is twofold.\nFirstly, tokenization will determine whether a result is included in the search results at all. If none of the tokens in the search query ma"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-palm module enables Weaviate to obtain vectors using a Google API. You can use this with Google Cloud Vertex AI, or with Google AI Studio. The configurations vary slightly for each. As of the time of writing (September 2023), you must manually enable the VertexAI API on your Google Cloud project."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-palm",
          "webPageMainText": "The text2vec-palm module enables Weaviate to obtain vectors using a Google API. You can use this with Google Cloud Vertex AI, or with Google AI Studio.\nAI Studio (previously called MakerSuite) support was added in version 1.22.4.\nKey notes:\nThe module can be used with either Google Cloud Vertex AI or AI Studio. The configurations vary slightly for each.\nStarting from v1.25.1 and v1.24.14, there are separate headers X-Google-Vertex-Api-Key and X-Google-Studio-Api-Key for Vertex AI users and AI Studio respectively.\nPrior to Weaviate v1.25.1 or v1.24.14, there was one header for both Vertex AI users and AI Studio, specified with either X-Google-Api-Key or X-PaLM-Api-Key. We recommend using the new headers for clarity and future compatibility.\nAs of the time of writing (September 2023), you must manually enable the Vertex AI API on your Google Cloud project. You can do so by following the instructions here.\nThis is called an access token in Google Cloud.\nIf you have the Google Cloud CLI to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/glossary",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Check for a Weaviate server update. The console displays a notification message in the console when a new version is available. The notification displays a list of clusters that can be upgraded. Consider using high availability (HA) clusters for production workloads. An HA cluster upgrades one node at a time so the cluster is available during the upgra."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/upgrade",
          "webPageMainText": "WCD does not automatically upgrade existing clusters when a new version of Weaviate core is released.\nIf you have a stand-alone cluster, an upgrade requires system downtime. Consider your business needs, and upgrade your cluster when you have a suitable maintenance window. There is no downtime if you have a high availability (HA) cluster.\nCheck for a Weaviate server update.\nThe console displays a notification message in the console when a new version is available.\n\nClick to expand the notification. The notification displays a list of clusters that can be upgraded.\n\nTo check if you are running the latest version of Weaviate, follow these steps.\nThe tile has an \"Update!\" button when a newer version is available.\n\n WCD restarts your cluster during an upgrade. A standard cluster is unavailable during the upgrade.\n To avoid downtime, consider using high availability (HA) clusters for production workloads. An HA cluster upgrades one node at a time so the cluster is available during the upgra"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You can use Google Cloud Marketplace to directly launch a Weaviate cluster. You can interact with the cluster using kubectl, or through the Weaviates API. We show examples below. The steps are as follows: configure the cluster, then deploy the application."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/gc-marketplace",
          "webPageMainText": "You can use Google Cloud Marketplace to directly launch a Weaviate cluster.\nBroadly, the steps are as follows:\nWe go through these steps in detail below.\nOnce you are at the deployment page, you should see a set of options.\nYou will need to:\nOnce you have done so, Weaviate will be deployed to the selected cluster. This should take a few minutes.\nOnce the application has been created, you can access the cluster through the load balancer.\nYou can interact with the cluster using kubectl, or through the Weaviate API. We show examples below.\nYou can run the following command which will update or create a kubeconfig file for the Weaviate cluster:\nThe exact command can be found in the Kubernetes Engine page, by clicking on the vertical ellipsis (  ) for your cluster, and clicking Connect.\nOnce that's set up, you can run kubectl commands as usual. For example\nAn example output of kubectl get svc --all-namespaces is:\nHere, the externally accessible Weaviate IP is 34.173.96.14.\nOnce the applicat"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Make sure to have your Weaviate instance set up. You should have created an instance and be able to connect to it. We are going to use a movie dataset sourced from TMDB. The dataset can be found in this GitHub repository. It contains bibliographic information on ~700 movies released between 1990 and 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_collections/preparation",
          "webPageMainText": "In this section you are going to populate your Weaviate instance with a movie dataset and corresponding vectors which are generated outside of Weaviate.\nMake sure to have your Weaviate instance set up. You should have created an instance and be able to connect to it.\nWe are going to use a movie dataset sourced from TMDB. The dataset can be found in this GitHub repository, and it contains bibliographic information on ~700 movies released between 1990 and 2024.\nNext, you will create a corresponding object collection and import the data.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A vector is a numerical representation of the underlying object's meaning. A vector search is robust to any changes that don't affect the meaning of the object. These different search types are offered because they each have different characteristics, and therefore different strengths. Let's explore the relative strengths of each search type."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/which_search/strengths",
          "webPageMainText": "These different search types are offered because they each have different characteristics, and therefore different strengths.\nLet's explore the relative strengths of each search type.\nA vector is a numerical representation of the underlying object's meaning. As a result, a vector search is robust to any changes that don't affect the meaning of the object.\nMore concretely, a vector of \"cat\", for example, will be similar to a vector of \"kitten\", \"feline\", and \"pet\", even though their spellings are very different.\nSee this in action below, where we search for \"cat\" and \"kitten\" using vector search.\nYou see that the results for \"cat\" and \"kitten\" are very similar.\nIn other words, the vectors for \"cat\" and \"kitten\" are similar in meaning, because the model can \"understand\" meaning.\nSimilarly, a vector of \"cat\" is similar to the vector of \"cat\" with a spelling mistake, such as \"caat\", or \"catt\".\nHere, the results are basically identical.\nThis robustness is a key strength of vector search, as"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate v1.20 - coming in July 2023 - changes this once and for all. Native multi-tenancy support that scales to millions of tenants with 10s of thousands of active tenants per node. GDPR-compliant deletes with one command are just one of the many features."
              }
            ]
          },
          "url": "https://weaviate.io/blog/multi-tenancy-vector-search",
          "webPageMainText": "\nLarge-scale setups were always a great reason to choose Weaviate. Last year we wrote about the first time a Weaviate setup ran with a billion objects & vectors. What was a mere experiment back then is a regular production case today. But earlier this year, we saw a shift in usage patterns: As we onboarded more and more large-scale and enterprise users, the definition of scale shifted from the number of vectors to the number of individual tenants that can run on a single setup.\nPreviously, Weaviate offered multiple ways to tackle multi-tenancy, but none were intended for a massive scale. Weaviate v1.20 - coming in July 2023 - changes this once and for all: Native multi-tenancy support that scales to millions of tenants with 10s of thousands of active tenants per node. Yet scale is not the only point that makes the new multi-tenancy feature great; we put a lot of emphasis on compliance and a smooth UX. GDPR-compliant deletes with one command are just one of the many features. Let me wal"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Academy offers Python and TypeScript/JavaScript courses. We are constantly improving our documentation, so keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/theory/hello_weaviate/next_steps",
          "webPageMainText": "After reading this theoretical overview of Weaviate, you may be interested in getting hands-on. If so, we recommend you to check out one of the Python or TypeScript/JavaScript courses in the Academy.\nWe have the following beginner courses available for Python:\nAnd for TypeScript/JavaScript:\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn).\nSee you soon! \ud83d\udc4b\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers aggregation queries. They are collectively referred to as Aggregate queries within. An Aggregate query can aggregate over an entire collection, or the results of a search. Each query can include any of the following types of arguments:Each data type has its own set of available aggregated properties."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/aggregate",
          "webPageMainText": "This page covers aggregation queries. They are collectively referred to as Aggregate queries within.\nAn Aggregate query can aggregate over an entire collection, or the results of a search.\nAn Aggregate query requires the target collection to be specified. Each query can include any of the following types of arguments:\nEach data type has its own set of available aggregated properties. The following table shows the available properties for each data type.\nBelow is an example query to obtain meta information about the Article collection. Note that the data is not grouped here, and results relate to all data objects in the Article collection.\nThe above query will result in something like the following:\nAs such, this Aggregate query will retrieve the total object count in a class.\nYou can use a groupBy argument to get meta information about groups of data objects.\nThe groupBy argument is structured as follows for the Aggregate function:\nIn the following example, the articles are grouped by "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Named vectors can be used in RAG queries to improve workflow and results. RAG, or retrieval augmented generation, is a powerful feature that combines the strengths of both vector search and language generation. Named vectors allow different users to search and generate results based on their specific needs, using the same collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors/nv_queries/use_cases",
          "webPageMainText": "RAG, or retrieval augmented generation, is a powerful feature that combines the strengths of both vector search and language generation.Named vectors can be used in RAG queries to improve workflow and results.\nIn this section, we'll explore a few examples of how named vectors allow different users to search and generate results based on their specific needs, using the same collection.\nImagine a design agency (Aesthetico) that is contracted to work on the poster design for a new movie.\nAesthetico's designers have arrived on this film poster design. They would now like to see how their poster compares to other movie posters in existence, and what types of movies these posters are for.\nLuckily for them, the MovieNVDemo collection has poster_title named vectors which is primarily based on the poster design. So Aesthetico's designers can search poster_title named vector and find movies that are similar to their poster design. And, they can then perform RAG to summarize the movies which are "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "To configure Weaviate in a Docker or a Kubernetes deployment, set these environment variables. For Boolean environment variables, \"on\", \"enabled\", \"1\", and \"true\" are interpreted as true. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/env-vars",
          "webPageMainText": "To configure Weaviate in a Docker or a Kubernetes deployment, set these environment variables\nFor Boolean environment variables, \"on\", \"enabled\", \"1\", and \"true\" are interpreted as true.\nAll other values are interpreted as false.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#helper-classes",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate stores data in \"collections\" A collection is a set of objects that share the same data structure. Each property has a name and a data type. Weaviate can automatically infer the data. However, it's a good practice to define the properties explicitly."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_collections/create_collection",
          "webPageMainText": "Weaviate stores data in \"collections\". A collection is a set of objects that share the same data structure. In our movie database, we might have a collection of movies, a collection of actors, and a collection of reviews.\nHere we will create a collection of movies.\nThis example creates a collection for the movie data:\nEach collection definition must have a name. Then, you can define additional parameters like we've done in this example.\nProperties are the object attributes that you want to store in the collection. Each property has a name and a data type.\nIn our movie database, we have properties like title, release_date and genre_ids, with data types like TEXT (string), DATE (date), or INT (integer). It's also possible to have arrays of integers, like we have with genre_ids.\nWeaviate can automatically infer the schema from the data. However, it's a good practice to define the properties explicitly, for better control and to avoid surprises.\nIn this code example, we specify the vectori"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Voyage AI's APIs allows you to access their models' capabilities directly from Weaviate. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/voyageai/reranker",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Voyage AI's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use a Voyage AI reranker model, and Weaviate will use the specified model and your Voyage AI API key to rerank search results.\nThis two-step process involves Weaviate first performing a search and then reranking the results using the specified model.\n\nYour Weaviate instance must be configured with the Voyage AI reranker integration (reranker-voyageai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Voyage AI API key to Weaviate for this integration. Go to Voyage AI to sign up and obtain an API key.\nProvide the API key to Weaviate using one of the following methods:\nConfigure a Weaviate collection to use a Voyage AI reranker model as follows:"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Prototyping an LLM-powered application is fun and easy but when you want to make it production-ready to use in your company, you will quickly face a variety of challenges. Retrieval-Augmented Generation (RAG) has been shown to be effective against hallucinations. Local deployments are a popular approach for privacy preservation. Everything is local, open source, and doesn\u2019t require any API keys!"
              }
            ]
          },
          "url": "https://weaviate.io/blog/local-rag-with-ollama-and-weaviate",
          "webPageMainText": "\nPrototyping an LLM-powered application is fun and easy but when you want to make it production-ready to use in your company, you will quickly face a variety of challenges, such as mitigating hallucinations or protecting data privacy. While Retrieval-Augmented Generation (RAG) has been shown to be effective against hallucinations, local deployments are a popular approach for privacy preservation.\nThis article showcases how you can implement a local RAG-based chatbot in Python in an on-premises environment without any dependencies on the outside world using the following local components:\nEverything is local, open source, and doesn\u2019t require any API keys!\nHad I known that getting set up with Ollama takes less than 5 minutes, I wouldn\u2019t have put it off for so long.\nDownload the Ollama version for your operating system from the official download page and follow the few installation steps.\nOpen a terminal and pull the relevant LLMs and embedding models of your choice. For this tutorial, we"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue. Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/filters",
          "webPageMainText": "Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion. The operator used for filtering is also called a where filter.\nA filter may consist of one or more conditions, which are combined using the And or Or operators. Each condition consists of a property path, an operator, and a value.\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\nFor example, this filter will only allow objects from the class Article with a wordCount that is GreaterThan than 1000.\nThe where filter is an algebraic object, which takes the following arguments:\nIf the operator is And or Or, the operands are a list of where filters.\nWeaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue.\nThe behavior for the Equal operator on multi-word textual properties in where filters depends on the tokenization of the property.\nSee the Schema p"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C. The strength of consistency can be determined by applying the following conditions:The data schema in Weaviates is strongly consistent."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/consistency#tunable-read-consistency",
          "webPageMainText": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match.\nSchema consistency is extremely important, as the schema defines the structure, or the blueprint, of the data. For this reason, Weaviate uses a strong consistency protocol and Raft consensus algorithm for schema replication.\nData objects, on the other hand, are eventually consistent, which means that all nodes will eventually contain the most updated data if the data is not updated for a while. Weaviate uses a leaderless design with eventual consistency for data replication.\nThis difference reflects the trade-off inherent in consistency and availability, as described in the CAP Theorem. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C.\nThe strength of consistency can be determined by applying the following conditions:\nThe data schema in Weaviate is strongly consistent. Once you use Weaviate, the data schema is rarely chang"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.19 brings a set of great features, performance improvements, and fixes. A downgrade to v1.18 will no longer be supported. You can now group Get search results based on a specific property. The groups and objectsPerGroup limits are custom."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-19-release",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.19, which brings a set of great features, performance improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\nKeep in mind that after upgrading to v1.19 a downgrade to v1.18 will no longer be supported. If you anticipate having to downgrade, please create a backup before upgrading! If a backup is done with v1.18 before upgrading, you can always go back to v1.18 if you wish.\n\nWith the introduction of this feature, you can now group Get search results based on a specific property.\nTake a collection of Passage objects for example, each object belonging to a Document. If searching through Passage objects, you can group the results according to any property of the Passage, including the cross-reference property that represents the Document each Passage is associated with.\nThe groups and objectsPerGroup limits are customi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this section, we'll work with an actual Weaviate instance to see how different tokenization methods impact filtering results. We are going to use a very small, custom dataset for demonstration purposes. We will create a simple object collection, with each object containing multiple properties."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/tokenization/filters",
          "webPageMainText": "Now that you've learned about different tokenization methods, let's put them into practice. In this section, you'll see how tokenization impacts filters.\nFor this section, we'll work with an actual Weaviate instance to see how different tokenization methods impact filtering results.\nWe are going to use a very small, custom dataset for demonstration purposes.\nTo follow along, you can use the following Python code to add this data to your Weaviate instance.\nWe will create a simple object collection, with each object containing multiple properties. Each properties will contain the same text, but with different tokenization methods applied.\nNote that we do not add object vectors in this case, as we are only interested in the impact of tokenization on filters (and keyword searches).\nNow, we add objects to the collection, repeating text objects as properties.\nNow that we have added a set of objects to Weaviate, let's see how different tokenization methods impact filtered retrieval.\nEach filt"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#asynchronous-status-checking-1",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with Google AI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps. The model provider integration pages are new and still undergoing improvements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/google",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nGoogle AI offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with Google AI Studio and Google Vertex AI APIs, allowing users to leverage Google AI's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nGoogle AI's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with Google AI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nGoogle AI embedding integration page\n\nGoogle AI's generative AI models can generate human-like text based on given prompts and contexts."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Self-Supervised Retrieval can surpass BM25 and Supervised techniques. In-depth technical breakdown of how binary quantization works and how to use it in Weaviate. How does Vamana compare to HNSW? How does it work on disks?"
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/research",
          "webPageMainText": "In-depth technical breakdown of how binary quantization works and how to use it in Weaviate.\nBoosting Weaviate using SIMD-AVX512, Loop Unrolling and Compiler Optimizations\nThe details behind how you can compress vectors using PQ with little loss of recall!\nFine-tuning LlaMA 7B to use the Weaviate GraphQL APIs\nUsing the Weaviate Tile Encoder to compress vectors with Product Quantization.\nImplementing HNSW + Product Quantization (PQ) vector compression in Weaviate.\nVector search on disks: How does Vamana compare to HNSW?\nSelf-Supervised Retrieval can surpass BM25 and Supervised techniques. This technique also pairs very well alongside BM25 in Hybrid Retrieval. Learn more about it.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's package structure is modelled after CleanArchitecture. The most central \"entities\" are found in the ./entities subpackages. All of these packages areagnostic of the API-types (GraphQL, REST, etc) as well as the usecases/kinds package."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/structure",
          "webPageMainText": "Weaviate's package structure is modelled after Clean\nArchitecture.\nWe believe Clean Architecture is a good fit for Weaviate. Besides the benefits\nlisted on the Clean Architecture page, we think it's a great fit for the\nfollowing reasons:\nThe most central \"entities\" are found in the ./entities subpackages.\nentities/models are auto-generated from go-swagger, whereas the remaining\nentities are custom-built. Note that allowing framework-generated packages to\nbe entities is not in line with Clean Architecture. This is mostly due to\nhistoric reasons. Entities are mostly structures with properties. Methods on\nthose structures are mainly accessor methods.\nThe usecases are located in the ./usecase folder. This is where most of the\napplication-specific business logic sits. For example CRUD logic and its\nvalidation sits in the usecases/kinds package and methods to traverse the\ngraph are in the usecases/traverser package. All of these packages are\nagnostic of the API-types (GraphQL, REST, etc) as "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-jinaai module enables Weaviate to obtain vectors using JinaAI Embeddings. To use the module, you must enable it in your Docker Compose file ( docker-compose.yml) You can supply the API key at query time by adding it to the HTTP header."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-jinaai",
          "webPageMainText": "The text2vec-jinaai module enables Weaviate to obtain vectors using JinaAI Embeddings.\nKey notes:\nTo use text2vec-jinaai, you must enable it in your Docker Compose file (docker-compose.yml). You can edit the Docker Compose file manually, or use the the Weaviate configuration tool to create a custom file.\nThis Docker Compose file shows how to use JinaAI as the vectorizer.\nTo configure how the module behaves in each collection, update the Weaviate schema.\nThe following example configures the Document collection by setting the vectorizer to text2vec-jinaai and the model to jina-embeddings-v2-small-en:\nYou can set vectorizer behavior using the moduleConfig section under each collection and property:\nYou can supply the API key at query time by adding it to the HTTP header.\nThis is an example of a nearText query that uses text2vec-jinaai.\nThe following models are available:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You must provide a valid OctoAI API key to use this service. The API key can be used to create, edit, and delete content. You can also use the API to make changes to the content of the service. For more information, visit www.octoai.com."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/octoai/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with OctoAI's APIs allows you to access open source and their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use an OctoAI generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model and your OctoAI API key.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the OctoAI generative model to generate outputs.\n\nYour Weaviate instance must be configured with the OctoAI generative AI integration (generative-octoai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid OctoAI API key to Weaviate for this integration. Go to OctoAI to sign up and obtain an API key.\nProvide the API key to Weaviate using one of the following methods:\nConfigure a "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector quantization reduces the memory footprint of the vector index by compressing the vector embeddings. Weaviate currently offers two vector quantization techniques:Product quantization is a multi-step quantization technique that is available for use with hnsw indexes in Weaivate. In neural networks, quantification reduces the values of the weights or activations of the model stored as a 32-bit floating-point number (4 bytes) to a lower precision number, such as an 8-bit integer."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-quantization",
          "webPageMainText": "Vector quantization reduces the memory footprint of the vector index by compressing the vector embeddings, and thus reduces deployment costs and improves the speed of the vector similarity search process.\nWeaviate currently offers two vector quantization techniques:\nIn general, quantization techniques reduce the memory footprint by representing numbers with lower precision numbers, like rounding a number to the nearest integer. In neural networks, quantization reduces the values of the weights or activations of the model stored as a 32-bit floating-point number (4 bytes) to a lower precision number, such as an 8-bit integer (1 byte).\nProduct quantization is a multi-step quantization technique that is available for use with hnsw indexes in Weaivate.\nPQ reduces the size of each vector embedding in two steps. First, it reduces the number of vector dimensions to a smaller number of \"segments\", and then each segment is quantized to a smaller number of bits from the original number of bits ("
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/tags",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Nelson Liu and Percy Liang's group at Stanford recently published a paper that discovered this \"lost in the middle\" effect.Greg Kamradt also ran great experiments and posted about how this very same pattern of underperformance exists in the new GPT-4 128K models from OpenAI."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper-2",
          "webPageMainText": "\nWhy do large language models pay more attention to and reason better over the beginning and end of what you tell them in prompts?\ud83e\udd14\nNelson Liu and Percy Liang's group at Stanford recently published a paper that discovered this \"lost in the middle\" effect. \nGreg Kamradt also ran great experiments and posted about how this very same pattern of underperformance exists in the new GPT-4 128K models from OpenAI. \nThe point of the paper was to establish \"how well LLMs use longer context\" and ran experiments conducting QnA and key-value retrieval tasks on models from Mosaic, Anthropic and OpenAI and varied input context size and the position of the relevant information in the context.\nThe main discovery was that attention followed a U-shaped pattern where more importance was given to the beginning and end of the context window as opposed to the middle portion.\nThis is such a great paper with a wealth of knowledge gems\ud83d\udc8e- here are some details and reasons why this happens:\nDue to Model Architect"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The gRPC API is faster than the REST API. Use it to improve import speeds. Batch imports are an efficient way to add multiple data objects and cross-references. To create a bulk import job, follow these steps:The following example adds objects to the MyCollection collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/import#import-with-references",
          "webPageMainText": "Batch imports are an efficient way to add multiple data objects and cross-references.\nTo create a bulk import job, follow these steps:\nThe following example adds objects to the MyCollection collection.\nThe gRPC API is faster than the REST API. Use the gRPC API to improve import speeds.\nThe Python client uses gRPC by default. See the client page for additional batch import configuration options.\nThe TypeScript client v3 uses gRPC by default.\nTo use the gRPC API with the Java client, add the setGRPCHost field to your client connection code. Update setGRPCSecured if you use an encrypted connection.\nTo use the gRPC API with the Go client, add the GrpcConfig field to your client connection code. Update Secured if you use an encrypted connection.\nTo use the gRPC API with the Spark connector, add the grpc:host field to your client connection code. Update grpc:secured if you use an encrypted connection.\nWeaviate generates an UUID for each object. Object IDs must be unique. If you set object ID"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with the Hugging Face Transformers library allows you to access their models' capabilities directly from Weaviate.Configure a Weaviates vector index to use the Transformers integration. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with the Hugging Face Transformers library allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use the Transformers integration, and configure the Weaviate instance with a model image, and Weaviate will generate embeddings for various operations using the specified model in the Transformers inference container. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the Hugging Face Transformers vectorizer integration (text2vec-transformers) module.\nThis integration is not available for Weaviate Cloud (WCD) serverless instances, as it requires spinning up a container with the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors/nv_collections",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default docker image doesn't need any configuration. To customize your instance, edit the configuration settings in the docker-compose.yml file. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally. You can use environment variables to control your Weaviates setup, authentication and authorization."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/docker-compose#starter-docker-compose-file",
          "webPageMainText": "Weaviate supports deployment with Docker. If you use the default values, you don't need a docker-compose.yml file to run the image. To customize your instance, edit the configuration settings in the docker-compose.yml file.\nThe default docker image doesn't need any configuration. To run a basic Weaviate instance, run this command from a terminal:\nThe command sets the following default values:\nWe prepared a starter Docker Compose file, which will let you:\nSave the text below as docker-compose.yml:\nEdit the docker-compose.yml file to add your local configuration. To start your Weaviate instance, run this command in your shell:\nThe Configurator can generate a docker-compose.yml file for you. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally (i.e. text2vec-transformers, or multi2vec-clip)\nYou can use environment variables to control your Weaviate setup, authentication and authorization, module settings, and data storage settings.\nA comprehensi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate TypeScript client supports TypeScript and JavaScript. Use the TypeScript v3 client for new projects. If your application is browser based, consider using the Type Script client v2. The v3 Client uses ES Modules and CommonJS compatibility. The client is version v3.0.5. See v3 packages for details."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript/typescript-v3",
          "webPageMainText": "The TypeScript client is version v3.0.5. Use the TypeScript v3 client for new projects.\nThe Weaviate TypeScript client supports TypeScript and JavaScript.\nThe v3 client supports server side development (Node.js hosted). See v3 packages for details. If your application is browser based, consider using the TypeScript client v2.\nIf you are migrating a project from the Weaviate TypeScript client v2 to the v3 client, see the migration page for additional details.\nThis section details how install and configure the v3 TypeScript client.\nThe v3 client package has a new name, weaviate-client. Use npm to install the TypeScript client library package:\nThe v3 client uses ES Modules. Most of the sample code in the documentation also uses the ES Module style.\nIf your code requires CommonJS compatibility, use the CommonJS import style:\nEdit your project's configuration files to make these changes:\nThe v3 client provides helper functions to connect your application to your Weaviate instance.\nEmbedded "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A full application of AI or embeddings is much more than just a prompt or a model. It\u2019s an integrated system that combines data, models, compute, and user interfaces. In this blog post, we\u2019ll talk about how we built a full application that discovers analogies between Wikipedia articles by combining serverless infrastructure from Modal and Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/blog/modal-and-weaviate",
          "webPageMainText": "\nA full application of AI or embeddings is much more than just a prompt or a model: it\u2019s an integrated system that combines data, models, compute, and user interfaces.\nIn this blog post, we\u2019ll talk about how we built a full application that discovers analogies between Wikipedia articles by combining serverless infrastructure from Modal with the search and storage capabilities of Weaviate. Try it here!\nThe goal of this blog post is to provide you with a quick overview of Modal and Weaviate and how we used them together to build out the search backend for our application. A tutorial on how to run and deploy the demo yourself can be found in Modal's documentation.\nWe\u2019ll be searching Wikipedia for articles that complete analogies using a combination of text search and vector-based semantic search. Naturally, that makes Weaviate a great fit!\nTo provide the infrastructure for computing the vector embeddings, we used Modal.\nModal makes it easy for Python developers to deploy serverless applic"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If you are new to Weaviate, we recommend you start with one of the 100-level courses written with the v4 client API. This course was written for the Weaviates client API (v3), and is now deprecated. It is best practice to use virtual environments to isolate projects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/setup",
          "webPageMainText": "This course was written for the Weaviate Python client API (v3), and is now deprecated.\nIf you are new to Weaviate, we recommend you start with one of the 100-level courses written with the v4 client API, such as those for working with text data, your own vectors, or multimodal data.\nFollow this short guide to make sure that you are set up to use Weaviate with the Python client.\nIf you have not yet set up Python and the Weaviate Python client, follow the instructions below.\nYou can install Python 3 in a variety of ways. One easy way is to use an appropriate installer for your system as per instructions on Python.org.\nIt is best practice to use virtual environments to isolate projects.\nIf you're not familiar with virtual environments, we highly recommend reading up on them - this tutorial on FreeCodeCamp is a good resource, as is this article on RealPython, which goes a little more in-depth.\nYou will also need the following libraries:\nActivate your virtual environment, and install the W"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "With Weaviate, you can perform semantic searches to find similar items. This is done by comparing the vector embeddings of the items in the database. This example finds entries in \"Movie\" based on their similarity to the query \"dystopian future\", and prints out the title and release year of the top 5 matches."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_searches/semantic",
          "webPageMainText": "With Weaviate, you can perform semantic searches to find similar items based on their meaning. This is done by comparing the vector embeddings of the items in the database.\nThis example finds entries in \"Movie\" based on their similarity to the query \"dystopian future\", and prints out the title and release year of the top 5 matches.\nThe results are based on similarity of the vector embeddings between the query and the database object text. In this case, the embeddings are generated by the vectorizer module.\nThe limit parameter here sets the maximum number of results to return.\nThe return_metadata parameter takes an instance of the MetadataQuery class to set metadata to return in the search results. The current query returns the vector distance to the query.\nThe returned object is an instance of a custom class. Its objects attribute is a list of search results, each object being an instance of another custom class.\nEach returned object will:\nIf you have any questions or feedback, let us "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This release introduces the multi2vec-clip module, a module that allows for multi-modal vectorization within a single vector space. A class can have image or text fields or both. The module provides both a nearText and a nearImage search and allows for various search combinations, such as text-search on image-only content."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/migration",
          "webPageMainText": "This version introduces indexFilterable and indexSearchable variables for the new text indexes, whose values will be set based on the value of indexInverted.\nSince filterable & searchable are separate indexes, filterable does not exist in Weaviate instances upgraded from pre-v1.19 to v1.19. The missing filterable index can be created though on startup for all text/text[] properties if env variable INDEX_MISSING_TEXT_FILTERABLE_AT_STARTUP is set.\nno breaking changes\nNew Features\nThis release introduces the multi2vec-clip module, a module that allows for multi-modal vectorization within a single vector space. A class can have image or text fields or both. Similarly, the module provides both a nearText and a nearImage search and allows for various search combinations, such as text-search on image-only content and various other combinations.\nThe following is a valid payload for a class that vectorizes both images and text fields:\nNote that:\nYou can then import data objects for the class as"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate stores data in \"collections\" A collection is a set of objects that share the same data structure. Each property has a name and a data type like title, date and genre. Weaviate can automatically infer the data from the collection. We can also use the built-in search function to search for specific objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_collections/create_collection",
          "webPageMainText": "Weaviate stores data in \"collections\". A collection is a set of objects that share the same data structure. In our movie database, we might have a collection of movies, a collection of actors, and a collection of reviews.\nHere we will create a collection of movies.\nThis example creates a collection for the movie data:\nEach collection definition must have a name. Then, you can define additional parameters like we've done in this example.\nProperties are the object attributes that you want to store in the collection. Each property has a name and a data type.\nIn our movie database, we have properties like title, release_date and genre_ids, with data types like TEXT (string), DATE (date), or INT (integer). It's also possible to have arrays of integers, like we have with genre_ids.\nWeaviate can automatically infer the schema from the data. However, it's a good practice to define the properties explicitly, for better control and to avoid surprises.\nIf you do not specify the vector yourself, W"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This section describes Weaviate's individual modules, including their capabilities and how to use them. Modules can be \" vectorizers\" (defines how the numbers in the vectors are chosen from the data) or other modules providing additional functions."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules",
          "webPageMainText": "This section describes Weaviate's individual modules, including their capabilities and how to use them.\nModules can be \"vectorizers\" (defines how the numbers in the vectors are chosen from the data) or other modules providing additional functions like question answering, custom classification, etc. Modules have the following characteristics:\nUnless you specify a default vectorization module in Weaviate's configuration, you'll need to specify which vectorization module is used per class you add to the data schema (or you need to enter a vector for each data point you add manually). Set the default with the environment variable DEFAULT_VECTORIZER_MODULE to text2vec-contextionary in the Docker Compose file:\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorizatio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use an ID to retrieve an object. If the id doesn't exist, Weaviate returns a 404 error. When multi-tenant datasets are enabled, the tenant name is required. If an object with a given id exists without retrieving it, make a HEAD request to the /v1/objects/ REST endpoint."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/read",
          "webPageMainText": "Instead of querying your database, you can use an ID to retrieve individual objects.\nCollections act like namespaces, so two different collections could have duplicate IDs between them.\n\n\nPrior to Weaviate v1.14 you can manipulate objects without specifying the collection name. This method is deprecated. It will be removed in Weaviate v2.0.0.\nStarting in v1.20, you can have multi-tenant datasets. When multi-tenancy is enabled, the tenant name is required.\nAlways include the collection name, and, when enabled, the tenant name.\nUse an ID to retrieve an object. If the id doesn't exist, Weaviate returns a 404 error.\nObject vectors can be retrieved by specifying its return.\nWhere named vectors are used, you can retrieve one or more of them by specifying their names.\nTo efficiently check if an object with a given id exists without retrieving it, make a HEAD request to the /v1/objects/ REST endpoint, or use the following client code:\nIf you have any questions or feedback, let us know in the u"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this unit, you saw how data is structured in Weaviate, and got hands-on experience populating your own instance. You also had a chance to import data according to this schema, and learned how to use batch imports to ensure that imports are as fast as possible. Now, you should be able to:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports/wrap_up",
          "webPageMainText": "In this unit, you saw how data is structured in Weaviate, and got hands-on experience populating your own instance of Weaviate from start to finish.\nYou have got hands-on experience in defining and creating a schema including classes, properties, data types and vectorization configurations. You also had a chance to import data according to this schema, and learned how to use batch imports to ensure that imports are as fast as possible.\nNow, you should have a broad understanding of Weaviate's indexes and schema, and how they work to store data to enable efficient, flexible, and powerful retrieval.\nHaving finished this unit, you should be able to:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#flat-index",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Accounts in Weaviate Cloud (WCD) are based on organizations. There is an organization for each user account. Users can belong to more than one organization. Each user in an organization has full access to the modify the organization and its clusters. To create a new organization, follow these steps."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/users-and-organizations",
          "webPageMainText": "Accounts in Weaviate Cloud (WCD) are based on organizations. There is an organization for each user account. Users can belong to more than one organization.\nUser accounts are identified by email addresses. Each user account has it's own default organization.\nOrganizations group user accounts together. Every user in the organization has the same access to organization assets:\nBe cautious when you add users to your organization, especially in production. Each user in an organization has full access to the modify the organization and its clusters.\nUser editable configuration settings are on the organization settings tab.\nTo open the settings tab, click Organization settings at the bottom of the organizations pull down menu.\nTo create a new organization, follow these steps:\nClick the organization pulldown menu in the WCD console.\nClick \"Add new organization\".\nEnter the organization name.\nWCD automatically switches the console view to the new organization.\nTo switch between organizations, s"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.21 released with new operators, performance improvements, multi-tenancy improvements, and more. Join us in celebrating Hacktoberfest, a month-long celebration of open source. A preview release of our new Python client is now available. Help us make it better by trying it out and providing your feedback."
              }
            ]
          },
          "url": "https://weaviate.io/blog/page/4",
          "webPageMainText": "Join us in celebrating Hacktoberfest, a month-long celebration of open source!\nA preview release of our new Python client is now available! Help us make it better by trying it out and providing your feedback.\nLearn how to build an application using Weaviate and Confluent\nThe details behind how you can compress vectors using PQ with little loss of recall!\nFine-tuning LlaMA 7B to use the Weaviate GraphQL APIs\nHow hybrid search works, and under the hood of Weaviate's fusion algorithms.\nWeaviate 1.21 released with new operators, performance improvements, multi-tenancy improvements, and more!\nLearn about why you need distance metrics in vector search and the metrics implemented in Weaviate (Cosine, Dot Product, L2-Squared, Manhattan, and Hamming).\nVector databases explained by their core concepts of vector embeddings, vector search, and vector indexing\nLearn about our latest open source demo and how we used Semantic and Generative Search to improve access to health\nLearn how to make testing"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A new way to chunk your data using LLM's. Getting an LLM to check its own responses for hallucination. Using prompt engineering to solve the 'lost in the middle' problem. Using LLMs to learn and use a secret language. Text2image diffusion models."
              }
            ]
          },
          "url": "https://weaviate.io/papers/page/3",
          "webPageMainText": "text2image diffusion models learn and use a secret language.\nCompares finetuning vs RAG for improvement on a specific domain.\nA new way to chunk your data using LLM's.\nGet an LLM to check its own responses for hallucination.\nMaking LLMs forget by finetuning.\nUsing prompt engineering to solve the 'lost in the middle' problem.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "There are four major GitHub repositories of Weaviate, any of which you can contribute to. You can also contribute by working on existing issues. Consider starting with issues tagged 'good first issues' If you are not sure where to start, we suggest finding something that overlaps with your interests."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/getting-started",
          "webPageMainText": "Welcome! Working with Weaviate, many of us in the team and the community are exposed to a suite of interesting technologies. They include not only vector databases, but also Docker, Kubernetes, GraphQL, REST and clients in various languages.\nThis means that is a wide set of opportunities for you to learn about and contribute to! If you are not sure where, we suggest finding something that overlaps with your interests\nThese are just some of the ways that you could apply your skills to the project:\nThere are four major GitHub repositories of Weaviate, any of which you can contribute to. This includes:\nIt is important that any contributions such as suggestions or bug reports be made to the correct repository, as they will be otherwise very difficult to understand or integrate.\nYou can also contribute by working on existing issues. Check the issues pages in Weaviate's GitHub repositories like the weaviate core repository. Consider starting with issues tagged 'good first issues'.\nNavigating"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate users now have simple access to data streams from across their entire business to build a real-time, contextual, and trustworthy knowledge base fueling their AI applications. Confluent\u2019s data streaming platform bridges the legacy and modern data stack, providing a continuous supply of AI-ready data."
              }
            ]
          },
          "url": "https://weaviate.io/blog/confluent-and-weaviate",
          "webPageMainText": "Today, we\u2019re excited to announce our new integration with Confluent Cloud. Weaviate users now have simple access to data streams from across their entire business to build a real-time, contextual, and trustworthy knowledge base fueling their AI applications. Confluent\u2019s data streaming platform bridges the legacy and modern data stack, providing a continuous supply of AI-ready data for development of sophisticated customer experiences with constant awareness of what\u2019s happening in the world and their business right now.\n\u201cWith our new integration with Confluent Cloud, Weaviate is taking a giant leap forward in empowering businesses to build AI applications that are not just smart, but also real-time and context-aware. Now, you can seamlessly tap into data streams from every corner of your enterprise, creating a continuously updated knowledge base that lets your AI systems respond to the world as it happens.\u201d\n\u2014 Etienne Dilocker, Chief Technology Officer, Weaviate\nReal-time AI needs real-t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.20 is a new release of Weaviate. This release includes a number of new features. The most important new feature is the ability to store data from up to millions of tenants in a single setup. This means that scaling your business or infrastructure to include data from a large group of users is easier and faster than ever."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/release_1_20",
          "webPageMainText": "\nWeaviate 1.20 is here!\nAs always, a brand-new release means a set of brand-new features. Here are the \u2b50\ufe0fhighlights\u2b50\ufe0f:\nWe hope we've whetted your appetite - so what're you waiting for?! Keep scrolling \u2b07\ufe0f!\nDowngrading from 1.20.x to a 1.19.x or lower is not possible.\nPlease proceed with caution, such as by making a backup of your data & schema, or cluster before upgrading.\nStore data from up to millions of tenants in a single setup.\n\n\nWe\u2019ll keep this brief as Etienne covered this in great detail in this blog post. The key point, though, is that Weaviate now makes it easy to store data from up to millions of tenants in a single setup.\nThis means that scaling your business or infrastructure to include data from a large group of users is easier and faster than ever. We have worked with our community on this feature to ensure that your compliance needs are met as well as performance needs, while keeping the experience a smooth one for everybody. Our multi-tenancy implementation allows for h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate TypeScript client supports TypeScript and JavaScript. Use the TypeScript v3 client for new projects. If your application is browser based, consider using the Type Script client v2. The v3 Client uses ES Modules and CommonJS compatibility. The client is version v3.0.5. See v3 packages for details."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript/typescript-v3#batch-inserts",
          "webPageMainText": "The TypeScript client is version v3.0.5. Use the TypeScript v3 client for new projects.\nThe Weaviate TypeScript client supports TypeScript and JavaScript.\nThe v3 client supports server side development (Node.js hosted). See v3 packages for details. If your application is browser based, consider using the TypeScript client v2.\nIf you are migrating a project from the Weaviate TypeScript client v2 to the v3 client, see the migration page for additional details.\nThis section details how install and configure the v3 TypeScript client.\nThe v3 client package has a new name, weaviate-client. Use npm to install the TypeScript client library package:\nThe v3 client uses ES Modules. Most of the sample code in the documentation also uses the ES Module style.\nIf your code requires CommonJS compatibility, use the CommonJS import style:\nEdit your project's configuration files to make these changes:\nThe v3 client provides helper functions to connect your application to your Weaviate instance.\nEmbedded "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) has an interactive console. Create a user account, then login to manage WCD clusters. Follow these steps to create a new WCD account. After you verify your email, you can log into the WCD Console. For help with Serverless, Enterprise SaaS, and Bring Your Own Cloud accounts, contact Weaviate support."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/create-account",
          "webPageMainText": "Weaviate Cloud (WCD) has an interactive console. Create a user account, then login to manage WCD clusters, run queries, and configure your organization details.\nFollow these steps to create a new WCD account.\nAfter you verify your email, you can log into the WCD Console.\nSandbox instances are free, short term instances that expire after 14 days. If you are using a Sandbox instance to try Weaviate, you don't have to set up billing.\nServerless clusters are persistent instances that are suitable for production, development, and testing. Serverless clusters are paid instances. The cost of each instance depends on the instance type and the support level you choose. You must configure billing before you can create a serverless instance.\nFor help with Serverless, Enterprise SaaS, and Bring Your Own Cloud accounts, contact Weaviate support directly to open a support ticket.\nFor questions and support from the Weaviate community, try these resources:\nTo add a support plan, contact Weaviate sales"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#specify-a-generative-module",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate Cloud (WCD) documentation now has its own section! Check it out here. The content is grouped into categories by goals:Commonly requested resources such as have their own sections, and others can be found in the More Resources section. If you have questions, visit our forum - we can help you with your specific problem, and help make the documentation better."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/introduction",
          "webPageMainText": "Welcome to the documentation for Weaviate, an open source vector database.\nThe content is grouped into categories by goals:\nCommonly requested resources such as\nHave their own sections, and others such as the\nAnd more can be found in the More Resources section.\nThe Weaviate Cloud (WCD) documentation now has its own section! Check it out here.\nIf you are new to Weaviate, we recommend starting with these sections:\nWe suggest you browse through the concepts section if you are interested in how Weaviate works.\nIf you have questions, visit our forum - we can help you with your specific problem, and help make the documentation better. Plus you'll meet our amazing, helpful community of users just like you!\nLike what you see? Consider giving us a \u2b50 on GitHub.\nWhere possible, we show code examples in multiple programming languages using our client libraries. The following example shows you how to get the Weaviate schema using different clients.\nThis page is an introduction to Weaviate. We prese"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A vector is a series of numbers like [1, 0] or [0.513, 0.155, ...] Vectors like these are used to capture meaning. Modern machine learning models such as GPT-x use vectors to represent some \"essence\", or \"meaning\" of objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/theory/hello_weaviate/overview_vectors",
          "webPageMainText": "We've covered that Weaviate is a vector database, and that a vector search is similarity-based. But, what is a vector?\nA vector in this context is just a series of numbers like [1, 0] or [0.513, 0.155, 0.983, ..., 0.001, 0.932]. Vectors like these are used to capture meaning.\nThis might seem like an odd concept. But in fact, you may have already used vectors to capture meaning without realizing it. If you have tried photo editing, or used MS Paint you might have encountered the RGB color system.\nThe RGB system uses groups of three numbers to represent colors. For example:\nIn these examples, each number can be thought of as a dial for how red, green or blue a color is.\nNow, imagine having hundreds, or even thousands, of these dials. That\u2019s how vectors are used to represent meaning. Modern machine learning models such as GPT-x, or those used with Weaviate, use vectors to represent some \"essence\", or \"meaning\" of objects. This can be done for any object type, such as text, code, images, v"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate recently added a new algorithm for hybrid search. A hybrid search is really two searches under-the-same-name. Hybrid search enables a \"best-of-both-worlds\" type capability using both of these search types. Weaviate can perform many different types of searches, including vector and keyword search."
              }
            ]
          },
          "url": "https://weaviate.io/blog/hybrid-search-fusion-algorithms",
          "webPageMainText": "\nAs you might know already, Weaviate can perform many different types of searches, including vector search and keyword search. Vector search is based on similarities of meaning to the input, whereas keyword search is based on how often the input words occur in the results.\nVector and keyword based search each have their strengths and weaknesses that arise from this difference, where vector search is more forgiving semantically and keyword search is more precise. Hybrid search enables a \"best-of-both-worlds\" type capability using both of these search types.\nThat probably sounds simple enough. But do you know how hybrid search combines these results? And that Weaviate recently added a new algorithm for how this is done?\nIn this post, we\u2019ll dive into exactly the world of hybrid search to discuss how it works, how results are produced, the algorithms used, and more. So let\u2019s get into it!\n\nHere is an example of a hybrid search:\nAs mentioned, a hybrid search is really two searches under-the-"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate provides the necessary APIs to iterate through all your data. This is useful when you want to manually copy/migrate your data (and vector embeddings) from one place to another. The new API clients (currently supported by the Python Client v4), encapsulate this functionality as an Iterator."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/read-all-objects#read-all-objects",
          "webPageMainText": "Weaviate provides the necessary APIs to iterate through all your data. This is useful when you want to manually copy/migrate your data (and vector embeddings) from one place to another.\nThis is done with the help of the after operator, also called the cursor API.\nThe new API clients (currently supported by the Python Client v4), encapsulate this functionality as an Iterator.\nThe following code iterates through all objects, providing the properties and id for each object.\nRead through all data including the vectors. (Also applicable where named vectors are used.)\nIterate through all tenants and read data for each.\nFor classes where multi-tenancy is enabled, you need to specify the tenant name when reading or creating objects. See Manage data: multi-tenancy operations for details.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue. Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/filters#where-filter",
          "webPageMainText": "Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion. The operator used for filtering is also called a where filter.\nA filter may consist of one or more conditions, which are combined using the And or Or operators. Each condition consists of a property path, an operator, and a value.\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\nFor example, this filter will only allow objects from the class Article with a wordCount that is GreaterThan than 1000.\nThe where filter is an algebraic object, which takes the following arguments:\nIf the operator is And or Or, the operands are a list of where filters.\nWeaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue.\nThe behavior for the Equal operator on multi-word textual properties in where filters depends on the tokenization of the property.\nSee the Schema p"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#gcs-google-cloud-storage",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#autoschema",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/objects/put/objects/%7BclassName%7D/%7Bid%7D",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/setup_weaviate",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.16 brings a set of great features, performance and UX improvements, and fixes. The ability to seamlessly combine an inverted index with a vector index is part of what makes Weaviate so powerful. The possibility to query the null state has been added."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/older-releases/release_1_16",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.16, which brings a set of great features, performance and UX improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\n\nOne of the core functionalities of databases are the index structures that allow us to find data objects quickly. The ability to seamlessly combine an inverted index with a vector index is part of what makes Weaviate so powerful. An inverted index maps the property value to the objects that it appears in. This is important when filtering through your database to find specific data objects.\nWhen dealing with large datasets, it is very common to have objects with missing or null properties. Naturally, you might want to find the objects with missing properties and do a bit of cleaning up. With Weaviate 1.16 we introduced the possibility to query the null state. This applies to both scenarios where a pro"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate offers a \"batch import\" process to maximize the import speed. To create a Weaviate object, you must:Optionally, you can manually specify:We'll cover these in more detail later on. In the figure, a request is made to create an object based on the provided data. If the vector is not provided and a vectorizer is specified, Weaviates will send a request to the vectorizer module for a vector em."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports/import",
          "webPageMainText": "So far, you've learned that data in Weaviate is represented by objects, which belong to a class, and have a set of properties. In the previous section on the schema, you learned how to create a framework for this structure.\nIn this section, you will learn how to import data into Weaviate, including our recommended best practices, and some key considerations. Once you're done with this section, you will be ready to import a real dataset into Weaviate by putting together what we've learned about the schema and imports.\nTo create a Weaviate object, you must:\nOptionally, you can manually specify:\nWe'll cover these in more detail later on.\nWeaviate offers a \"batch import\" process to maximize the import speed. Take a look at this diagram that shows the object creation process:\nIn the figure, a request is made to create an object based on the provided data.\nIf the vector is not provided and a vectorizer is specified, Weaviate (core) will send a request to the vectorizer module for a vector em"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The gRPC API is faster than the REST API. Use it to improve import speeds. Batch imports are an efficient way to add multiple data objects and cross-references. To create a bulk import job, follow these steps:The following example adds objects to the MyCollection collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/import#stream-data-from-large-files",
          "webPageMainText": "Batch imports are an efficient way to add multiple data objects and cross-references.\nTo create a bulk import job, follow these steps:\nThe following example adds objects to the MyCollection collection.\nThe gRPC API is faster than the REST API. Use the gRPC API to improve import speeds.\nThe Python client uses gRPC by default. See the client page for additional batch import configuration options.\nThe TypeScript client v3 uses gRPC by default.\nTo use the gRPC API with the Java client, add the setGRPCHost field to your client connection code. Update setGRPCSecured if you use an encrypted connection.\nTo use the gRPC API with the Go client, add the GrpcConfig field to your client connection code. Update Secured if you use an encrypted connection.\nTo use the gRPC API with the Spark connector, add the grpc:host field to your client connection code. Update grpc:secured if you use an encrypted connection.\nWeaviate generates an UUID for each object. Object IDs must be unique. If you set object ID"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#restore-backup",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate uses gzip compression by default. See the Backups page for a general introduction, configuration, and tech background of Backups. Once the modules are enabled and the configuration is provided, you can start abackup on any running instance with a single HTTP request."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/backups",
          "webPageMainText": "See the Backups page for a general introduction, configuration, and tech background of Backups.\nOnce the modules are enabled and the configuration is provided, you can start a\nbackup on any running instance with a single HTTP request.\nThe request takes a json object with the following properties:\nNote: You cannot set include and exclude at the same time. Set none or exactly one of those.\nNote: Weaviate uses gzip compression by default.\nFor client code examples, see the How-to: Configure / Backups page.\nWhile you are waiting for a backup to complete, Weaviate stays fully usable.\nAll client implementations have a \"wait for completion\" option which will poll the backup status in the background and only return once the backup has completed (successfully or unsuccessfully).\nIf you set the \"wait for completion\" option to false, you can also check the status yourself using the Backup Creation Status API.\nThe response contains a \"status\" field. If the status is SUCCESS, the\nbackup is complete."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has a modularized structure. Functionality such as vectorization or backups is handled by optional modules. Weaviate does not know how to vectorize an object, i.e. how to calculate the vectors given an object. You can choose and attach a vectorizer module that best fits your use case."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/modules",
          "webPageMainText": "Weaviate has a modularized structure. Functionality such as vectorization or backups is handled by optional modules.\nThe core of Weaviate, without any modules attached, is a pure vector-native database.\n\nData is stored in Weaviate as the combination of an object and its vector, and these vectors are searchable by the provided vector index algorithm. Without any vectorizer modules attached, Weaviate does not know how to vectorize an object, i.e. how to calculate the vectors given an object.\nDepending on the type of data you want to store and search (text, images, etc.), and depending on the use case (like search, question answering, etc., depending on language, classification, ML model, training set, etc.), you can choose and attach a vectorizer module that best fits your use case. Or, you can \"bring your own\" vectors to Weaviate.\nThis page explains what modules are, and what purpose they serve in Weaviate.\nThis graphic displays the available modules for the latest Weaviate version (v||"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We are going to use a movie dataset sourced from TMDB. The dataset can be found in this GitHub repository. It contains bibliographic information on ~700 movies released between 1990 and 2024. You will need an OpenAI API key to follow along. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_collections/preparation",
          "webPageMainText": "In this section you are going to populate your Weaviate instance with a movie dataset, using the OpenAI API to embed the text data.\nMake sure to have your Weaviate instance set up. You should have created an instance and be able to connect to it.\nYou will need an OpenAI API key to follow along. If you don't have one, go to the OpenAI website and sign up for an account and create an API key.\nWe are going to use a movie dataset sourced from TMDB. The dataset can be found in this GitHub repository, and it contains bibliographic information on ~700 movies released between 1990 and 2024.\nNext, you will create a corresponding object collection and import the data.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is building an open-source brand. To create a meaningful brand, we need to know why we're solving that problem, and who we are. Businesses that don't know why they exist and what they are trying to achieve struggle to find product-market fit."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/building-an-open-source-brand",
          "webPageMainText": "\nHere at Weaviate, we aren't just building open-source products, we're building an open-source brand.\nTo create a meaningful product, we need to both solve a problem and know the people we're building it for. To create a meaningful brand, we need to know why we're solving that problem, and who we are.\nCreating that brand in an open-source spirit does not call for the traditional brand-building techniques used to shape a message. Rather, our goal is to transparently share our experiences as team members connect with each other and our users, to help them solve their problems.\nFor the last eight years, I've helped tech companies build their brands and visual identities. I've learned an important lesson: Businesses that don't know why they exist and what they are trying to achieve struggle to find product-market fit.\nThey have no strategy or vision, creating confusion for the team and, inevitably, their customers.\nThey don't know who they are talking to and without a clear value propositi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Binary quantization (BQ) is a vector compression technique that can reduce the size of a vector. BQ is available for the flat index type from v1.23 onwards and for the hnsw index  type fromv1.24. To use BQ, enable it as shown below and add data to the collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/bq-compression",
          "webPageMainText": "BQ is available for the flat index type from v1.23 onwards and for the hnsw index  type from v1.24.\nBinary quantization (BQ) is a vector compression technique that can reduce the size of a vector.\nTo use BQ, enable it as shown below and add data to the collection.\nEach collection can be configured to use BQ compression. BQ must be enabled at collection creation time, before data is added to it.\nThis can be done by setting the vector_index_config of the collection to enable BQ compression.\nThe following parameters are available for BQ compression, under vectorIndexConfig:\nFor example:\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Authentication is one of those topics that we get quite a few questions about. It's a big, complex topic, and even within Weaviate, there are many options available. We've recently introduced an API key-based authentication method, which we think might be a good balance of security and usability."
              }
            ]
          },
          "url": "https://weaviate.io/blog/authentication-in-weaviate",
          "webPageMainText": "\nAuthentication is one of those topics that we get quite a few questions about. And we can see why. It's a big, complex topic, and even within Weaviate, there are many options available which can make it seem quite confusing.\nThe core concept of authentication is relatively simple. When a client (e.g. a Weaviate client) sends a request to a server (e.g. a Weaviate database), it includes a \"secret\" that provides some assurances to Weaviate as to who that request is coming from, so that it can operate on that information.\n\n\nIn other words, the server can provide as much access as the particular user is allowed.\nBut balancing security with usability can be a tricky line to draw, as everybody has different needs and often use different systems.\nSo, we thought that this might be a good time to provide an overview of all things authentication in Weaviate. Also, we've recently introduced an API key-based authentication method, which we think might be a good balance of security and usability f"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page illustrates various use cases for vector databases by way of open-source demo projects. If you would like to contribute your own project to this page, create an issue on GitHub. A vector databases enables fast, efficient similarity searches on and across any modalities, such as text or images, as well as their combinations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/example-use-cases",
          "webPageMainText": "This page illustrates various use cases for vector databases by way of open-source demo projects. You can fork and modify any of them.\nIf you would like to contribute your own project to this page, create an issue on GitHub.\nA vector databases enables fast, efficient similarity searches on and across any modalities, such as text or images, as well as their combinations. Vector database' similarity search capabilities can be used for other complex use cases, such as recommendation systems in classical machine learning applications.\nVector databases and LLMs go together like cookies and milk!\nVector databases help to address some of large language models (LLMs) limitations, such as hallucinations, by helping to retrieve the relevant information to provide to the LLM as a part of its input.\nLearn more in our LLMs and Search blog post.\nWeaviate can leverage its vectorization capabilities to enable automatic, real-time classification of unseen, new concepts based on its semantic understandi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is available as a hosted service, Weaviate Cloud (WCD), or as a self managed instance. If you manage your own instance, you can host it locally or with a cloud provider. Self-managed instances use the same Weaviates core database as WCD."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation",
          "webPageMainText": "Weaviate is available as a hosted service, Weaviate Cloud (WCD), or as a self managed instance. If you manage your own instance, you can host it locally or with a cloud provider. Self-managed instances use the same Weaviate core database as WCD.\nTo install and configure Weaviate, see the following:\nDocker Compose and Kubernetes use yaml files to configure Weaviate instances. Docker uses the docker-compose.yml file. Kubernetes relies on Helm charts and the values.yaml file. The Weaviate documentation also calls these files configuration yaml files.\nIf you are self-hosting, consider experimenting on a small scale with Docker and then transferring your configuration to Kubernetes Helm charts when you are more familiar with Weaviate.\nDISCLAIMER: Release candidate images and other unreleased software are not supported.\nUnreleased software and images may contain bugs. APIs may change. Features under development may be withdrawn or modified. Do not use unreleased software in production.\nTo ru"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "I lead Weaviate\u2019s Solution Engineering team. Right now, we\u2019re only four people. We combine a broad knowledge of different types of software, different domains, and applications. We\u2019're also responsible for running Weaviates in the cloud for customers who want to have a managed service."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/creating-a-remote-first-solution-engineering-team",
          "webPageMainText": "\nI lead Weaviate\u2019s Solution Engineering team. Right now, we\u2019re only four people. Still, we combine a broad knowledge of different types of software, different domains, and applications, and we use that knowledge to help customers get the most out of Weaviate. We\u2019re also responsible for running Weaviate in the cloud for customers who would like to have a managed service.\nIn a way, we\u2019re the storefront. At this point, most customers want to use vector search for something but don\u2019t know how to get there. Others are fascinated by vector search but don\u2019t yet know how they\u2019d use it; they\u2019ll ask us to suggest use cases. So, we begin with discussions about what kind of data they have, what they want to build, and how Weaviate can help them. Next, we build a proof-of-concept or create a small version to demo and establish a business value. The final step is getting something into production and customer-facing.\nAlong the way, we often share customer feedback with the Weaviate core team on feat"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Add reranker-voyageai to the ENABLE_MODULES environment variable. This module is enabled by default in WCD. You can also specify options such as the model to use. This example configures the Document collection to use the re Rank-lite-1 model."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/reranker-voyageai",
          "webPageMainText": "This module is enabled by default in WCD.\nAdd reranker-voyageai to the ENABLE_MODULES environment variable.\nBelow is an example Docker Compose file, which will spin up Weaviate with the reranker-voyageai module (as well as text2vec-voyageai).\nThe reranker-voyageai module can be configured for any collection in the schema. You can also specify options such as the model to use.\nThis example configures the Document collection to use the reranker-voyageai module, with the rerank-lite-1 model, and to return the documents in the response.\nIf there is only one reranker module enabled, you don't need to do anything. The reranker module will be used by default.\nWhere multiple reranker modules are enabled, you must specify the reranker module to be used for each collection. You can do this by adding the desired reranker in the moduleConfig section of the schema, even without any further settings.\nThe reranker-voyageai module supports the following models:\nYou can supply parameters at query time "
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/classification",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Schema is the blueprint that defines its data structure for each class of objects. A class is a collection of objects of the same type. The only required parameter is class, as the rest can be inferred by Weaviate. Each class definition will include one or more properties, which must have a data type."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports/schema",
          "webPageMainText": "A schema in Weaviate is the blueprint that defines its data structure for each class of objects. A class is a collection of objects of the same type.\nIn this section, you will learn how to define a schema and gain insight into some key considerations while doing so.\nAs you learned earlier, a schema definition includes a great deal of information. Let's cover a few of those properties in this section, starting with:\nYou can define for each class and property a name and description.\nFor classes, these are called:\nFor properties, these are called:\nIn defining a class, the only required parameter is class, as the rest can be inferred by Weaviate. However, it is recommended to include a description for each class and property, as this will help you and others understand the data structure.\nTo define a class, you can use this syntax.\nEach class definition will include one or more properties, which must have a data type. If you do not specify a data type, Weaviate will automatically assign on"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " vector embeddings power modern search and Retrieval-Augmented Generation (RAG) applications. Embeddings capture the semantic meaning of data objects and represent them in an array of numbers. Weaviate has many integrations with various model providers and their wide variety of embedding models."
              }
            ]
          },
          "url": "https://weaviate.io/blog/how-to-choose-an-embedding-model",
          "webPageMainText": "\nVector embeddings power modern search and Retrieval-Augmented Generation (RAG) applications. Embeddings capture the semantic meaning of data objects (e.g., text) and represent them in an array of numbers. In today\u2019s Generative AI applications, these vector embeddings are typically generated with so-called embedding models.\n\nAs a vector database that stores vector embeddings and retrieves data objects based on vector search, Weaviate has many integrations with various model providers and their wide variety of embedding models.\nBut how do you approach selecting the right embedding model for your search or RAG application? As you will learn in this article, it depends on your use case and specific requirements.\nWould a general-purpose model be sufficient for what you are trying to achieve, or do you have specific needs, such as modality (e.g., text only or multimodal), subject domain (e.g., coding, law, medical, multilingual, etc.), and deployment mode? In most cases, starting with a gen"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The results shown in Healthsearch should not be taken as health advice. The results are based on the semantic similarity between the query and user-written reviews. Try out the Healthsearch tool to see what other people have found to help them sleep better. For confidential support call the Samaritans in the UK on 08457 90 90 90, visit a local Samaritans branch or click here for details."
              }
            ]
          },
          "url": "https://weaviate.io/blog/healthsearch-demo",
          "webPageMainText": "\nIsn\u2019t it annoying when you just want to find a remedy for your headache and instead find out that you have a horrible disease?\nYou google your symptoms and after digging into the first few search results, there is no doubt, you're probably going to die from a terrible disease in just a matter of hours. Spoiler alert, it's almost never the case. The phenomenon is called Dr. Google, and to save you the stress, we want to help you explore what others have found that may have helped them for their conditions.\nTry out the live demo here\u2728\nHealthsearch is a technical demonstration and acts as a proof of concept.\nThe results shown in Healthsearch should not be taken as health advice or is it the intention of this demo. The search results are based on the semantic similarity between the query and user-written reviews.\nImagine you could type in I need to sleep better and instantly get a list of related supplements where other users have written reviews claiming it has helped them sleep better. "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open source vector database that's purpose-built for AI. Tight integrations with AWS infrastructure and services like SageMaker and Bedrock help developers build and deploy production-ready generative AI applications with less hassle. Weaviate can meet you where you are on your journey to the cloud. Enterprises can migrate data to AWS and power real-time analytics and apps on a unifieddata platform."
              }
            ]
          },
          "url": "https://weaviate.io/partners/aws",
          "webPageMainText": "Weaviate on AWS\nPowerful AI-native vector database. Simple, secure deployment on AWS.\nWeaviate is an open source vector database that's purpose-built for AI. Tight integrations with AWS infrastructure and services like SageMaker and Bedrock help developers build and deploy production-ready generative AI applications with less hassle.\nSub-second semantic search performance and ability to scale to handle billions of vectors and millions of tenants.\nNatively integrate with AWS SageMaker, AWS Bedrock, and model providers like Cohere, OpenAI, Hugging Face, and more. Or, use custom models.\nWeaviate is available in AWS marketplace and allows one-click container based scalable deployment inside the customers tenant.\nWhether you are a traditional enterprise with an on-prem data footprint or a digital native, Weaviate can meet you where you are on your journey to the cloud. Enterprises can migrate data to AWS with Weaviate and power real-time analytics and apps on a unifieddata platform. This su"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn how to work with any text data using Weaviate and a movie dataset. You will learn how to search through that data using semantic, keyword and hybrid searches, as well as filters. Use large language models to augment and transform retrieved data. Set up a Weaviates instance and connect to it. Creating a collection and import data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data",
          "webPageMainText": "In this project-based course, you will learn how to work with any text data using Weaviate and a movie dataset.\nYou will get hands-on experience on how to store and index text data by meaning, using Weaviate's vectorization capabilities. You will learn how to search through that data using semantic, keyword and hybrid searches, as well as filters. You will also learn how to use Weaviate's retrieval augmented generation (RAG) capabilities to generate outputs based on the retrieved objects.\nSet up a Weaviate instance and connect to it.\nCreate a collection and import data, and have Weaviate create vectors for you.\nLearn how to use search functions in Weaviate.\nUse large language models to augment and transform retrieved data.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative Mistral is a module for Weaviate Cloud. It performs retrieval augmented generation, or RAG, based on the data stored in your Weaviates instance. To use generative-mistral, you must enable it in your Docker Compose file ( docker-compose.yml)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/generative-mistral",
          "webPageMainText": "generative-mistral performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance.\nThe module works in two steps:\nYou can use the Generative Mistral module with any other upstream modules. For example, you could use text2vec-cohere, text2vec-huggingface or text2vec-openai to vectorize and query your data, but then rely on the generative-mistral module to generate a response.\nThe generative module can perform RAG for:\nYou need to input both a query and a prompt (for individual responses) or a task (for all responses).\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use generative-mistral, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables generative-mistral and sets the Mistral authentication credentials.\nYou can configure how the module will behave i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_searches",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You accept and agree to the following terms and conditions for Your present and future Contributions submitted to Weaviate. You reserve all right, title, and interest in and to Your Contributions. The license is for your protection as a Contributor as well as the protection of Weaviates. It does not change your rights to use your own Contributions for any other purpose."
              }
            ]
          },
          "url": "https://weaviate.io/service/contributor-license-agreement",
          "webPageMainText": "In order to clarify the intellectual property license granted with Contributions from any person or entity,\nWeaviate B.V. (\"Weaviate\") must have a Contributor License Agreement (\"CLA\") on file that has been signed by each\nContributor, indicating agreement to the license terms below. This license is for your protection as a Contributor as\nwell as the protection of Weaviate; it does not change your rights to use your own Contributions for any other purpose.\nYou accept and agree to the following terms and conditions for Your present and future Contributions submitted to Weaviate.\nExcept for the license granted herein to Weaviate and recipients of software distributed by Weaviate, You reserve all right,\ntitle, and interest in and to Your Contributions.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#set-vector-index-type",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This vector database benchmark is designed to measure and illustrate Weaviate's Approximate Nearest Neighbor (ANN) performance for a range of real-life use cases. The benchmark is open source, so you can reproduce the results yourself. For good starting point values and performance tuning advice, see HNSW Configuration Tips."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/benchmarks/ann#sift1m-1m-128d-vectors-l2-distance",
          "webPageMainText": "This vector database benchmark is designed to measure and illustrate Weaviate's Approximate Nearest Neighbor (ANN) performance for a range of real-life use cases.\nThis is not a comparative benchmark that runs Weaviate against competing vector database solutions. \nTo discuss trade-offs with other solutions, contact sales.\nTo make the most of this vector database benchmark, you can look at it from different perspectives:\nFor each benchmark test, we set these HNSW parameters:\nFor good starting point values and performance tuning advice, see HNSW Configuration Tips.\nFor each set of parameters, we've run 10,000 requests, and we measured the following metrics:\nBy request, we mean:\nAn unfiltered vector search across the entire dataset for the given test. All\nlatency and throughput results represent the end-to-end time that your\nusers would also experience. In particular, these means:\nThis benchmark is open source, so you can reproduce the results yourself.\nThis section contains datasets model"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default values in values.yaml may be sufficient. Make sure to set your desired Weaviate version. The yaml file is extensively documented to help you align the configuration with your setup. The configuration file is setup for:See the resource requ requeur for more information."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/kubernetes",
          "webPageMainText": "Make sure to set your desired Weaviate version.\nThis can be done through either explicitly setting it as part of the values.yaml or through overwriting the default as outlined in the deployment step below.\nIf you are looking for a complete end-to-end tutorial on the topic, see the Weaviate Academy course, Weaviate on Kubernetes. The course is an end-to-end tutorial on how to use MiniKube to deploy Weaviate on Kubernetes.\nTo obtain and install the Weaviate chart on your Kubernetes cluster, take the following steps:\nAdd the Weaviate helm repo that contains the Weaviate helm chart\nGet the default values.yaml configuration file from the Weaviate helm chart:\nThe default values in values.yaml may be sufficient. However, we recommend reviewing:\nIn the values.yaml\nfile you can tweak the configuration to align it with your\nsetup. The yaml file is extensively documented to help you align the\nconfiguration with your setup.\nOut of the box, the configuration file is setup for:\nSee the resource requ"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#asynchronous-status-checking",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The multi2vec-bind module enables Weaviate to use the ImageBind model to vectorize data at import time. To use the module, you must enable it in your Docker Compose file (e.g. docker-compose.yml) The module requires a significant amount of memory to run."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind#class-level",
          "webPageMainText": "The multi2vec-bind module enables Weaviate to use the ImageBind model to vectorize data at import time.\nKey notes:\nmulti2vec-bind allows Weaviate to generate vectors data containing any number of the following modalities:\nThis module is not available on Weaviate Cloud.\nThe multi2vec-bind module requires a significant amount of memory to run. You may need to increase the memory limit for the multi2vec-bind container to 12 GB or more, such as through Docker Desktop's settings. You can additionally set a limit on your Docker Compose file as shown below, however your Docker Desktop memory limit must be equal to or higher than the limit set in the Docker Compose file.\nTo use multi2vec-bind, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nThis module will benefit greatly from GPU usage. Make sure to enable CUDA if you h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has recently unveiled a new module which allows users to easily integrate models from Hugging Face to vectorize their data and incoming queries. At the time of this writing, there are over 700 models that can be easily plugged into Weaviate. We will describe factors that differentiate these models and give you tools to choose the perfect model for your use case."
              }
            ]
          },
          "url": "https://weaviate.io/blog/how-to-choose-a-sentence-transformer-from-hugging-face",
          "webPageMainText": "\nWeaviate has recently unveiled a new module which allows users to easily integrate models from Hugging Face to vectorize their data and incoming queries. At the time of this writing, there are over 700 models that can be easily plugged into Weaviate.\nYou may ask: Why are there so many models and how do they differ?\nAnd more importantly: How to choose a Sentence Transformer for Semantic Search?\nThere are too many models to summarize in one flowchart. So instead, we will describe factors that differentiate these models and give you tools to choose the perfect model for your use case.\nNot too long ago, Deep Learning models were typically differentiated based on architectural decisions. For example, ResNet differs from DenseNet based on how frequently they implement skip connections between layers. Fast forward to today, the Deep Learning community has fallen in love with attention layers and the transformer network architecture. Transformers mostly differ between encoder, decoder, and en"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative-cohere performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance. You can use the Generative Cohere module with non-Cohere upstream modules. You need to input both a query and a prompt (for individual responses) or a task (for all responses)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/generative-cohere",
          "webPageMainText": "generative-cohere performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance.\nThe module works in two steps:\nYou can use the Generative Cohere module with non-Cohere upstream modules. For example, you could use text2vec-openai or text2vec-huggingface to vectorize and query your data, but then rely on the generative-cohere module to generate a response.\nThe generative module can provide results for:\nYou need to input both a query and a prompt (for individual responses) or a task (for all responses).\ngenerative-cohere requires an Cohere API key to perform the generation task.\nYou can provide your Cohere API key in two ways:\nDuring the configuration of your Docker instance, by adding COHERE_APIKEY under environment to your Docker Compose file, like this:\nAt run-time (recommended), by providing \"X-Cohere-Api-Key\" to the Weaviate client, like this:\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#properties",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate can be scaled horizontally by being run on a set of multiple nodes in a cluster. There are (at least) three distinct motivations to scale out horizontally which all will lead to different setups. See Sharding vs Replication below for trade-offs involved when running multiple shards."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/cluster",
          "webPageMainText": "Weaviate can be scaled horizontally by being run on a set of multiple nodes in a cluster. This section lays out various ways in which Weaviate can be scaled, as well as factors to consider while scaling, and Weaviate's architecture in relation to horizontal scaling.\nGenerally there are (at least) three distinct motivations to scale out horizontally which all will lead to different setups.\nDue to the memory footprint of an HNSW graph it may be desirable to spread a dataset across multiple servers (\"nodes\"). In such a setup, a single class index is composed of multiple shards and shards are spread across servers.\nWeaviate does the required orchestration at import and query time fully automatically. The only adjustment required is to specify the desired shard count. See Sharding vs Replication below for trade-offs involved when running multiple shards.\nSolution: Sharding across multiple nodes in a cluster\nThe ability to shard across a cluster was added in Weaviate v1.8.0.\nWhen you receive"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model. It encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware. The ONNX-enabled images can use ONNx Runtime for faster inference processing on CPUs."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-transformers#option-3-custom-build-with-a-private-or-local-model",
          "webPageMainText": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model.\ntext2vec-transformers encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nTransformer model inference speeds are usually about ten times faster with GPUs. If you have a GPU, use one of the GPU enabled models.\nIf you use text2vec-transformers without GPU acceleration, imports or nearText queries may become bottlenecks. The ONNX-enabled images can use ONNX Runtime for faster inference processing on CPUs. Look for the -onnx suffix in the image name.\nAlternatively, consider one of the following options:\nThis module is not available on Weaviate Cloud.\nTo use text2vec-transformers, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to genera"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default docker image doesn't need any configuration. To customize your instance, edit the configuration settings in the docker-compose.yml file. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally. You can use environment variables to control your Weaviates setup, authentication and authorization."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/docker-compose#multi-node-setup",
          "webPageMainText": "Weaviate supports deployment with Docker. If you use the default values, you don't need a docker-compose.yml file to run the image. To customize your instance, edit the configuration settings in the docker-compose.yml file.\nThe default docker image doesn't need any configuration. To run a basic Weaviate instance, run this command from a terminal:\nThe command sets the following default values:\nWe prepared a starter Docker Compose file, which will let you:\nSave the text below as docker-compose.yml:\nEdit the docker-compose.yml file to add your local configuration. To start your Weaviate instance, run this command in your shell:\nThe Configurator can generate a docker-compose.yml file for you. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally (i.e. text2vec-transformers, or multi2vec-clip)\nYou can use environment variables to control your Weaviate setup, authentication and authorization, module settings, and data storage settings.\nA comprehensi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In our previous post, we explained how to compress vectors in memory. We introduced HNSW+PQ and explained the most popular encoding technique: KMeans. The Tile encoder is a distribution-based encoder. It doesn\u2019t need to be fit to the data since it leverages the underlying distribution of the data."
              }
            ]
          },
          "url": "https://weaviate.io/blog/ann-algorithms-tiles-enocoder",
          "webPageMainText": "\nIn our previous post, we explained how to compress vectors in memory. This was an important first step since we could still have a coarse representation of the vectors to guide our search through queries with a very low memory footprint. We introduced HNSW+PQ and explained the most popular encoding technique: KMeans, which can be used to find a compressed representation of vectors. While KMeans gives very good results, there are a couple of drawbacks. Firstly, it is expensive to fit to data. Secondly, when compressing vectors, it needs to calculate distances to all centroids for each segment. This results in long encoding and indexing times.\nIn this blog post, we present an alternative to KMeans, the Tile encoder, which is a distribution-based encoder. The Tile encoder works very similarly to KMeans but it doesn\u2019t need to be fit to the data since it leverages the fact that we know the underlying distribution of the data beforehand.\n\nKMeans produces a tiling over the full range of valu"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The meta endpoint accepts a GET request and returns the following fields. The following command is used to retrieve the data from the meta endpoint. The command:returns:\u0153\u02da\u02da\u2019\u02da \u2018\u0153\u2019\u2019 \u2018\u02da\u00a0\u2018\u02d9 \u2019\u02d9\u201d\u2019\u00a0\u2009\u2019 \u00a0\u201c\u2018\u2019.\u201d \u2018\u2009.\u2019, \u2018%s\u2019%s%s%.\u2019%, \u2018#\u2019 %s%\u00a0\u2019#\u201d, \u201c%s+\u2019%.\u201d,. \u2019%\u2019,. \ufffd"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/meta",
          "webPageMainText": "The meta endpoint accepts a GET request:\nAnd it returns the following fields:\nThe following command:\nreturns:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#4-load-the-rest-of-your-data",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Multi-tenancy provides data isolation. Each tenant is stored on a separate shard. Data stored in one tenant is not visible to another tenant. Weaviate returns an error if you try to insert an object into a non-existent tenant. The auto-tenant feature is available from v1.25.0 for batch imports."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/multi-tenancy#automatically-add-new-tenants",
          "webPageMainText": "Multi-tenancy provides data isolation. Each tenant is stored on a separate shard. Data stored in one tenant is not visible to another tenant. If your application serves many different users, multi-tenancy keeps their data private and makes database operations more efficient.\nMulti-tenancy is disabled by default. To enable multi-tenancy, set multiTenancyConfigin the collection definition:\nBy default, Weaviate returns an error if you try to insert an object into a non-existent tenant. To change this behavior so Weaviate creates a new tenant, set autoTenantCreation to true in the collection definition.\nThe auto-tenant feature is available from v1.25.0 for batch imports, and from v1.25.2 for single object insertions as well.\nSet autoTenantCreation when you create the collection, or reconfigure the collection to update the setting as needed.\nAutomatic tenant creation is useful when you import a large number of objects. Be cautious if your data is likely to have small inconsistencies or typo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Anthropic was able to solve the \"lost in the middle\" problem \"by adding the sentence \u201cHere is the most relevant sentence in the context:\u201d to the start of Claude\u2019s response\" This was enough to raise Claude 2.1's score from 27% to 98% on the original evaluation."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper8",
          "webPageMainText": "\nAnthropic was able to solve the \"lost in the middle\" problem \"by adding the sentence \u201cHere is the most relevant sentence in the context:\u201d to the start of Claude\u2019s response. This was enough to raise Claude 2.1\u2019s score from 27% to 98% on the original evaluation.\"\nDoes it just take a little bit of prompt engineering to solve low accuracy when needing to retrieve from the middle of a context window??\n\ud83d\udd17 Article Link\nCheck out the Quickstart tutorial, and begin building amazing apps with the free trial of Weaviate Cloud (WCD).\nGitHub\nForum\nSlack\nX (Twitter)\nSign up for our bi-weekly newsletter to stay updated!\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This is the privacy policy of Weaviate B.V. (\u201cWeaviate\u201d, \u2018we\u2019, and \u201cour\u201d). Weaviates is a private limited company, established at the Prinsengracht 769A in Amsterdam, the Netherlands. Weaviated is responsible for the collection and use of your personal data."
              }
            ]
          },
          "url": "https://weaviate.io/privacy",
          "webPageMainText": "This is the privacy policy of Weaviate B.V. (\u201cWeaviate\u201d, \u201cwe\u201d, and \u201cour\u201d). Weaviate is a private limited company, established at the Prinsengracht 769A in Amsterdam, the Netherlands. Weaviate is responsible for the collection and use of your personal data as described in this privacy policy.\u00a0\nAt Weaviate we respect your privacy and seek to protect the personal data we collect and use in accordance with applicable personal data protection legislation. Therefore, this privacy policy serves to clarify what personal data we collect, use, share, store and otherwise process in various situations, and how, why and on what legal basis we do so.\u00a0\nWhat is relevant to you depends on your relationship with us. Therefore, this privacy policy is structured in a layered way to allow you to read only what is relevant to you. Therefore, please refer to:\nSection 2, if you make use of our Weaviate products and services;\nSection 3, if you visit our websites or complete forms on our websites;\nSection 4, if"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Modular RAG is comprised of various functional modules. Different RAG patterns are composed of different modules. The modular RAG paradigm is slowly becoming the norm in the RAG domain due to its versatility and flexibility, allowing: \u00a0flexibility, versatility, and versatility."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper22",
          "webPageMainText": "\nA recent survey on Retrieval-Augmented Generation (RAG) mentions an evolving paradigm:\nModular RAG. \nModular RAG is comprised of various functional modules. Thus, modular RAG is not standalone. Instead, different RAG patterns are composed of different modules.   \nFor example, the following animation shows:\n\ud83e\udd5a The original naive RAG paradigm consists of the \u201cRetrieval\u201d, \"Augmentation,\" and \"Generation\" modules.\n\ud83d\udc23 After naive RAG has shown some limitations, advanced RAG has emerged as a new paradigm. A typical pattern of Advanced RAG builds upon the foundation of Naive RAG by adding \u201cRewrite\u201d and \u201cRerank\u201d modules. \n\ud83d\udc13 Different RAG patterns, such as DSP, can be composed of entirely different modules.  \nThe modular RAG paradigm is slowly becoming the norm in the RAG domain due to its versatility and flexibility, allowing: \nI definitely recommend checking out the full survey if you want to catch up on recent advancements in the RAG domain.\n\ud83d\udd17 arXiv Link\n\ud83d\udcdc Download paper\nCheck out the Quickst"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "It is also possible to add a cross-reference property to an existing collection definition. This requires adding reference properties in both directions, and adding two cross-references per object pair. Use cross- references to establish directional relationships between collections. Use the reference property in the collection definition before adding cross-References to it."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/cross-references#update-a-cross-reference",
          "webPageMainText": "Use cross-references to establish directional relationships between collections.\nNotes:\nInclude the reference property in the collection definition before adding cross-references to it.\nIt is also possible to add a cross-reference property to an existing collection definition.\nSpecify a cross-reference when creating an object.\nSpecify the required id and properties for the source and the target.\nThis requires adding reference properties in both directions, and adding two cross-references per object pair (from A -> to B and from B -> to A).\nCreate the JeopardyCategory collection:\nCreate the JeopardyQuestion collection including the reference property to JeopardyCategory:\nModify JeopardyCategory to add the reference to JeopardyQuestion:\nAnd add the cross-references:\nWeaviate allows creation of multiple cross-references from one source object.\nCross-references can be read as part of the object.\nDeleting a cross-reference with the same parameters used to define the cross-reference.\nWhat ha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page has links to the developer release notes for the Weaviate core database and the client libraries. For descriptive notes on recent major releases, follow the links in the table of contents at the left of this page. For older releases, see the blog pages at Weaviates.io."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes#weaviate-core",
          "webPageMainText": "This page has links to the developer release notes for the Weaviate core database and the client libraries. To see release notes for a particular version, click on the version number.\nFor descriptive notes on recent major releases, follow the links in the table of contents at the left of this page. For descriptive notes on older releases, see the blog pages at Weaviate.io.\nFor links to the Weaviate Core releases, expand this section.\nFor links to the Python Client releases, expand this section.\nThe JavaScript client is no longer maintained. The TypeScript client accepts code written in JavaScript and TypeScript. Migrate your JavaScript client code to the TypeScript client.\nFor links to the TypeScript Client releases, expand this section.\nFor links to the JavaScript Client releases, expand this section.\nFor links to the Go Client releases, expand this section.\nFor links to the Java Client releases, expand this section.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Paid support is available for Serverless Clusters, Weaviate Enterprise SaaS, and Bring your Own Cloud clusters. Sandboxes and self-hosted clusters are not eligible for paid support. Professional support is email based and is available 24 hours a day, seven days a week."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/support-levels#standard-support",
          "webPageMainText": "Weaviate Cloud (WCD) offers multiple levels of support. You have the flexibility to choose the level of support that you need.\nSandboxes and self-hosted clusters are not eligible for paid support.\nPaid support is available for Serverless Clusters, Weaviate Enterprise SaaS, and Bring your Own Cloud clusters.\nFor Serverless instances, the default support level is Standard support. You are automatically enrolled for Standard support when you create a Serverless cluster. To switch to another level, contact our sales team\nFor Weaviate Enterprise SaaS and Bring your Own Cloud clusters, contact our sales team to discuss which level of support is right for you.\nStandard support is email based and is available during business hours.\nMonitoring. The WCD team monitors your cluster.\nSeverity determines incident response time:\nProfessional support is email based and is available 24 hours a day, seven days a week.\nSeverity 1 and Severity 2 incident response includes a  follow up phone call.\nMonitori"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This course will introduce you to tokenization, and how it relates to Weaviate. This course is self-contained. We recommend that you go through one of the 101-level courses, such as that for working with text, your own vectors, or multimodal data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/tokenization",
          "webPageMainText": "This course is self-contained. However, we recommend that you go through one of the 101-level courses, such as that for working with text, your own vectors, or multimodal data.\nThis course will introduce you to tokenization, and how it relates to Weaviate. Specifically, it will discuss what it is, how it relates to search and how to configure it.\nNote that tokenization is a concept that applies to keyword search and filtering, as well as in the context of language models.\nThis course focuses on the keyword aspect, but will briefly discuss how tokenization impacts language models.\nWhat is tokenization, and why is it important?\nWhat tokenization options are available in Weaviate?\nSee how tokenization impacts filters.\nSee how tokenization impacts searches.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The flat index is a very simple vector index that mimics a \"map\" data type. It simply stores the location of each vector, such that a search can be done by comparing the query vector to each vector in the collection. This leads to very low resource requirements, at the cost of search speed as the number of vectors increases."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/vector_index/flat",
          "webPageMainText": "The \"flat\" index is a simple and efficient vector index type that is best suited for small collections of vectors.\nThe flat index is a very simple vector index that mimics a \"map\" data type. It simply stores the location of each vector, such that a search can be done by comparing the query vector to each vector in the collection. As you might expect, this leads to very low resource requirements, at the cost of search speed as the number of vectors increases.\nWhere this index type shines is in large use cases where there are a high number of small collections, such as one for each end-user in a multi-tenant environment. A basic example may be a notes application, where each end user has their own collection of notes.\nIn such an environment, each end user will be treated as a \"tenant\", in a multi-tenant collection, and each tenant will have their own vector index. This is a perfect use case for the flat index.\nThe key compromise with the flat index is that it is not scalable. As the numb"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a persistent and fault-tolerant database. This page gives you an overview of how objects and vectors are stored within Weaviate and how an inverted index is created at import time. Each class in Weaviates user-defined schema leads to the creation of an index internally. An index is a wrapper type comprised of one or many shards."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/storage#object-and-inverted-index-store",
          "webPageMainText": "Weaviate is a persistent and fault-tolerant database. This page gives you an overview of how objects and vectors are stored within Weaviate and how an inverted index is created at import time.\nThe components mentioned on this page aid Weaviate in creating some of its unique features:\nEach class in Weaviate's user-defined schema leads to the creation of an index internally. An index is a wrapper type that is comprised of one or many shards. Shards within an index are self-contained storage units. Multiple shards can be used to distribute the load among multiple server nodes automatically.\nEach shard houses three main components:\nWeaviate doesn't rely on any third-party databases. The three components of a shard are all housed within Weaviate. This means that there are no runtime dependencies to other services and all components will scale equally with Weaviate.\nSince version v1.5.0, the object and inverted store are implemented using an LSM-Tree approach. This means that data can be ing"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Anyscale offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with Anyscale's Endpoints APIs. These integrations empower developers to build sophisticated AI-driven applications with ease. The model provider integration pages are new and still undergoing improvements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/anyscale",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nAnyscale offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with Anyscale's Endpoints APIs, allowing users to leverage Anyscale's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nAnyscale's generative AI models can generate human-like text based on given prompts and contexts.\nWeaviate's generative AI integration enables users to perform retrieval augmented generation (RAG) directly within the Weaviate database. This combines Weaviate's efficient storage and fast retrieval capabilities with Anyscale's generative AI models to generate personalized and context-aware responses.\nAnyscale generative AI integration page\nThese integrations enable developers to leverage Anyscale's powerful models directly within Weaviat"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative Anyscale is a module for Weaviate Cloud. It performs retrieval augmented generation, or RAG, based on the data stored in your instance. To use generative-anyscale, you must enable it in your Docker Compose file ( docker-compose.yml)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/generative-anyscale",
          "webPageMainText": "generative-anyscale performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance.\nThe module works in two steps:\nYou can use the Generative Anyscale module with any other upstream modules. For example, you could use text2vec-cohere, text2vec-huggingface or text2vec-openai to vectorize and query your data, but then rely on the generative-anyscale module to generate a response.\nThe generative module can perform RAG for:\nYou need to input both a query and a prompt (for individual responses) or a task (for all responses).\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use generative-anyscale, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables generative-anyscale and sets the Anyscale authentication credentials.\nYou can configure how the module will be"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This course is written for the Weaviate Python client API (v3), and is now deprecated. We will look at how to use keyword searches with the BM25F ranking algorithm. We'll also look at generative searches and question and answer searches. By the end of this unit, you will have a suite of query types to choose from."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_2",
          "webPageMainText": "This course was written for the Weaviate Python client API (v3), and is now deprecated.\nIf you are new to Weaviate, we recommend you start with one of the 100-level courses written with the v4 client API, such as those for working with text data, your own vectors, or multimodal data.\nIn this unit, you will learn about even more types of queries that you can run with Weaviate.\nWe will start by looking how to use keyword searches with the BM25F ranking algorithm, as well as hybrid searches that combines keyword searches with vector searches.\nThen, we will look at generative searches and question and answer (QnA) searches. These searches allow you to not only retrieve data objects, but to transform the results before returning them to you.\nBy the end of this unit, you will have a suite of query types to choose from, so that you can retrieve the right information in the form that you want.\nLet's get started.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/classifications",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate allows you to use the Cohere API to create and edit embeddings. You must provide a valid API key to use this feature. For more information, visit Weaviate's API page. For help with this feature, please visit the Weaviates API page: http://www.weaviate.com/."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/cohere/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Cohere's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use a Cohere embedding model, and Weaviate will generate embeddings for various operations using the specified model and your Cohere API key. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the Cohere vectorizer integration (text2vec-cohere) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Cohere API key to Weaviate for this integration. Go to Cohere to sign up and obtain an API key.\nProvide the API key to Weaviate using one of th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "With Weaviate you can query your data using vector similarity search, keyword search, or a mix of both with hybrid search. You can control what object properties and metadata to return. This page provides fundamental search syntax to get you started.You can get objects without specifying any parameters. This returns objects ordered by their UUID."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/basics",
          "webPageMainText": "With Weaviate you can query your data using vector similarity search, keyword search, or a mix of both with hybrid search. You can control what object properties and metadata to return.\nThis page provides fundamental search syntax to get you started.\nYou can get objects without specifying any parameters. This returns objects ordered by their UUID.\nThe output is like this:\n  Specify the information that you want your query to return. You can return object properties, object IDs, and object metadata.\nUse limit to set a fixed maximum number of objects to return.\nThe output is like this:\nTo start in the middle of your result set, define an offset. Set a limit to return objects starting at the offset.\nThe output is like this:\nTo paginate through the entire database, use a cursor instead of offset and limit.\nYou can specify which object properties to return.\nThe output is like this:\nYou can retrieve the object vector. (Also applicable where named vectors are used.)\nThe output is like this:\nY"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This course was written for the Weaviate Python client API (v3), and is now deprecated. We'll examine how to use Weaviates data structure so that you can retrieve the right information the way you want. By the end of this unit, Weaviated's overall data architecture will start to become clearer."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports",
          "webPageMainText": "This course was written for the Weaviate Python client API (v3), and is now deprecated.\nIf you are new to Weaviate, we recommend you start with one of the 100-level courses written with the v4 client API, such as those for working with text data, your own vectors, or multimodal data.\nThe previous units introduced you to the fundamentals of Weaviate, its capabilities, and how to execute basic queries on existing data. Now that you're familiar with the various query types, it's time to explore how to populate your own Weaviate instance with data.\nIn this unit, we'll examine how to use Weaviate to effectively structure your data so that you can retrieve the right information the way you want. We'll delve into defining a schema for your data and importing data into Weaviate.\nBy the end of this unit, Weaviate's overall data architecture will start to become clearer in your mind. This will start to empower you to build a vector database that really suits your needs and goals.\nLet's get start"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Sign up now and start building with your 14-day free trial. Pricing is based on dimensions stored and chosen SLA tier. The exact calculation can be found in the FAQ (not inclusive of discounts and taxes).All Packages include:Price per 1M vector dimensions stored per month.Phone Escalation response time: Severity 1."
              }
            ]
          },
          "url": "https://weaviate.io/pricing#contact-sales",
          "webPageMainText": "Pricing\nSign up now and start building with your 14-day free trial.\nOur ecosystem is designed to give you the capabilities to build and test your applications for free. When you are ready to move to production, simply pick a plan that best suits your needs.\nfrom $  25  /mo\nfrom $  135  /mo\nfrom $  450  /mo\nOur pricing is based on dimensions stored and chosen SLA tier. The exact calculation can be found in the FAQ (not inclusive of discounts and taxes).\nAll Packages include:\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $25/mo\n$0.095\n\n1bd\n2bd\n3bd\n5bd\nfrom $135/mo\n$0.145\n\n\n4h (24/7)\n8h (24/7)\n1bd\n2bd\nfrom $450/mo\n$0.175\n\n\n1h (24/7)\n4h (24/7)\n8h (24/7)\n1bd\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $25/mo\n$0.095\n\n1bd\n2bd\n3bd\n5bd\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeve"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model. To use this module, you must enable it in your Docker Compose file. For production use cases, we recommend using other modules that use a more modern, transformer-based architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-contextionary",
          "webPageMainText": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model.\nKey notes:\nAs a lightweight model, it is well suited for testing purposes.\nFor production use cases, we recommend using other modules that use a more modern, transformer-based architecture.\nThis module is not available on Weaviate Cloud.\nTo use text2vec-contextionary, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nContextionary:\nThis configuration enables text2vec-contextionary, sets it as the default vectorizer, and sets the parameters for the Contextionary Docker container.\nYou can configure how the module will behave in each class through the Weaviate schema.\nYou can set vectorizer behavior using the moduleConfig section under each class and property:\nIf you are using this module and are vectorizing the class or property name, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The media\u2019s recent obsession with generative AI and ChatGPT in particular was a bit of an early birthday present for Weaviate. In the last few months, we have found that when we talk about vector databases, we\u2019re more widely understood too."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/weaviate-celebrates-a-fourth-birthday",
          "webPageMainText": "\nIf Weaviate was a typical human child, this is about the stage of development when we would begin using the future tense in speech. And, at about four, kids begin using words that are 100% understandable to strangers, not just family members.\nOf course, we\u2019ve been thinking about the future from the very beginning; our fourth birthday is a rare occasion when we\u2019ll dwell on the past for a moment. But coincidentally, one thing that has happened recently is analogous to that hypothetical four-year-old child using language that strangers can understand: In the last few months, we have found that when we talk about vector databases, we\u2019re more widely understood too!\nThe media\u2019s recent obsession with generative AI and ChatGPT in particular was a bit of an early birthday present for Weaviate. Like so many watershed moments in tech\u2014or indeed, in life\u2014this happened at first very slowly, and then all of a sudden.\nSlowly\u2026\nAround 2014 people tinkered with machine learning and models, thinking of n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Concepts section explains various aspects related to Weaviate and its architecture. You can read these sections in any order. If you are after a practical guide, try the quickstart tutorial. The figure below gives a 30,000 feet view of Weaviates architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts",
          "webPageMainText": "The Concepts section explains various aspects related to Weaviate and its architecture to help you get the most out of it. You can read these sections in any order.\nIf you are after a practical guide, try the quickstart tutorial.\nData structure\nModules\nIndexing\nVector indexing\nVector quantization\nThe figure below gives a 30,000 feet view of Weaviate's architecture.\n\nYou can learn more about the individual components in this figure by following these guides:\nLearn about storage inside a shard\nWays to scale Weaviate horizontally\nHow to plan resources\nFiltered vector search\nUser-facing interfaces\nReplication architecture\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Docker is a set of products that use OS-level virtualization to deliver software in packages called containers. You can think of docker containers as lightweight virtual machines. After reading this article, your most common questions about these technologies should be answered and there should be nothing in the way of building amazing use cases with Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/blog/docker-and-containers-with-weaviate",
          "webPageMainText": "\nWeaviate attracts different users with various backgrounds. Some have been working with containers for years, but we understand that not everyone has. Inspired by a few recent questions and comments about Docker on the Weaviate Slack, I've set out to write an article to provide a better background on Docker and containers in general. After reading this article, your most common questions about these technologies should be answered and there should be nothing in the way of building amazing use cases with Weaviate.\nIn this short overview, we will:\nDocker is a [\u2026][set of products] that use OS-level virtualization to deliver software in packages called containers.\nWikipedia\nYou can think of docker containers as lightweight virtual machines. Each container has its own file system, own OS libraries and software. This provides a lot of isolation. At the same time, containers share the host system's kernel, so the overhead is much smaller than with regular virtual machines.\nThe best practice "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector search returns the objects with most similar vectors to that of the query. To search a collection that has named vectors, use the target vector field to specify which named vector to search. To set a similarity threshold between the search and target vectors, define a maximum distance (or certainty)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/similarity#search-with-image",
          "webPageMainText": "Vector search returns the objects with most similar vectors to that of the query.\nTo search a collection that has named vectors, use the target vector field to specify which named vector to search.\nThe output is like this:\nUse the Near Text operator to find objects with the nearest vector to an input text.\nThe output is like this:\nUse the Near Image operator to find objects with the nearest vector to an image.\nThis example uses a base64 representation of an image.\nSee Image search for more information.\nIf you have an object ID, use the Near Object operator to find similar objects to that object.\nIf you have an input vector, use the Near Vector operator to find objects with similar vectors\nTo set a similarity threshold between the search and target vectors, define a maximum distance (or certainty).\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\nTo limit results to groups of similar distances to the query, use the autocut fil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "When choosing an index type, use the following as a guide. In a multi-tenant environment, the \"dynamic\" index may be a good default choice, as it will allow some tenants to remain in the flat index while others are automatically converted to hnsw when they grow."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/vector_index/next_steps",
          "webPageMainText": "Congratulations! You have completed this course on vector indexes. We hope you found it helpful and informative.\nWhen choosing an index type, use the following as a guide:\nAlso, in a multi-tenant environment, the \"dynamic\" index may be a good default choice, as it will allow some tenants to remain in the flat index while others are automatically converted to hnsw when they grow.\nThese resources will help you continue your learning journey:\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn).\nSee you soon! \ud83d\udc4b\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We are a company backed by Index Ventures, Battery Ventures, New Enterprise Associates, Cortical Ventures, Zetta Venture Partners, ING Ventures, GTM-fund, Scale Asia Ventures, and Alex van Leeuwen. You can find more information about us on our Crunchbase page, our board and advisors are listed on our organizational chart."
              }
            ]
          },
          "url": "https://weaviate.io/company/investors",
          "webPageMainText": "Thanks for your interest in our journey to bring AI Native vector database infrastructure to developers and operators (DevOps / MLOps) all over the world.\nWe are a company backed by Index Ventures, Battery Ventures, New Enterprise Associates, Cortical Ventures, Zetta Venture Partners, ING Ventures, GTM-fund, Scale Asia Ventures, and Alex van Leeuwen.\nYou can find more information about us on our Crunchbase page, our board and advisors are listed on our organizational chart.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Dynamic indexing is an experimental feature. Use with caution."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/vector-index",
          "webPageMainText": "Vector indexes facilitate efficient, vector-first data storage and retrieval.\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nAvailable starting in v1.25. Dynamic indexing is an experimental feature. Use with caution.\nUse these parameters to configure the index type and their properties. They can be set in the collection configuration.\nGenerally, the hnsw index type is recommended for most use cases. The flat index type is recommended for use cases where the data the number of objects per index is low, such as in multi-tenancy cases."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate provides powerful filtered vector search capabilities. You can eliminate candidates in your \"fuzzy\" vector search based on individual properties. Thanks to Weaviate's efficient pre-filtering mechanism, you can keep the recall high - even when filters are very restrictive."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/prefiltering",
          "webPageMainText": "Weaviate provides powerful filtered vector search capabilities, meaning that you can eliminate candidates in your \"fuzzy\" vector search based on individual properties. Thanks to Weaviate's efficient pre-filtering mechanism, you can keep the recall high - even when filters are very restrictive. Additionally, the process is efficient and has minimal overhead compared to an unfiltered vector search.\nSystems that cannot make use of pre-filtering typically have to make use of post-filtering. This is an approach where a vector search is performed first and then some results are removed which do not match the filter. This leads to two major disadvantages:\nThe limitations of post-filtering are overcome by pre-filtering. Pre-Filtering describes an approach where eligible candidates are determined before a vector search is started. The vector search then only considers candidates that are present on the \"allow\" list.\nSome authors make a distinction between \"pre-filtering\" and \"single-stage filte"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate stores data in \"collections\" A collection is a set of objects that share the same data structure. In our movie database, we have properties like title, release_date and genre_ids, with data types like TEXT (string), DATE (date), or INT (integer)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_collections/create_collection",
          "webPageMainText": "Weaviate stores data in \"collections\". A collection is a set of objects that share the same data structure. In our movie database, we might have a collection of movies, a collection of actors, and a collection of reviews.\nHere we will create a collection of movies.\nThis example creates a collection for the movie data:\nEach collection definition must have a name. Then, you can define additional parameters like we've done in this example.\nProperties are the object attributes that you want to store in the collection. Each property has a name and a data type.\nIn our movie database, we have properties like title, release_date and genre_ids, with data types like TEXT (string), DATE (date), or INT (integer). It's also possible to have arrays of integers, like we have with genre_ids.\nAs a multimodal object, we also have the poster property which is the image data, which is saved as a BLOB (binary large object) data type.\nWeaviate can automatically infer the schema from the data. However, it's "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with Cohere's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps. These integrations empower developers to build sophisticated AI-driven applications with ease."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/cohere",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nCohere offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with Cohere's APIs, allowing users to leverage Cohere's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nCohere's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with Cohere's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nCohere embedding integration page\n\nCohere's generative AI models can generate human-like text based on given prompts and contexts.\nWeaviate's generative AI integration enables u"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This unit will provide you with an overview of the fundamentals of Weaviate. You will then learn about what vector database and vector search are. By the end of this unit, you will have a strong foundation of knowledge that will help you to effectively navigate the rest of the course. This course was written for the Weaviates Python client API (v3), and is now deprecated."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate",
          "webPageMainText": "This course was written for the Weaviate Python client API (v3), and is now deprecated.\nIf you are new to Weaviate, we recommend you start with one of the 100-level courses written with the v4 client API, such as those for working with text data, your own vectors, or multimodal data.\nWelcome!\nThis is the beginning of your journey through the world of vectors with Weaviate. This unit will provide you with an overview of the fundamentals of Weaviate.\nYou'll first gain an understanding of what Weaviate is, and what it can do. You will then learn about what vector database and vector search are before going on to run Weaviate and perform vector searches yourself.\nBy the end of this unit, you will have a strong foundation of knowledge that will help you to effectively navigate the rest of the course, and for using Weaviate in your own projects.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a database with hundreds of millions of data objects. Weaviate must be able to import data quickly and reliably while maintaining data integrity and reducing time overhead. Database design comes with interesting challenges. Lock striping is an arrangement where locking occurs on multiple buckets or 'stripes'"
              }
            ]
          },
          "url": "https://weaviate.io/blog/Lock-striping-pattern",
          "webPageMainText": "\nDatabase design comes with interesting challenges. Like, dealing with race conditions when importing data in parallel streams. But for every new challenge, there is a clever solution. One of those clever solutions is Lock striping. It refers to an arrangement where locking occurs on multiple buckets or 'stripes'.\nAre you curious about, the challenge that we faced, which solutions we considered, and what was our final solution? Read on \ud83d\ude00.\nDatabases must be able to import data quickly and reliably while maintaining data integrity and reducing time overhead. Weaviate is no exception to this! Given that our users populate Weaviate with hundreds of millions of data objects (if not more), we appreciate that import performance is of the highest ... import-ance (sorry) \ud83e\udd41.\nWeaviate offers and strongly recommends the batch import feature for adding data objects in bulk. To further speed up the import process, you can use parallelization, which lets you run multiple batches concurrently. Each ob"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A 'single prompt' generation wil perform RAG queries on each retrieved object. This is useful when you want to transform each object separately, with the same prompt. This example finds entries in \"Movie\" whose vector best matches the query vector (for \"dystopian future\"). Then, instructs the large language model to translate the title of each movie into French."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_rag/single_prompt",
          "webPageMainText": "A 'single prompt' generation wil perform RAG queries on each retrieved object. This is useful when you want to transform each object separately, with the same prompt.\nThis example finds entries in \"Movie\" whose vector best matches the query vector (for \"dystopian future\"). Then, instructs the large language model to translate the title of each movie into French.\nEach of the results are then printed out to the console.\nYou must pass on one or more properties to the single_prompt parameter through braces, as we've done here with \"... {title} ...\". This will instruct Weaviate to pass on the title property from each retrieved object to the large language model.\nEach response object is similar to that from a regular search query, with an additional generated attribute. This attribute will contain the generated output for each object.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#replicationconfig",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This course uses a local, Docker instance of Weaviate. Generating multimodal vectors is currently only possible with local models. See the Work with: your own vectors course for more information. If you are generating vectors outside of WeAViate, you can use a cloud instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/setup_weaviate/create_docker",
          "webPageMainText": "Generating multimodal vectors is currently only possible with local models, and as a result this course uses a local, Docker instance of Weaviate. If you are generating vectors outside of Weaviate, you can use a cloud instance. See the Work with: your own vectors course for more information.\nHere, you will create a Weaviate instance and a multi-modal vectorizer container using Docker.\nInstall Docker on your machine. We recommend following the official Docker installation guide.\nCreate a new directory and navigate to it in your terminal. Then, create a new file called docker-compose.yml and add the following content:\nRun the following command to start Weaviate:\nOnce the instance is created, you can access it at http://localhost:8080.\nTo connect to the Weaviate instance, use the connect_to_local function.\nSome Weaviate modules can use inference APIs for vectorizing data or large language model integration. You can provide the API keys for these services to Weaviate at instantiation.\nThis"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#other-use-cases",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has spent almost its entire life as a company in the pandemic and post-pandemic period. We were never forced to make a rushed transition from on-site to remote work; we were born remote-first. We believe that the benefits of remote work clearly outweigh any disadvantages."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/being-a-remote-first-company",
          "webPageMainText": "\nWeaviate has spent almost its entire life as a company in the pandemic and post-pandemic period (that is, if we dare assume that the days of major Covid disruptions are over!). For us, that was lucky timing. We were never forced to make a rushed transition from on-site to remote work; we were born remote-first.\nLike many companies who made that transition, we've found that our people are happier and, if anything, more productive. Unlike those legacy companies, we have no intention of switching back\u2014or in our case, just switching\u2014to onsite work.\nWe believe that the benefits of remote work clearly outweigh any disadvantages. Let's face it: the old 9-5 workday didn't work for everyone. Some employees are morning people; others are night owls. Some people love to travel; they're energized by new sights and sounds and pump that energy into their work.\nMost importantly, we're not just a new company; we're working in a whole new tech ecosystem. It is a challenge to find people who have solid"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this section, we will explore data import, including details of the batch import process. We will discuss points such as how vectors are imported, what a batch import is, how to manage errors, and some advice on optimization. Before you start this tutorial, you should follow the steps in the tutorials to have:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/import",
          "webPageMainText": "In this section, we will explore data import, including details of the batch import process. We will discuss points such as how vectors are imported, what a batch import is, how to manage errors, and some advice on optimization.\nBefore you start this tutorial, you should follow the steps in the tutorials to have:\nWe will use the dataset below. We suggest that you download it to your working directory.\nDownload jeopardy_tiny.json\nAs mentioned in the schema tutorial, the schema specifies the data structure for Weaviate.\nSo the data import must map properties of each record to those of the relevant class in the schema. In this case, the relevant class is Question as defined in the previous section.\nEach Weaviate data object is structured as follows:\nMost commonly, Weaviate users import data through a Weaviate client library.\nIt is worth noting, however, that data is ultimately added through the RESTful API, either through the objects endpoint or the batch endpoint.\nAs the names suggest, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this section, we'll work with an actual Weaviate instance to see how different tokenization methods impact filtering results. We are going to use a very small, custom dataset for demonstration purposes. We will create a simple object collection, with each object containing multiple properties."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/tokenization/filters#discussions",
          "webPageMainText": "Now that you've learned about different tokenization methods, let's put them into practice. In this section, you'll see how tokenization impacts filters.\nFor this section, we'll work with an actual Weaviate instance to see how different tokenization methods impact filtering results.\nWe are going to use a very small, custom dataset for demonstration purposes.\nTo follow along, you can use the following Python code to add this data to your Weaviate instance.\nWe will create a simple object collection, with each object containing multiple properties. Each properties will contain the same text, but with different tokenization methods applied.\nNote that we do not add object vectors in this case, as we are only interested in the impact of tokenization on filters (and keyword searches).\nNow, we add objects to the collection, repeating text objects as properties.\nNow that we have added a set of objects to Weaviate, let's see how different tokenization methods impact filtered retrieval.\nEach filt"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate stores data objects in class-based collections. Each data object in Weaviate belongs to a collection and has one or more properties. Data objects are represented as JSON-documents. Objects normally include a vector that is derived from a machine learning model. The vector is also called an embedding or a vector embedding."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/data#multi-tenancy",
          "webPageMainText": "Each data object in Weaviate belongs to a collection and has one or more properties.\nWeaviate stores data objects in class-based collections. Data objects are represented as JSON-documents. Objects normally include a vector that is derived from a machine learning model. The vector is also called an embedding or a vector embedding.\nEach collection contains objects of the same class. The objects are defined by a common schema.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nImagine we need to store information about an author named Alice Munro. In JSON format the data looks like this:\nYou can also attach vector representations to your data objects. Vectors are arrays of numbers that are stored under the \"vector\" property.\nIn this example, the Alice Munro data object has a small vector. The vector is some information about Alice, maybe a story or an image, that a machine "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Contextionary is the pretrained language model that can come with Weaviate. It gives context and semantics to the language use in the dataset. Note that this is not intended for stand-alone use. Find benchmarks of this trained language model on the Classification benchmarks page."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/contextionary",
          "webPageMainText": "The Contextionary is the pretrained language model that can come with Weaviate. It gives context and semantics to the language use in the dataset. You can read more about what the Contextionary (c11y) is here.\nThe Contextionary can be found on GitHub, but note that this is not intended for stand-alone use. Find benchmarks of this trained language model on the Classification benchmarks page.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The v4 Weaviate Python client API is a complete rewrite, aimed at an improved overall user experience. It is therefore also very different to the v3 API, and will require re-learning of changed patterns. The current Python client version is v4.6.5."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration",
          "webPageMainText": "The current Python client version is v4.6.5\nThe v4 Weaviate Python client API is a complete rewrite, aimed at an improved overall user experience. It is therefore also very different to the v3 API, and will require re-learning of changed patterns in the way you interact with Weaviate.\nWhile this may introduce some overhead, we believe the v4 API is a significant improvement to your developer experience. For instance, using the v4 client will allow you to take full advantage faster speeds through the gRPC API, and additional static analysis for IDE assistance through strong typing.\nDue to the extensive API surface changes, this guide does not cover every change. Instead, this guide is designed to help you understand the major changes and how to migrate your code at a high level.\nFor code examples, refer to the documentation throughout the site, starting with these suggested sections.\nTo go from v3 to v4, you must\nUpgrade the client library:\nUpgrade Weaviate to a compatible version\nMake "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Git is a version control tool which keeps track of the changes you make to files. It allows you to go back to previous versions if necessary and keeping a record of what has been done. There are four major GitHub repositories of Weaviate, any of which you can contribute to."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/getting-started/git-and-github",
          "webPageMainText": "Git and GitHub are indispensable tools for working with open-source communities.\nSo we prepared a guide on using git and GitHub to help you contribute to Weaviate. If you are relatively new to working on open-source projects, you may find this section helpful.\nIf you are new to git/GitHub, you can go through this section like a tutorial and follow along. Alternatively, you can treat it as a reference and jump to the relevant section. The commands shown below are shell commands.\nThere are four major GitHub repositories of Weaviate, any of which you can contribute to. This includes:\nGenerally speaking, the process to contribute using git and GitHub goes like this:\nHere is some information on working with git and GitHub.\nGit is a version control tool which keeps track of the changes you make to files, allowing you to go back to previous versions if necessary and keeping a record of what has been done.\nEach set of tracked files is called a \"repository\", or a \"repo\". Each repo is typically "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#tokenization",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default docker image doesn't need any configuration. To customize your instance, edit the configuration settings in the docker-compose.yml file. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally. You can use environment variables to control your Weaviates setup, authentication and authorization."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/docker-compose#environment-variables",
          "webPageMainText": "Weaviate supports deployment with Docker. If you use the default values, you don't need a docker-compose.yml file to run the image. To customize your instance, edit the configuration settings in the docker-compose.yml file.\nThe default docker image doesn't need any configuration. To run a basic Weaviate instance, run this command from a terminal:\nThe command sets the following default values:\nWe prepared a starter Docker Compose file, which will let you:\nSave the text below as docker-compose.yml:\nEdit the docker-compose.yml file to add your local configuration. To start your Weaviate instance, run this command in your shell:\nThe Configurator can generate a docker-compose.yml file for you. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally (i.e. text2vec-transformers, or multi2vec-clip)\nYou can use environment variables to control your Weaviate setup, authentication and authorization, module settings, and data storage settings.\nA comprehensi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The dynamic index is a flat index that is automatically converted to an hnsw index when the number of vectors in the collection exceeds a predetermined threshold. The flat index is very efficient for small collections, but its search time increases linearly with the number. The hnSW index, on the other hand, is more efficient for large collections but includes a memory overhead."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/vector_index/dynamic",
          "webPageMainText": "The \"dyanmic\" index is a \"best of both worlds\" approach that combines the benefits of the hnsw and flat indexes.\nSimply put, the dynamic index is a flat index that is automatically converted to an hnsw index when the number of vectors in the collection exceeds a predetermined threshold (10,000 by default).\nThe motivation for this is that the flat index is very efficient for small collections, but its search time increases linearly with the number of vectors in the collection. The hnsw index, on the other hand, is more efficient for large collections, but includes a memory overhead with little benefit for small collections.\nThe dynamic index is a good choice if you do not know how big the size of each collection will be, or if you expect some tenants to grow much larger than others.\nIn a multi-tenancy configuration, this will mean that all tenants will start with the flat index, but will automatically switch to the hnsw index when the number of vectors in the collection exceeds the thre"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We welcome and support people of all backgrounds and identities. This includes but is not limited to, members of any sexual orientation, gender identity and expression, race, ethnicity, culture, national origin, social and economic class. An environment where people feel uncomfortable or threatened is not a productive or creative one."
              }
            ]
          },
          "url": "https://weaviate.io/service/code-of-ethics-and-professional-conduct",
          "webPageMainText": " \nWe welcome and support people of all backgrounds and identities. This includes but is not limited to, members of any sexual orientation, gender identity and expression, race, ethnicity, culture, national origin, social and economic class, educational level, color, immigration status, sex, age, size, family status, political belief, religion, and mental and physical ability.\nInside our Community, we depend on each other to thrive, learn, share, and produce the best experience we can as a community. Your decisions and communication will impact other community members. You should take those consequences into account when making decisions.\nWe won't all agree all the time, but disagreement is no excuse for disrespectful behavior. We all experience frustration from time to time, but we cannot allow that frustration to become personal attacks. An environment where people feel uncomfortable or threatened is not a productive or creative one.\nAlways conduct yourself professionally. Be kind to "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_rag",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.16 brings a set of great features, performance and UX improvements, and fixes. The ability to seamlessly combine an inverted index with a vector index is part of what makes Weaviate so powerful. The possibility to query the null state has been added."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-16-release",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.16, which brings a set of great features, performance and UX improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\n\nOne of the core functionalities of databases are the index structures that allow us to find data objects quickly. The ability to seamlessly combine an inverted index with a vector index is part of what makes Weaviate so powerful. An inverted index maps the property value to the objects that it appears in. This is important when filtering through your database to find specific data objects.\nWhen dealing with large datasets, it is very common to have objects with missing or null properties. Naturally, you might want to find the objects with missing properties and do a bit of cleaning up. With Weaviate 1.16 we introduced the possibility to query the null state. This applies to both scenarios where a pro"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use the after operator to retrieve all objects from a Weaviate instance. The after operator retrieves objects of a class based on the order of ids. You can pass the id of the last retrieved object as a cursor to start the next page. The offset parameter is a flexible way to page results as it allows use with parameters like sort."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/objects#response-fields",
          "webPageMainText": "Use the after operator.\nList data objects in reverse order of creation. The data will be returned as an array of objects.\nA: This Aggregate query will output a total object count in a class.\nWithout any restrictions (across classes, default limit = 25):\nWith optional query params:\nYou can use limit and offset for paging results.\nThe offset parameter is a flexible way to page results as it allows use with parameters such as sort. It is limited by the value of QUERY_MAXIMUM_RESULTS which sets the maximum total number of objects that can be listed using this parameter.\nGet the first 10 objects:\nGet the second batch of 10 objects:\nGet the next batch of 10 objects:\nYou can use the after operator to retrieve all objects from a Weaviate instance . The after operator (\"Cursor API\") retrieves objects of a class based on the order of ids. You can pass the id of the last retrieved object as a cursor to start the next page.\nIt is not possible to use the after operator without specifying a class.\nF"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate uses the Raft consensus algorithm for schema replication, implemented with Hashicorp's raft library. A schema change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. This architecture ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/cluster-architecture#schema-replication-raft",
          "webPageMainText": "This page describes how the nodes or clusters in Weaviate's replication design behave.\nIn Weaviate, schema replication and data replication are separate. For the schema, Weaviate uses the Raft consensus algorithm with strong consistency. For data replication, Weaviate uses a leaderless design with eventual consistency.\nWeaviate uses the Raft consensus algorithm for schema replication, implemented with Hashicorp's raft library.\nRaft ensures that schema changes are consistent across the cluster. A schema change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. Once a majority of nodes have acknowledged the change, the leader commits the change to the log. The leader then notifies the followers, which apply the change to their logs.\nThis architecture ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures.\nAs a result, a Weaviate cluster will include a leader node that"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We have imported the complete Wikidata PBG model into a Weaviate to search through the entire dataset. The demo GraphQL queries contain both pure vector search and scalar and vector searched mixed queries. We have made the import scripts, pre-processed articles, and backup available so that you can run the complete setup."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/example-datasets",
          "webPageMainText": "This example application spins up a Weaviate instance using the\nmulti2vec-clip\nmodule, imports a few sample images (you can add your own images, too!) and\nprovides a very simple search frontend in React using\nthe TypeScript/JavaScript client.\nGet started here\nWe imported the complete English language Wikipedia article dataset into a single Weaviate instance to conduct semantic search queries through the Wikipedia articles, besides this, we've made all the graph relations between the articles too. We have made the import scripts, pre-processed articles, and backup available so that you can run the complete setup yourself.\nGet started here\nWe have imported the complete Wikidata PBG model into a Weaviate to search through the entire dataset in < 50 milliseconds (excluding internet latency). The demo GraphQL queries contain both pure vector search and scalar and vector searched mixed queries.\nGet started here\nThis dataset contains +/- 1000 random news articles from; Financial Times, New Yo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use the after operator to retrieve all objects from a Weaviate instance. The after operator retrieves objects of a class based on the order of ids. You can pass the id of the last retrieved object as a cursor to start the next page. The offset parameter is a flexible way to page results as it allows use with parameters like sort."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/objects#parameters-1",
          "webPageMainText": "Use the after operator.\nList data objects in reverse order of creation. The data will be returned as an array of objects.\nA: This Aggregate query will output a total object count in a class.\nWithout any restrictions (across classes, default limit = 25):\nWith optional query params:\nYou can use limit and offset for paging results.\nThe offset parameter is a flexible way to page results as it allows use with parameters such as sort. It is limited by the value of QUERY_MAXIMUM_RESULTS which sets the maximum total number of objects that can be listed using this parameter.\nGet the first 10 objects:\nGet the second batch of 10 objects:\nGet the next batch of 10 objects:\nYou can use the after operator to retrieve all objects from a Weaviate instance . The after operator (\"Cursor API\") retrieves objects of a class based on the order of ids. You can pass the id of the last retrieved object as a cursor to start the next page.\nIt is not possible to use the after operator without specifying a class.\nF"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "As a remote-first company, Weaviate gives its people the flexibility to work when and where they choose. But there\u2019s more to work/life balance than flexibility on the \u2018work\u2019 side of that equation. I believe that taking time off to recharge and refresh one's mind are essential."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/taking-time-off-at-weaviate",
          "webPageMainText": "\nAs a remote-first company, Weaviate gives its people the flexibility to work when and where they choose. We give every employee lots of autonomy and trust they will work in a way that suits their situation and needs, while also fulfilling the requirements of their position and supporting other team members.\nBut there\u2019s more to work/life balance than flexibility on the \u201cwork\u201d side of that equation. I believe that taking time off to recharge and refresh one\u2019s mind are essential. So yes, it follows that if any person is to do their best work, they must spend occasional blocks of time not working. That\u2019s why we\u2019ve developed a philosophy about taking time off, and actively encourage our people to use their time off.\nHowever, just as individuals have unique workstyles, they also have unique needs as regards time off. That\u2019s especially true for Weaviate; as we assemble an increasingly global team, we need to take different countries and cultures into account, as well as our company values an"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate allows partial or complete object updates. To update objects, you must provide the collection name, id and properties. For multi-tenancy collections, you will also need to specify the tenant name. Weaviate v2.0.0 is now available."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/update",
          "webPageMainText": "Weaviate allows partial or complete object updates.\nPartial updates use PATCH requests to the /v1/objects REST API endpoint under the hood.\nComplete updates use PUT requests to the /v1/objects REST API endpoint under the hood.\nUpdates that include a vector property will recalculate the vector embedding (unless all updated text properties are skipped).\nTo update objects, you must provide the collection name, id and properties to update.\nFor multi-tenancy collections, you will also need to specify the tenant name. See Manage data: multi-tenancy operations for details on how.\nCollections act like namespaces, so two different collections could have duplicate IDs between them.\n\n\nPrior to Weaviate v1.14 you can manipulate objects without specifying the collection name. This method is deprecated. It will be removed in Weaviate v2.0.0.\nStarting in v1.20, you can have multi-tenant datasets. When multi-tenancy is enabled, the tenant name is required.\nAlways include the collection name, and, when"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/blog/tags",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate provides the necessary APIs to iterate through all your data. This is useful when you want to manually copy/migrate your data (and vector embeddings) from one place to another. The new API clients (currently supported by the Python Client v4), encapsulate this functionality as an Iterator."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/read-all-objects",
          "webPageMainText": "Weaviate provides the necessary APIs to iterate through all your data. This is useful when you want to manually copy/migrate your data (and vector embeddings) from one place to another.\nThis is done with the help of the after operator, also called the cursor API.\nThe new API clients (currently supported by the Python Client v4), encapsulate this functionality as an Iterator.\nThe following code iterates through all objects, providing the properties and id for each object.\nRead through all data including the vectors. (Also applicable where named vectors are used.)\nIterate through all tenants and read data for each.\nFor classes where multi-tenancy is enabled, you need to specify the tenant name when reading or creating objects. See Manage data: multi-tenancy operations for details.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Training a LLM to understand images!Fine-Tuning for Better Retrieval-Augmented Generation.Zero-shot detection of LLM generated content. Training LLMs without making them memorize! Training LLM's to understand an image without memorizing it."
              }
            ]
          },
          "url": "https://weaviate.io/papers",
          "webPageMainText": "Training LLMs without making them memorize!\nTraining a LLM to understand images!\nFine-Tuning for Better Retrieval-Augmented Generation\nZero-shot detection of LLM generated content.\nOverview of the different RAG techniques.\nOverview of OpenAI's New Truncatable - Matryoshka Embeddings\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The gRPC API is faster than the REST API. Use it to improve import speeds. Batch imports are an efficient way to add multiple data objects and cross-references. To create a bulk import job, follow these steps:The following example adds objects to the MyCollection collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/import#specify-a-vector",
          "webPageMainText": "Batch imports are an efficient way to add multiple data objects and cross-references.\nTo create a bulk import job, follow these steps:\nThe following example adds objects to the MyCollection collection.\nThe gRPC API is faster than the REST API. Use the gRPC API to improve import speeds.\nThe Python client uses gRPC by default. See the client page for additional batch import configuration options.\nThe TypeScript client v3 uses gRPC by default.\nTo use the gRPC API with the Java client, add the setGRPCHost field to your client connection code. Update setGRPCSecured if you use an encrypted connection.\nTo use the gRPC API with the Go client, add the GrpcConfig field to your client connection code. Update Secured if you use an encrypted connection.\nTo use the gRPC API with the Spark connector, add the grpc:host field to your client connection code. Update grpc:secured if you use an encrypted connection.\nWeaviate generates an UUID for each object. Object IDs must be unique. If you set object ID"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This self-contained, practical video course will teach you the basics of Weaviate. It will also teach you how to integrate it to a TypeScript (or JavaScript) app. The course will be available in English, Spanish, French and Italian. It is intended to be a short course of about 30 minutes in length."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/js/intro_weaviate_typescript",
          "webPageMainText": "This self-contained, practical video course will teach you the basics of Weaviate, and how to integrate it to a TypeScript (or JavaScript) app.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#vector-cache-considerations",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) provides a web interface and an API endpoint that provide information about your Weaviate instance. Each cluster has a Details button. To get cluster details programmatically, use the nodes REST endpoint. For help with Serverless, Enterprise SaaS, and Bring Your Own Cloud accounts, contact Weaviates support directly to open a support ticket."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/cluster-status",
          "webPageMainText": "Weaviate Cloud (WCD) provides a web interface and an API endpoint that provide information about your Weaviate instance.\nWhen you log into the WCD web console, the Dashboard tab lists your clusters. Each cluster has a Details button. Click the Details button to see the following information:\nThe Details view also has an Advanced configuration button. Click on Advanced configuration to configure, or to check the status of, these additional settings:\nTo get cluster details programmatically, use the nodes REST endpoint.\nThe nodes endpoint returns an array of nodes. The nodes have the following fields:\nFor help with Serverless, Enterprise SaaS, and Bring Your Own Cloud accounts, contact Weaviate support directly to open a support ticket.\nFor questions and support from the Weaviate community, try these resources:\nTo add a support plan, contact Weaviate sales.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If you haven't yet, we recommend going through the Quickstart tutorial first to get the most out of this section. Tutorials aim to empower you to use Weaviate based on your particular needs.Here, you can learn how to: Use Weaviates in a variety of ways."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials",
          "webPageMainText": "Tutorials aim to empower you to use Weaviate based on your particular needs.\nIf you haven't yet, we recommend going through the Quickstart tutorial first to get the most out of this section.\nHere, you can learn how to:\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Large Language Models are heralding a new era in information technology. To better understand this revolution, it\u2019s important to consider the historical context. The printing press significantly reduced the cost of reproducing information. The internet cut out the middleman, making the distribution of information virtually free."
              }
            ]
          },
          "url": "https://weaviate.io/blog/generative-feedback-loops-with-LLMs",
          "webPageMainText": "\nLarge Language Models are heralding a new era in information technology. To better understand this revolution, it\u2019s important to consider the historical context. The printing press significantly reduced the cost of reproducing information, while the internet cut out the middleman, making the distribution of information virtually free. In Aggregation Theory, Ben Thompson writes about how the free distribution of the internet allowed companies to modularize (or unbundle) services and focus on user experience. Ben states that \u201ccompanies that win the user experience can generate a virtuous cycle where their ownership of consumers/users attracts suppliers which improves the user experience\u201d.\nEnter Large Language Models (LLMs), a world changing technology that enables transforming and generating information at incredible speeds and low cost. LLMs present the opportunity to expedite the virtuous cycle Aggregation Theory describes by commoditizing the human effort traditionally required to de"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.24 is here! Here are the release highlights. Named vectors make your collections richer and more versatile. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-24-release",
          "webPageMainText": "Weaviate 1.24 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nNamed vectors make your collections richer and more versatile.\nStarting in 1.24, collections can have multiple named vectors. Each vector is independent. Each vector has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to fine tune interactions with your data.\nIn earlier versions, objects in your collections are limited to one vector. Now, you can vectorize meta data like titles and descriptions so that it is available for vector search. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata. A single object in a collection can have multiple named vectors.\nYou don't have to use multiple vectors in your collections, but if you do, adjust your queries to specify which vector you want to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_searches",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/nodes",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) provides two instance types. Sandbox clusters run a full version of the Weaviate core database. Sandboxes are fully featured, but they have a limited lifetime and they run on scaled down infrastructure compared to serverless clusters. If you are working through a course in Weaviates Academy, consider using a sandbox to complete the lessons."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/sandbox",
          "webPageMainText": "Weaviate Cloud (WCD) provides two instance types.\nSandbox clusters run a full version of the Weaviate core database. When you create a sandbox, it has the latest version of Weaviate core.\nWeaviate core uses modules to connect to vectorizers, rankers, generators, and other services. Modules provide programmatic connections to these services. WCD provides built in modules for more than a dozen services. To see the list of modules that are available for your cluster, check the cluster details panel in the Weaviate web console.\nSandbox clusters are intended for learning, experimenting, and exploring. Sandboxes are fully featured, but they have a limited lifetime and they run on scaled down infrastructure compared to serverless clusters.\nIf you are working through a course in Weaviate Academy, consider using a sandbox to complete the lessons without having to install and configure a local instance.\nSandboxes are not designed for production use. Compared to serverless instances, they are lim"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The new Weaviate v3 Typescript client is now available. The new client has a faster gRPC-powered API and numerous quality-of-life improvements. To install the new client, run the following command in your terminal:$ wget -i \"v3\" && wget http://www.weaviate.com/v3."
              }
            ]
          },
          "url": "https://weaviate.io/blog/typescript-client-stable-release",
          "webPageMainText": "\nThe new TypeScript client is now GA!!! After a successful beta phase, we are ready to share the best Weaviate TypeScript client yet. \nNot too long ago we released the beta version of the Weaviate v3 Typescript client, an extremely well received release! After a successful beta, today we\u2019re happy to share that the v3 Weaviate Typescript client is stable. We're even more excited to invest more in enabling the JavaScript ecosystem with this and subsequent releases.\nTo install the new client, run the following command in your terminal.\nAs highlighted previously, following the release of a new Python client, we felt it necessary to dedicate time to serving the Javascript community. The v3 client is what came out; with a faster gRPC-powered API, first-class Typescript support and numerous quality-of-life improvements! Don't just take our word for it. We've had a wonderful group of early adopters building real applications and solving problems.\n\"I\u2019ve been enjoying the v3 client as it nears r"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#replication-settings",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Module system is a way to extend Weaviate's functionality. The user decides which modules are activated at startup through configuration. modules provide access to various machine-learning models which can be used to turn media into vectors at query and import time. We are going through the text2vec-transformers module as an example."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-modules/overview#high-level-architecture",
          "webPageMainText": "The Module system in Weaviate is a way to extend Weaviate's functionality.\nModules often provide access to various machine-learning models which can be\nused to turn media into vectors at query and import time. However, that's not\nthe only thing a module can do; any extension on functionality can be\nincorporated into a module.\nThe user decides which modules are activated at startup through configuration.\nSome modules can be combined with each other, others might be conflicting. In\nthis case startup will fail.\nA module is essentially code which compiles with Weaviate, but a module can\nalso communicate with other services. We are going through the\ntext2vec-transformers module as an example.\nFrom a high level, the motivation for a user to enable this module would be to\nhave their imported data vectorized with a transformer module (e.g. BERT,\netc.). Additionally, at query time, the query string should also be vectorized\nin the same way.\nFrom a tech level this module therefore has to provide"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The module can be used with either Google Cloud Vertex AI or AI Studio. The configurations vary slightly for each. AI Studio (previously called MakerSuite) support was added in version 1.22.4. The API key for VertexAI users is called an access token in Google Cloud."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/generative-palm",
          "webPageMainText": "AI Studio (previously called MakerSuite) support was added in version 1.22.4.\nThe module can be used with either Google Cloud Vertex AI or AI Studio. The configurations vary slightly for each.\nStarting from v1.25.1 and v1.24.14, there are separate headers X-Google-Vertex-Api-Key and X-Google-Studio-Api-Key for Vertex AI users and AI Studio respectively.\nPrior to Weaviate v1.25.1 or v1.24.14, there was one header for both Vertex AI users and AI Studio, specified with either X-Google-Api-Key or X-PaLM-Api-Key. We recommend using the new headers for clarity and future compatibility.\nYou must enable the Vertex AI API on your Google Cloud project. To enable the API, following these instructions.\nThe API key for Vertex AI users is called an access token in Google Cloud.\nIf you have the Google Cloud CLI tool installed and set up, you can view your token by running the following command:\nBy default, Google Cloud's OAuth 2.0 access tokens have a lifetime of 1 hour. You can create tokens that la"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Sign up now and start building with your 14-day free trial. Pricing is based on dimensions stored and chosen SLA tier. The exact calculation can be found in the FAQ (not inclusive of discounts and taxes).All Packages include:Price per 1M vector dimensions stored per month.Phone Escalation response time: Severity 1."
              }
            ]
          },
          "url": "https://weaviate.io/pricing#faq",
          "webPageMainText": "Pricing\nSign up now and start building with your 14-day free trial.\nOur ecosystem is designed to give you the capabilities to build and test your applications for free. When you are ready to move to production, simply pick a plan that best suits your needs.\nfrom $  25  /mo\nfrom $  135  /mo\nfrom $  450  /mo\nOur pricing is based on dimensions stored and chosen SLA tier. The exact calculation can be found in the FAQ (not inclusive of discounts and taxes).\nAll Packages include:\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $25/mo\n$0.095\n\n1bd\n2bd\n3bd\n5bd\nfrom $135/mo\n$0.145\n\n\n4h (24/7)\n8h (24/7)\n1bd\n2bd\nfrom $450/mo\n$0.175\n\n\n1h (24/7)\n4h (24/7)\n8h (24/7)\n1bd\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $25/mo\n$0.095\n\n1bd\n2bd\n3bd\n5bd\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeve"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate allows object deletion by id or by a set of criteria. To delete objects, you must provide the collection name as well as identifying criteria (e.g. object id or filters) For multi-tenancy collections, you will also need to specify the tenant name when deleting objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/delete#use-containsany--containsall",
          "webPageMainText": "Weaviate allows object deletion by id or by a set of criteria.\nTo delete objects, you must provide the collection name as well as identifying criteria (e.g. object id or filters).\nFor multi-tenancy collections, you will also need to specify the tenant name when deleting objects. See Manage data: multi-tenancy operations for details on how.\nCollections act like namespaces, so two different collections could have duplicate IDs between them.\n\n\nPrior to Weaviate v1.14 you can manipulate objects without specifying the collection name. This method is deprecated. It will be removed in Weaviate v2.0.0.\nStarting in v1.20, you can have multi-tenant datasets. When multi-tenancy is enabled, the tenant name is required.\nAlways include the collection name, and, when enabled, the tenant name.\nTo delete by id, specify the collection name and the object id.\nTo delete objects that match a set of criteria, specify the collection and a where filter.\nThe ContainsAny / ContainsAll filters allow deletion of "
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/schema/put/schema/%7BclassName%7D",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Cohere is an AI platform that provides its users with access to its LLMs. Cohere trains their own LLMs for text generation and understanding and serves them via API. You can think of it as a managed LLM service in the cloud, with the ability to customize/finetune them on your dataset."
              }
            ]
          },
          "url": "https://weaviate.io/blog/cohere-multilingual-with-weaviate",
          "webPageMainText": "\nNatural Language Processing (NLP) has enabled computers to understand the human language. It has shifted the way humans build and interact with computers. Large Language Models (LLMs) underpin the latest developments in NLP and have gained traction in various applications. Cohere is an AI platform that provides its users with access to its LLMs. Cohere gives developers and businesses the ability to implement NLP as part of their toolkit.\nCohere trains their own LLMs for text generation and understanding and serves them via API. You can think of it as a managed LLM service in the cloud, with the ability to customize/finetune them on your dataset.\nNow, you can combine Cohere\u2019s LLMs with a vector database like Weaviate to get the best of both worlds. More specifically, you can run complex NLP queries at a large scale of millions (and even billions) of text objects and get results back in a blink of an eye.\nIf you don\u2019t consider a \"blink of an eye\" as a scientific metric (note: it isn\u2019t!)"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Embedded Weaviate is a new deployment model that runs a Weaviates instance from your application code. It creates a permanent datastore in the location set in your persistence_data_path. The next time the client runs, it starts a new instance of Embedded weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/embedded#lifecycle",
          "webPageMainText": "Embedded Weaviate is experimental software. APIs and parameters may change.\nEmbedded Weaviate is a new deployment model that runs a Weaviate instance from your application code rather than from a stand-alone Weaviate server installation.\nWhen Embedded Weaviate starts for the first time, it creates a permanent datastore in the location set in your persistence_data_path. When your client exits, the Embedded Weaviate instance also exits, but the data persists . The next time the client runs, it starts a new instance of Embedded Weaviate. New Embedded Weaviate instances use the data that is saved in the datastore.\nWhen you exit the client, the Embedded Weaviate instance also exits.\nTo pass additional configuration details to your embedded instance, use a custom connection:\nTo configure Embedded Weaviate, set these variables in your instantiation code or pass them as parameters when you invoke your client. You can also pass them as system environment variables. All parameters are optional.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This unit will provide you with an overview of the fundamentals of Weaviate. You will then learn about what vector database and vector search are. By the end of this unit, you will have a strong foundation of knowledge that will help you to effectively navigate the rest of the course."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/theory/hello_weaviate",
          "webPageMainText": "Welcome!\nThis is the beginning of your journey through the world of vectors with Weaviate. This unit will provide you with an overview of the fundamentals of Weaviate.\nYou'll first gain an understanding of what Weaviate is, and what it can do. You will then learn about what vector database and vector search are before going on to run Weaviate and perform vector searches yourself.\nBy the end of this unit, you will have a strong foundation of knowledge that will help you to effectively navigate the rest of the course, and for using Weaviate in your own projects.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A breakdown of the Long Context Retrieval Embedding Models from Stanford. They release 3 long context(2k/8k/32k) BERT-like encoder embedding models on HuggingFace. The models are only 80M params and outperform larger models (4-85x larger)"
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper16",
          "webPageMainText": "\nA breakdown of the Long Context Retrieval Embedding Models from Stanford!\ud83d\udca5 \nThey release 3 long context(2k/8k/32k) BERT-like encoder embedding models on HuggingFace\nThe models are only 80M params and outperform MUCH larger models (4-85x larger)\nAccessible via @togethercompute endpoints and integrated into @llama_index and @LangChainAI\nThey also release LoCo a long context retrieval benchmark.\nThey replace the Attention and MLP blocks in the transformer architecture with diagonal block matrix (Monarch Matrices -M2) operations which are hardware optimized and subquadratic in the sequence length - O(N^(1.5)) \nThis enables scaling sequence length and model parameters better.\nThese M2 models are trained for long context retrieval on a mixture of long and short context tasks data - surprisingly only training on long context doesn't work.\nUse a cosine similarity loss instead of the trusty supervised contrastive training loss. \nThis loss function. can be computed independently per datapoint i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Reranking seeks to improve search relevance by reordering the result set returned by a retriever with a different model. It computes a relevance score between the query and each data object, and returns the list of objects sorted from the most to the least relevant. With our reranker modules, you can conveniently perform multi-stage searches without leaving Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/reranking",
          "webPageMainText": "Reranking seeks to improve search relevance by reordering the result set returned by a retriever with a different model.\nReranking computes a relevance score between the query and each data object, and returns the list of objects sorted from the most to the least relevant. Computing this score for all (query, data_object) pairs would typically be prohibitively slow, which is why reranking is used as a second stage after retrieving the relevant objects first.\nAs the reranker works on a smaller subset of data after retrieval, different, potentially more computationally expensive approaches can be used to improve search relevance.\nWith our reranker modules, you can conveniently perform multi-stage searches without leaving Weaviate.\nIn other words, you can perform a search - for example, a vector search - and then use a reranker to re-rank the results of that search. Our reranker modules are compatible with all of vector, bm25, and hybrid searches.\nYou can use reranking in a GraphQL query "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Join Connor Shorten as he interviews Weaviate community users, leading machine learning experts, and explores Weaviates use cases from users and customers. We are beyond honored to feature Dai Vu from Google on this one, alongside Weaviated Co-Founder Bob van Luijt! We are super excited to share our 94th WeAviate podcast with Magdalen Dobson Manohar."
              }
            ]
          },
          "url": "https://weaviate.io/podcast",
          "webPageMainText": "Join Connor Shorten as he interviews Weaviate community users, leading machine learning experts, and explores Weaviate use cases from users and customers.\nWelcome to the 95th Weaviate Podcast! We are beyond honored to feature Dai Vu from Google on this one, alongside Weaviate Co-Founder Bob van Luijt!\nWe are super excited to share our 94th Weaviate podcast with Magdalen Dobson Manohar!\nSo pleased to publish our newest Weaviate podcast with Kyle Davis, the creator of RAGKit!\nOur 92nd episode of the Weaviate podcast with David de Matheu!\nWe are super excited to publish our latest Weaviate podcast with Tengyu Ma, Co-Founder of Voyage AI and Assistant Professor at Stanford University!\nOur 90th Weaviate Podcast with Chris Dossman! Self-Discover is a fascinating new algorithm from researchers at Google DeepMind and USC.\nHey everyone! Our 89th Weaviate Podcast on Matryoshka Representation Learning!\nJason Liu is the creator of Instructor, one of the world's leading LLM frameworks, particularly"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Multi-tenancy provides data isolation. Each tenant is stored on a separate shard. Data stored in one tenant is not visible to another tenant. Weaviate returns an error if you try to insert an object into a non-existent tenant. The auto-tenant feature is available from v1.25.0 for batch imports."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/multi-tenancy#update-tenant-activity-status",
          "webPageMainText": "Multi-tenancy provides data isolation. Each tenant is stored on a separate shard. Data stored in one tenant is not visible to another tenant. If your application serves many different users, multi-tenancy keeps their data private and makes database operations more efficient.\nMulti-tenancy is disabled by default. To enable multi-tenancy, set multiTenancyConfigin the collection definition:\nBy default, Weaviate returns an error if you try to insert an object into a non-existent tenant. To change this behavior so Weaviate creates a new tenant, set autoTenantCreation to true in the collection definition.\nThe auto-tenant feature is available from v1.25.0 for batch imports, and from v1.25.2 for single object insertions as well.\nSet autoTenantCreation when you create the collection, or reconfigure the collection to update the setting as needed.\nAutomatic tenant creation is useful when you import a large number of objects. Be cautious if your data is likely to have small inconsistencies or typo"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest##",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You can check whether the Weaviate instance is up using the is_live function. You can retrieve meta information about the Weviate instance using the meta function. This will print the server meta information to the console. After you have finished using the WeAviate client, you should close the connection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/setup_weaviate/communicate",
          "webPageMainText": "Here, we'll perform basic operations to communicate with Weaviate using the Python client library.\nYou can check whether the Weaviate instance is up using the is_live function.\nYou can retrieve meta information about the Weaviate instance using the meta function.\nThis will print the server meta information to the console. The output will look similar to the following:\nNote that this output is a little longer due to the additional details from the CLIP models.\nAfter you have finished using the Weaviate client, you should close the connection. This frees up resources and ensures that the connection is properly closed.\nWe suggest using a try-finally block as a best practice. For brevity, we will not include the try-finally blocks in the remaining code snippets.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector search returns the objects with most similar vectors to that of the query. To search a collection that has named vectors, use the target vector field to specify which named vector to search. To set a similarity threshold between the search and target vectors, define a maximum distance (or certainty)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/similarity#autocut",
          "webPageMainText": "Vector search returns the objects with most similar vectors to that of the query.\nTo search a collection that has named vectors, use the target vector field to specify which named vector to search.\nThe output is like this:\nUse the Near Text operator to find objects with the nearest vector to an input text.\nThe output is like this:\nUse the Near Image operator to find objects with the nearest vector to an image.\nThis example uses a base64 representation of an image.\nSee Image search for more information.\nIf you have an object ID, use the Near Object operator to find similar objects to that object.\nIf you have an input vector, use the Near Vector operator to find objects with similar vectors\nTo set a similarity threshold between the search and target vectors, define a maximum distance (or certainty).\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\nTo limit results to groups of similar distances to the query, use the autocut fil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The database schema defines how data is stored, organized and retrieved in Weaviate. A schema must be defined before data can be imported. This tutorial will guide you through the process of defining a schema for your data, including commonly used settings and key considerations. Let's begin with a simple example before diving into the details."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/starter-guides/schema",
          "webPageMainText": "This tutorial will guide you through the process of defining a schema for your data, including commonly used settings and key considerations.\nThe database schema defines how data is stored, organized and retrieved in Weaviate.\nA schema must be defined before data can be imported. We generally recommend defining as much of the schema manually, although Weaviate can also infer the schema during import if auto-schema feature is enabled.\nLet's begin with a simple example before diving into the details.\nThis example will create a simple collection called Question, with three properties (answer, question, and category), the text2vec-openai vectorizer and the generative-cohere module for RAG. It then retrieves the schema and displays it.\nThe returned configuration should look something like this:\nNote: results will vary depending on your client library.\nAlthough we only specified the collection name and properties, the returned schema includes much more information.\nThis is because Weaviate i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page includes benchmarking information. Use the weekly Newsquiz to test your knowledge of stories you saw on this page. At the bottom of the page, please share your feedback about our site and the content of this site. If you have any questions or feedback, let us know in the forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/contextionary/classification-benchmarks",
          "webPageMainText": "Benchmarks on this page refer to a specific model version, details about\neach version are contained here:\nFor additional information, try these sources.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use Explore to perform vector searches across multiple collections. The Explore function is disabled where multiple inference (e.g. text2vec-xxx) modules are enabled. Explore is not available on Weaviate Cloud as its clusters are pre-configured with multiple inference modules for AWS, Cohere, Google, OpenAI and so on."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/explore",
          "webPageMainText": "The Explore function is disabled where multiple inference (e.g. text2vec-xxx) modules are enabled.\nAs a result, Explore is not available on Weaviate Cloud (WCD) as its clusters are pre-configured with multiple inference modules for AWS, Cohere, Google, OpenAI and so on.\nUse Explore to perform vector searches across multiple collections. Note that Explore is currently not available in the gRPC API.\nFor Explore:\nThe Explore function has the following syntax:\nAn example query:\nThe result might look like this:\nThe nearText and nearVector operators work in Explore as they do in other queries. See search operators for more information.\nExplore queries can be combined with filters. See filters for more information.\nPagination (i.e. limit with offset) is not possible in Explore queries.\nBecause pagination is not possible in multidimensional storage, we recommend using moveTo and moveAwayFrom if further query refinement is sought. They work as they do in other queries. See search operators#near"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The key to improving vector search is to make sure that the vector representation of the object is fit for purpose. Unless you are inserting data with your own vectors, you will be using a Weaviate vectorizer module, and a model within that module, to generate vectors for your data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/which_search/strategies",
          "webPageMainText": "In addition to selecting the right search types, there are also strategies you can employ to improve the quality of your search results.\nLet's explore some of these strategies.\nThe key to improving vector search is to make sure that the vector representation of the object is fit for purpose, so as to suit the search needs.\nUnless you are inserting data with your own vectors, you will be using a Weaviate vectorizer module, and a model within that module, to generate vectors for your data.\nThe choice of vectorizer module and model is important, as it will determine what aspects of the data are captured in the vector representation, and how well the model is able to \"understand\" the data.\nFirst and foremost, you should select a vectorizer module that is best suited for your data type. For example, if you are working with text data, you should use the text2vec module, and if you are using image or multi-modal data, you should likely use the multi2vec module.\nWe will cover vectorizer select"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/batch",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector search returns the objects with most similar vectors to that of the query. To search a collection that has named vectors, use the target vector field to specify which named vector to search. To set a similarity threshold between the search and target vectors, define a maximum distance (or certainty)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/similarity",
          "webPageMainText": "Vector search returns the objects with most similar vectors to that of the query.\nTo search a collection that has named vectors, use the target vector field to specify which named vector to search.\nThe output is like this:\nUse the Near Text operator to find objects with the nearest vector to an input text.\nThe output is like this:\nUse the Near Image operator to find objects with the nearest vector to an image.\nThis example uses a base64 representation of an image.\nSee Image search for more information.\nIf you have an object ID, use the Near Object operator to find similar objects to that object.\nIf you have an input vector, use the Near Vector operator to find objects with similar vectors\nTo set a similarity threshold between the search and target vectors, define a maximum distance (or certainty).\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\nTo limit results to groups of similar distances to the query, use the autocut fil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This is a preview version of an article about chunking techniques in Git. We'll use Weaviate to search through the book and evaluate the impact of the techniques. Some sections are not yet complete - such as videos and quiz questions. Please check back later for the full version."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking/example_search",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nIn the preceding section, we imported multiple chapters of a book into Weaviate using different chunking techniques. They were:\nNow, we will use Weaviate to search through the book and evaluate the impact of the chunking techniques.\nSince the data comes from the first two chapters of a book about Git, let's search for various git-related concepts and see how the different chunking strategies perform.\nFirst of all, we'll retrieve information from our Weaviate instance using various search terms. We'll use a semantic search (nearText) to aim to retrieve the most relevant chunks.\nThe search is carried out as follows, looping through each chunking strategy by filtering our dataset. We'll obtain a couple of top results for each search term.\nUsing thes"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Humans have a remarkable ability to learn and build world models through the integration of multiple sensory inputs. Infants explore the world through their senses, touching, tasting, listening and observing objects and people around them. This sensory exploration helps them link different perspectives of the same experience to create a holistic understanding of their environment."
              }
            ]
          },
          "url": "https://weaviate.io/blog/multimodal-models",
          "webPageMainText": "\nHumans have a remarkable ability to learn and build world models through the integration of multiple sensory inputs. Our combination of senses work synergistically to provide us with rich and diverse information about our environment. By combining and interpreting these sensory inputs, we are able to form a coherent understanding of the world, make predictions, and acquire new knowledge very efficiently.\nThe process of learning through multi-sensory inputs begins from the early stages of human development. Infants explore the world through their senses, touching, tasting, listening, and observing objects and people around them. This sensory exploration helps them link different perspectives of the same experience to create a holistic understanding of their environment.\nThis fusion of multisensory data when learning new concepts is also partially responsible for why humans can learn with very few data points - making us great few-shot learners. Let's imagine you are trying to teach the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In January 2023, SeMI Technologies became Weaviate as we aligned with our customers. The entire Company will soon gather for the first time\u2026 in Italy! The company's All Hands sessions were once held in a small room in the back of the office. The company is now based in San Francisco, California."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/page/2",
          "webPageMainText": "When I arrived at Weaviate, our All Hands sessions were...\nIn January 2023, SeMI Technologies became Weaviate as we aligned...\nTaking time off at Weaviate\nGood design is good business\nThe case for Product Engineering\nThe entire Company will soon gather for the first time\u2026 in Italy!\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Filters can be used to precisely refine search results. You can filter by properties as well as metadata, and you can combine multiple filters with and or or conditions to further narrow down the results. This example finds entries in \"MovieMM\" based on their similarity to the query \"dystopian future\", only from those released after 2010."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_searches/filters",
          "webPageMainText": "Filters can be used to precisely refine search results. You can filter by properties as well as metadata, and you can combine multiple filters with and or or conditions to further narrow down the results.\nThis example finds entries in \"MovieMM\" based on their similarity to the query \"dystopian future\", only from those released after 2010. It prints out the title and release year of the top 5 matches.\nThis query is identical to that shown earlier for search, but with the addition of a filter. The filters parameter here takes an instance of the Filter class to set the filter conditions. The current query filters the results to only include those with a release year after 2010.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "RAG is the process of augmenting inputs to a Large Language Model (LLM) with context retrieved from a vector database. RAG applications are commonly used for chatbots and question-answering systems. The RAG pipeline is broken down into three components: 1. Indexing, 2. Retrieval, and 3. Generation."
              }
            ]
          },
          "url": "https://weaviate.io/blog/rag-evaluation",
          "webPageMainText": "\nRetrieval Augmented Generation (RAG) is picking up steam as one of the most popular applications of Large Language Models and Vector Databases. RAG is the process of augmenting inputs to a Large Language Model (LLM) with context retrieved from a vector database, like Weaviate. RAG applications are commonly used for chatbots and question-answering systems. \nLike any engineering system, evaluating performance is crucial to the development of RAG applications. The RAG pipeline is broken down into three components: 1. Indexing, 2. Retrieval, and 3. Generation. RAG Evaluation is tricky because of the series of interacting components and the strain of collecting test data. This article will present an exciting development in using LLMs to produce evaluations and the state of RAG components.\nTL;DR: We were inspired to write this blog post from our conversation with the creators of Ragas, Jithin James and Shauhul Es on the 77th Weaviate podcast. These new advances in using LLMs to evaluate RA"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Multi-factor authentication (MFA) increases the security of browser logins. MFA is not enabled by default. Use API keys to connect browser based client applications to WCD. For help with Serverless, Enterprise SaaS, and Bring Your Own Cloud accounts, contact Weaviate support."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/multi-factor-auth",
          "webPageMainText": "Multi-factor authentication (MFA) increases the security of browser logins. MFA is not enabled by default.\nTo enable MFA, follow these steps.\nAfter you configure MFA, WCD prompts you to supply the one-time authentication code each time you log in.\nTo disable MFA, contact support.\nIf you use a JavaScript or TypeScript client to connect a browser hosted application to Weaviate, do not enable MFA for that client's account.\nThere is no way to pass the the one-time authentication code to the application, so the application cannot connect to WCD.\nUse API keys to connect browser based client applications to WCD.\nFor help with Serverless, Enterprise SaaS, and Bring Your Own Cloud accounts, contact Weaviate support directly to open a support ticket.\nFor questions and support from the Weaviate community, try these resources:\nTo add a support plan, contact Weaviate sales.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Aggregate is a powerful function that allows you to combine information from multiple objects into a single result. Available properties in Aggregate differ according to data types of the property being queried. For example, the available properties for a String property are different from those for an Integer property or a cross-reference."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_1/aggregate",
          "webPageMainText": "Now that you have seen how to retrieve individual objects with Get, let's take a look at how to compile information with Aggregate.\nAggregate is a powerful function that allows you to combine information from multiple objects into a single result to get a quick overview of the results.\nWhile the overall structure of Aggregate queries is similar to Get queries, there are some important differences as the queries relate to sets of results.\nThe basic syntax for Aggregate queries is as follows:\nUnlike a Get query, available properties in Aggregate differ according to data types of the property being queried.\nThese reflect the possible operations that can be performed on different data types. For example, the available properties for a String property are different from those for an Integer property or a cross-reference.\nLet's try out some Aggregate queries.\nAs a reminder, our objects include the following schema:\nTake a look at this query:\nWhat kind of results do you expect to come back?\nN"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The code to access depends on whether you have authentication turned on, or off. For this unit, you will require your own instance of Weaviate. A free sandbox instance should be just fine. Follow the \"Get Started with WCD\" section on this page and come back."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/schema_and_imports/preparation",
          "webPageMainText": "For this unit, you will require your own instance of Weaviate.\nIf you do not have one, we recommend setting one up on the Weaviate Cloud (WCD). A free sandbox instance should be just fine.\nFollow the \"Get Started with WCD\" section on this page and come back.\nNow, let's make sure that you can access your Weaviate instance by following the example below.\nMake sure you know what your Weaviate instance address is - it should look like:\nYou can find it in your WCD dashboard.\nThe code to access depends on whether you have authentication turned on, or off. If you are not sure, go to your WCD dashboard and check what it says about \"Authentication\".\nIf authentication is on, you can instantiate your client as shown below.\nIf authentication is switched off in your instance, you do not need the authentication parameter.\nOnce your client is instantiated, you can confirm that you can write to your Weaviate instance by running the following code:\nYou should see a long alphanumeric string printed on y"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use these guides to manage data and perform CRUD operations in Weaviate. The guides cover these topics: If you have any questions or feedback, let us know in the user forum.  The guides are available in English, Spanish, French and Italian. For more information, visit the\u00a0Weaviate\u00a0website."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data",
          "webPageMainText": "Use these guides to manage data and perform CRUD operations in Weaviate.\nThe guides cover these topics:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn how to use Weaviate to retrieve objects based on their similarity. Use various query types such as an input text, vector, or object. You will also compare vector search with keyword search to compare and contrast the two techniques, before learning how to combine the two."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/theory/hello_weaviate/examples_1",
          "webPageMainText": "Let's take a look at a few more examples of what you can do with Weaviate.\nFirst, we will try vector searches by searching through our demo database. You will learn how to use Weaviate to retrieve objects based on their similarity, using various query types such as an input text, vector, or object.\nYou will also compare vector search with keyword search to compare and contrast the two techniques, before learning how to combine the two techniques through the use of filters.\nFor our first example, let's search our demo dataset. It contains a small sample of questions from the quiz show Jeopardy!.\nImagine that you're running a quiz night, and you want to get some questions about \"animals in movies\". In a traditional database you could look for word matches, perhaps something like:\nThis is a difficult query to write. Even worse, you would probably have to add the names of specific animals to the query as well.\nThe Weaviate query is much more intuitive. See what happens when we run the foll"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with Jina AI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps. These integrations empower developers to build sophisticated AI-driven applications with ease."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/jinaai",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nJina AI offers a wide range of models for natural language processing. Weaviate seamlessly integrates with Jina AI's APIs, allowing users to leverage Jina AI's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nJina AI's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with Jina AI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nJina AI embedding integration page\nThese integrations enable developers to leverage Jina AI's powerful models directly within Weaviate.\nIn turn, they simplify the process of building AI-d"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The multi2vec-palm module uses a Google multimodal embedding model to create vectors from text or images. This module enables the nearText and nearImage search operators. The module is only compatible with Google Vertex AI. It is not supported in Google AI Studio."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-palm",
          "webPageMainText": "The multi2vec-palm module uses a Google multimodal embedding model to create vectors from text or images\nThis module enables the nearText and nearImage search operators.\nmulti2vec-palm uses an external API.\nThis module is only compatible with Google Vertex AI. It is not compatible with Google AI Studio.\nThe module s not compatible with Auto-schema. Define your collections manually.\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use the multi2vec-palm module, enable it in your Docker Compose file. Edit your docker-compose.yml manually or use the Weaviate configuration tool to generate the file.\nThis module is only supported in Google Vertex AI. It is not supported in Google AI Studio.\nTo enable the Vertex AI API on your Google Cloud project, follow Google's instructions.\nStarting from v1.25.1 and v1.24.14, there are separate headers X-Google-Vertex-Api-Key and X-Google-Studio-Api-Key for Vertex AI users an"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The examples on this page demonstrate how to create individual objects in Weaviate. To create an object, specify the following:By default, auto-schema creates new collections and adds new properties. The same value always generates the same ID. Use deterministic IDs to avoid inserting duplicate objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/create",
          "webPageMainText": "The examples on this page demonstrate how to create individual objects in Weaviate.\nThis example creates an object in the JeopardyQuestion collection.\nTo create an object, specify the following:\nBy default, auto-schema creates new collections and adds new properties.\nWhen you create an object, you can provide a vector. (For specifying multiple, named vectors, see below.)\nWhen you create an object, you can specify named vectors (if configured in your collection).\nWhen you create an object, you can specify an ID.\nIf no ID is provided, Weaviate will generate a random UUID.\nYou can generate an ID based on your data object.\nObject IDs are not randomly generated. The same value always generates the same ID.Weaviate throws an error if you provide a duplicate ID. Use deterministic IDs to avoid inserting duplicate objects.\nYou can create an object with cross-references to other objects.\nSee How-to: Cross-references for more on working with cross-references.\nCurrently, geo-coordinate filtering i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is happy to announce our inclusion in the Forbes AI 50 2024 list. We\u2019re excited to share the details of our newly launched Weaviate Hero Program. Let\u2019s find out more about the Hero Program and the Weaviates we\u2019ve partnered with."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/announcement",
          "webPageMainText": "Weaviate is happy to announce our inclusion in the Forbes AI 50 2024 list!\nWe\u2019re excited to share the details of our newly launched Weaviate Hero Program! Let\u2019s find out more ...\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#pq-parameters",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#specify-vectorizer-settings",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The multi2vec-clip module enables Weaviate to obtain vectors locally from text or images using a CLIP model. It encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware. As of Weaviates v1.24.2, you can use multiple inference containers."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-clip#how-to-use",
          "webPageMainText": "The multi2vec-clip module enables Weaviate to obtain vectors locally from text or images using a CLIP model.\nmulti2vec-clip encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use multi2vec-clip, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nAs of Weaviate v1.24.2, you can use multiple inference containers with multi2vec-clip. This allows you to use different models for different collections by setting the inferenceUrl in the collection configuration.\nThis configuration enables multi2vec-clip, sets it as the default vectorizer, and sets the parameters for the Docker container, including setting it to use multi2vec-clip:sentence"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "When you prompt an LLM, RAG supplies relevant documents. A separate retrieval model computes the probability of each text chunk being relevant. Fine-tuning the LLM and retrieval model together can improve performance without requiring extensive data processing.Authors from Meta fine-tuned Llama 2 (65B parameters) and DRAGON+ a retriever, to create RA-DIT 65B."
              }
            ]
          },
          "url": "https://weaviate.io/papers/radit",
          "webPageMainText": "\nCan we finetune our LLM and retriever together to improve RAG performance?\nThis paper proposes a technique to do exactly that!\nWhen you prompt an LLM, RAG supplies relevant documents. A separate retrieval model computes the probability of each text chunk being relevant and provides the top chunks to the LLM. The LLM generates tokens based on the chunks, prompt, and previous tokens.\nFine-tuning LLMs and retrieval models together improves performance without extensive data processing, enabling better retrieval-augmented generation.\nLLMs aren't exposed to retrieval-augmented inputs during pretraining, limiting their ability to use retrieved text effectively. Fine-tuning the LLM and retrieval model together can improve performance without requiring extensive data processing.\nAuthors from Meta fine-tuned Llama 2 (65B parameters) and DRAGON+, a retriever, to create RA-DIT 65B. They fine-tuned Llama 2 on prompts with retrieved text and questions, and fine-tuned DRAGON+ to retrieve more relev"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's All Hands set-up has been overhauled to reflect the needs of the company. Weaviate has doubled in size in the last year and expects to grow again in the coming year. The new All Hands format is designed to be more informal and informal."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/how-a-values-driven-all-hands-helps-sustain-our-company-culture",
          "webPageMainText": "\nWeaviate continues to grow. All the more reason to ensure that our All Hands sessions contribute to preserving a valued work environment and sense of community.\nWhen I arrived at Weaviate, our All Hands sessions were mainly a way to spend time together as a team. Just a year ago, we could have an All Hands in which everyone was able to share how they were doing and what they were up to. However our company has doubled in size, and\u2013spurred by a recently completed Series B round and the realization that our vector database can function as a critical layer in a generative AI stack\u2013we expect to grow again in the coming year.\nThat change in scale means we have to reshape our All Hands because there are simply too many people for a loosely structured meeting to be practical. But beyond those practical concerns, our get-togethers don\u2019t only reflect our values, they also help to reinforce them.\nSo, I\u2019ve given our All Hands set-up a makeover.\nThe first step in any makeover or renovation projec"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#python-client-v3-api",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.24 is here! Here are the release highlights. Named vectors make your collections richer and more versatile. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-24-release#python-client",
          "webPageMainText": "Weaviate 1.24 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nNamed vectors make your collections richer and more versatile.\nStarting in 1.24, collections can have multiple named vectors. Each vector is independent. Each vector has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to fine tune interactions with your data.\nIn earlier versions, objects in your collections are limited to one vector. Now, you can vectorize meta data like titles and descriptions so that it is available for vector search. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata. A single object in a collection can have multiple named vectors.\nYou don't have to use multiple vectors in your collections, but if you do, adjust your queries to specify which vector you want to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Sign up below to learn how to build AI-native apps.Join an online workshop or meet us in-person at an event. We hold workshops for different experience levels.Stay up to date with the latest Weaviate trends and insights. Follow us on Twitter @Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/community/events",
          "webPageMainText": "We hold workshops for different experience levels.Sign up below to learn how to build AI-native apps.\nJoin an online workshop or meet us in-person at an event.\nIntro to Hybrid Search: Combining the power of keyword and vector search\nMultimodal Product Discovery: The next generation of search for ecommerce\nBuilding an AI-Native Foundation for Enterprise Applications\nConnect with the Weaviate Team and hundreds of developers and data engineers! Our community is here to help you with your projects and provide expert advice. Share how you build your apps with Weaviate.\nJoin Connor Shorten as he interviews Weaviate community users, leading machine learning experts, and explores Weaviate use cases from users and customers.\nStay up to date with the latest Weaviate trends and insights.\nGo to Blog\nWeaviate\u2019 search engine opens up new ways to query your data\nThis page is an introduction to Weaviate. We present a very high-level overview of Weaviate here, so that you have some context before movin"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#bm25",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#vectorizer",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The results are based on similarity of the vector embeddings between the query and the database object text. This can be done with a near vector query. The limit parameter here sets the maximum number of results to return. The returned object is an instance of a custom class. Its objects attribute is a list of search results."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_searches/vector",
          "webPageMainText": "In this scenario, we've added data objects and our own vectors. Accordingly, any similarity searches will also require a vector input. This can be done with a near vector query.\nThis example finds entries in \"Movie\" based on their similarity to the input vector and prints out the title and release year of the top 5 matches.\nThe results are based on similarity of the vector embeddings between the query and the database object text. In this case, the embeddings are input manually in the query.\nThe limit parameter here sets the maximum number of results to return.\nThe return_metadata parameter takes an instance of the MetadataQuery class to set metadata to return in the search results. The current query returns the vector distance to the query.\nThe returned object is an instance of a custom class. Its objects attribute is a list of search results, each object being an instance of another custom class.\nEach returned object will:\nThe query vector in this example is obtained similarly to how"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Mistral's APIs allows you to access their models' capabilities directly from Weaviate. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances. You must provide a valid Mistral API key to Weaviated for this integration."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/mistral/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Mistral's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use an Mistral generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model and your Mistral API key.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the Mistral generative model to generate outputs.\n\nYour Weaviate instance must be configured with the Mistral generative AI integration (generative-mistral) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Mistral API key to Weaviate for this integration. Go to Mistral to sign up and obtain an API key.\nProvide the API key to Weaviate using one of the following methods:\nConfigure a Weaviate"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#invertedindexconfig--stopwords-stopword-lists",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A vector embedding is an array of numbers, that is used to describe an object. The meaning of each value in the array, depends on what machine learning model we use to generate them. To judge how similar two objects are, we can compare their vector values, by using various distance metrics."
              }
            ]
          },
          "url": "https://weaviate.io/blog/distance-metrics-in-vector-search",
          "webPageMainText": "\nVector databases - like\u00a0Weaviate\u00a0- use\u00a0machine learning models\u00a0to analyze data and\u00a0calculate vector embeddings. The vector embeddings are\u00a0stored together with the data\u00a0in a database, and later are used to query the data.\nIn a nutshell, a vector embedding is an array of numbers, that is used to describe an object. For example, strawberries could have a vector\u00a0[3, 0, 1]\u00a0\u2013 more likely the array would be a lot longer than that.\nNote, the meaning of each value in the array, depends on what machine learning model we use to generate them.\nTo judge how similar two objects are, we can compare their vector values, by using various\u00a0distance metrics.\nIn the\u00a0context of vector search,\u00a0similarity measures\u00a0are a function that takes two vectors as input and calculates a distance value between them. The distance can take many shapes, it can be the geometric distance between two points, it could be an angle between the vectors, it could be a count of vector component differences, etc. Ultimately, we use"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/setup_weaviate",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate now supports the PaLM models for embeddings and generative search through two new modules. How to use OpenAI's embedding models trained with Matryoshka Representation Learning in a vector database like Weaviate. Learn how you can connect Weaviates to ChatGPT to generate customized responses."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/integrations",
          "webPageMainText": "How to use OpenAI's embedding models trained with Matryoshka Representation Learning in a vector database like Weaviate\nLearn how to vectorize ~50 million objects and ingest into Weaviate using Modal!\nAn end-to-end generative feedback loop demo using Weaviate, Ollama, Mistral and Snowflake\u2019s Snowpark Container Services!\nLearn how to build an application using Weaviate and Confluent\nAn introductory overview of LlamaIndex, the LLM framework\nDemo on how to ingest PDFs into Weaviate using Unstructured.\nWeaviate now supports the PaLM models for embeddings and generative search through two new modules.\nAn introduction to creating generative feedback loops with LLMs in Weaviate.\nA show-and-tell of how we created the Weaviate Retrieval Plugin for ChatGPT\nLearn about Auto-GPT and how to give it long-term memory with Weaviate!\nLearn how you can connect Weaviate to ChatGPT to generate customized responses.\nDid you know that Weaviate can summarize information during retrieval? Learn how you can su"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_collections",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transforming from a small band of visionaries, into a company. In order to stay true to our open-source spirit as we grow, we want to share that vision with a much larger group of people than just our team. That's the purpose of this blog. We think of it as a playbook on how run our company."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/our-mission-at-weaviate",
          "webPageMainText": "\nWe're moving towards our goal of creating a profitable, AI-first, open-source company around our vector database, Weaviate. With help from our investors, Weaviate is transforming from a small band of visionaries, into a company - yes, still a small one for now, but a growing one, united by a shared vision. In order to stay true to our open-source spirit as we grow, we want to share that vision with a much larger group of people than just our team. That's the purpose of this blog. We think of it as a meta-conversation about our company.\nThat's the purpose of this blog. We think of it as a playbook on how run our company.\nOur key audience is the community of developers using our open source solutions such as Weaviate, whether they are open-source users, Weaviate's customers, or others simply investigating our technology. Note that I don't say only users because every download is valuable. I'm sure that in some future post, we'll get into why even non-remunerative users help us to reach "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate allows object deletion by id or by a set of criteria. To delete objects, you must provide the collection name as well as identifying criteria (e.g. object id or filters) For multi-tenancy collections, you will also need to specify the tenant name when deleting objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/delete",
          "webPageMainText": "Weaviate allows object deletion by id or by a set of criteria.\nTo delete objects, you must provide the collection name as well as identifying criteria (e.g. object id or filters).\nFor multi-tenancy collections, you will also need to specify the tenant name when deleting objects. See Manage data: multi-tenancy operations for details on how.\nCollections act like namespaces, so two different collections could have duplicate IDs between them.\n\n\nPrior to Weaviate v1.14 you can manipulate objects without specifying the collection name. This method is deprecated. It will be removed in Weaviate v2.0.0.\nStarting in v1.20, you can have multi-tenant datasets. When multi-tenancy is enabled, the tenant name is required.\nAlways include the collection name, and, when enabled, the tenant name.\nTo delete by id, specify the collection name and the object id.\nTo delete objects that match a set of criteria, specify the collection and a where filter.\nThe ContainsAny / ContainsAll filters allow deletion of "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.24 is here! Here are the release highlights. Named vectors make your collections richer and more versatile. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-24-release#hnsw-and-binary-quantization",
          "webPageMainText": "Weaviate 1.24 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nNamed vectors make your collections richer and more versatile.\nStarting in 1.24, collections can have multiple named vectors. Each vector is independent. Each vector has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to fine tune interactions with your data.\nIn earlier versions, objects in your collections are limited to one vector. Now, you can vectorize meta data like titles and descriptions so that it is available for vector search. You can group things that are logically related, like a music video and a lyric sheet, in the same object. You don't have to create cross-references or manage shared metadata. A single object in a collection can have multiple named vectors.\nYou don't have to use multiple vectors in your collections, but if you do, adjust your queries to specify which vector you want to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model. To use this module, you must enable it in your Docker Compose file. For production use cases, we recommend using other modules that use a more modern, transformer-based architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-contextionary#module-endpoints-api-reference",
          "webPageMainText": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model.\nKey notes:\nAs a lightweight model, it is well suited for testing purposes.\nFor production use cases, we recommend using other modules that use a more modern, transformer-based architecture.\nThis module is not available on Weaviate Cloud.\nTo use text2vec-contextionary, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nContextionary:\nThis configuration enables text2vec-contextionary, sets it as the default vectorizer, and sets the parameters for the Contextionary Docker container.\nYou can configure how the module will behave in each class through the Weaviate schema.\nYou can set vectorizer behavior using the moduleConfig section under each class and property:\nIf you are using this module and are vectorizing the class or property name, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Core uses a typical Test Pyramid approach. The tests are grouped into the following three levels:Unit tests test the smallest possible unit, mostly a struct in golang. Unit tests are designed to validate the business logic and not the internals.Integration tests test anything that crosses a boundary."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/tests",
          "webPageMainText": "Weaviate Core follows a typical Test Pyramid approach. As Weaviate itself contains no graphical user interface (GUI), the highest level tests test the user journeys at an API level.\nThe tests are grouped into the following three levels:\nUnit tests test the smallest possible unit, mostly one \"class\" (usually a struct in golang) with its methods. Unit tests are designed to validate the business logic and not the internals.\nUnit tests are stateless and do not depend on any external programs or runtime other than the Golang-built tools. (Note: We do make use of the stretchr/testify packages. However, they are installed with any other code-level dependency and don't require running dedicated software).\nThis makes tests fast to execute, easy to adapt and easy to run with third-party tools like code watchers.\nIntegration tests test anything that crosses a boundary. A boundary could be the dependence on an external party (e.g. a third-party database) or an independent custom tool, such as the "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Offering is an open-sourced vector Offering that permits customers to store data objects and vector embeddings. To be eligible to register for a Weaviate account, you must review and accept the terms of this Weaviates Terms of Service (this \u201cAgreement\u201d or these \u201cTerms\u201d)"
              }
            ]
          },
          "url": "https://weaviate.io/service/weaviate-general-terms-of-service",
          "webPageMainText": "Last Updated: May 2024\nThank you for using the Weaviate Offering (as defined below), an open-sourced vector Offering that permits customers to store data objects and vector embeddings (the \u201cWeaviate Offering\u201d) which is offered as a SaaS-based product (the \u201cServerless Offering\u201d).\nTo be eligible to register for a Weaviate account and use the Weaviate Offering, you must review and accept the terms of this Weaviate Terms of Service (this \u201cAgreement\u201d or these \u201cTerms\u201d) by clicking the terms of service checkbox or other mechanism provided within the online registration process. PLEASE REVIEW THESE TERMS CAREFULLY. BY ACCEPTING THESE TERMS OR USING THE WEAVIATE OFFERING, YOU AGREE TO THESE TERMS AND CONDITIONS WITH WEAVIATE LLC IF YOU RESIDE OR ARE ESTABLISHED IN THE UNITED STATES OF AMERICA, OR WITH WEAVIATE B.V. (\u201cWeaviate\u201d) IF YOU RESIDE OR ARE ESTABLISHED OUTSIDE THE UNITED STATES OF AMERICA. IF YOU DO NOT AGREE TO BE BOUND BY THESE TERMS, YOU SHOULD NOT USE THE WEAVIATE OFFERING.\nIn this "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#mutability",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Service Level Agreement delineates the service levels for Weaviate's vector database services. The infrastructure of the services is designed for Normal Use. Any usage beyond Normal Use may lead to a degradation of service quality and availability. Issues accessing the service due to application errors (like misuse, misconfiguration, etc.) are excluded from Availability calculations."
              }
            ]
          },
          "url": "https://weaviate.io/sla",
          "webPageMainText": "Introduction\nThis Service Level Agreement (\"SLA\") delineates the service levels for Weaviate's vector database services, including the Standard and Enterprise tiers valid during the term of the Agreement. The infrastructure of the services is designed for Normal Use, and the Availability is applicable solely for Normal Use of the services. Any usage beyond Normal Use may lead to a degradation of service quality and availability. Issues accessing the service due to application errors (like misuse, misconfiguration, etc.) are excluded from Availability calculations and are not considered downtime as these are the responsibility of the Customer.\nNormal Use refers to the utilization of the service within the parameters outlined in our official documentation. The specifics of these parameters, including any limitations or restrictions, are detailed in the documentation available to all customers. In instances where a customer wishes to operate outside of these parameters, arrangements can b"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn about the new hybrid search feature that enables you to combine dense and sparse vectors to deliver the best of both search methods. A gentle introduction to Large Language Models (LLMs) - how they work and what they learn. Learn about the vision of the AI-First Database Ecosystem, which drives the R&D of the databases."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/concepts/page/3",
          "webPageMainText": "A gentle introduction to Large Language Models (LLMs) - how they work and what they learn.\nMachine learning models can create beautiful and novel images. Learn how Diffusion Models work and how you could make use of them.\nGet an intuitive understanding of what exactly vector embeddings are, how they're generated, and how they're used in semantic search.\nEver wonder how Weaviate turns objects into vectors, behind-the-scenes? Find out in this post!\nLearn about the new hybrid search feature that enables you to combine dense and sparse vectors to deliver the best of both search methods.\nLearn about the hardware, software and performance metric specifications behind our ~1B object import of the Sphere dataset into Weaviate.\nLearn more about the differences between vector libraries and vector databases!\nWeaviate introduces Ref2Vec, a new module that utilises Cross-References for Recommendation!\nLearn about the vision of the AI-First Database Ecosystem, which drives the R&D of the databases o"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this unit, you have learned how to query Weaviate. You have also learned how certain search operators are used, and how filtering works. In the next module, we will learn how to build a Weaviates instance, from schema creation to data import. Now, you should be able to:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_1/wrap_up",
          "webPageMainText": "In this unit, you have acquired valuable knowledge on querying Weaviate to retrieve the right objects or aggregate information effectively. We dived deep into various search operators available in Weaviate, such as nearVector, nearObject, and nearText, and filters that can be applied to refine your search results by focusing on specific criteria, enabling you to extract more accurate and relevant information.\nYou have also learned some of the key principles around how Weaviate applies these operators to perform searches. You have learned how certain search operators are used, and how filtering works.\nNow that you are armed with knowledge about how to query Weaviate, in the next module we will learn how to build a Weaviate instance, from schema creation to data import.\nNow, you should be able to:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a free, open-source search engine. It uses the Get and Aggregate functions to search for objects. In this unit, we will look at how Weaviate performs a vector search. We will also look at various filters such as where, limit and offset."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_1/inside_queries_1",
          "webPageMainText": "In this unit, we have looked at various ways to construct a vector search.\nWe started by learning how to use Get and Aggregate vector search functions, adding search operators such as nearVector, nearObject and nearText, before wrapping up with various filters such as where, limit and offset.\nNow let's stop to take a look at how these searches are actually performed, starting with the vector search process.\nAs the name suggests, vector search relies on vectors to perform its operations. When you perform a vector search in Weaviate, regardless of whether nearVector, nearObject or nearText is used, the input is converted to a vector.\nThe input vector is then compared to the stored vectors in Weaviate to return the most relevant objects.\nFor queries using the nearVector operator, Weaviate simply takes the provided vector and performs the vector search.\nFor queries such as nearObject and nearText where the vector is not directly provided, Weaviate obtains the vector using a suitable method"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/objects",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an AI-native vector database, as a fully-managed SaaS offering. Best for nimble teams at all stages of building. Pricing is based on dimensions stored and chosen SLA tier. The exact calculation can be found in the FAQ (not inclusive of discounts and taxes)."
              }
            ]
          },
          "url": "https://weaviate.io/services/serverless",
          "webPageMainText": "The easiest way to get started with Weaviate. All the power of our AI-native vector database, as a fully-managed SaaS offering. Best for nimble teams at all stages of building.\nProduct Quantization (PQ) and Binary Quantization (BQ) optional\nOur pricing is based on dimensions stored and chosen SLA tier. The exact calculation can be found in the FAQ (not inclusive of discounts and taxes).\nAll Packages include:\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $25/mo\n$0.095\n\n1bd\n2bd\n3bd\n5bd\nfrom $135/mo\n$0.145\n\n4h (24/7)\n8h (24/7)\n1bd\n2bd\nfrom $450/mo\n$0.175\n\n1h (24/7)\n4h (24/7)\n8h (24/7)\n1bd\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $25/mo\n$0.095\n\n1bd\n2bd\n3bd\n5bd\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $135/mo\n$0.145\n\n4h (24/7)\n8h (24/7)"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You have completed this course on tokenization for the inverted index. There are many more resources available to help you continue your learning journey. For non-English texts, especially those which do not rely on spaces between words, try the trigram or gse tokenization methods which were added in Weaviate v1.24."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/tokenization/next_steps",
          "webPageMainText": "Congratulations! You have completed this course on tokenization for the inverted index. We hope you found it helpful and informative.\nThere are many more resources available to help you continue your learning journey.\nAs a reminder, for non-English texts, especially those which do not rely on spaces between words, try the trigram or gse tokenization methods which were added in Weaviate v1.24 for such cases.\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn).\nSee you soon! \ud83d\udc4b\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Dynamic indexing is an experimental feature. Use with caution."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/vector-index#configure-semantic-indexing",
          "webPageMainText": "Vector indexes facilitate efficient, vector-first data storage and retrieval.\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nAvailable starting in v1.25. Dynamic indexing is an experimental feature. Use with caution.\nUse these parameters to configure the index type and their properties. They can be set in the collection configuration.\nGenerally, the hnsw index type is recommended for most use cases. The flat index type is recommended for use cases where the data the number of objects per index is low, such as in multi-tenancy cases."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The model is trained to predict the next token for trillions of tokens. The base model can be finetuned for dialogue - turning the base model into a chatbot. Human labelers are asked to pick good vs. bad responses and this data is used to train a model."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper20",
          "webPageMainText": "\nA Simple Overview of the LLM Training Steps:\ud83d\udd21\nUnsupervised Pretraining: \nHigh quantity, low quality data\nThe model is trained to predict the next token for trillions of tokens.\nProduces what is called the foundation or base model.  \nSupervised Finetuning:\nLow quantity, high quality {prompt, response}\nEnables the model to be finetuned for dialogue - turning the base model into a chatbot\nOften referred to as instruction tuning\nReinforcement Learning from Human Feedback (RLHF): - lots of innovation going on here (will cover DPO, PTO, and KTO soon)\nThis is a two-step process:\na. Train a reward model to act as a scoring function:\nThis model will take in a prompt + response and provide a score of how good it is.\nHuman labelers are asked to pick good vs. bad responses and this data is used to train a model.\nb. Optimize LLM to generate responses for which the reward model will give high scores. \nUse an iterative procedure to update a part of the model such that:\nSpecifically for this phase it"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Pagination is not a cursor-based implementation. This has the following implications: The autocut function limits results based on discontinuities in the result set. The query stops returning results after the specified number of jumps. The Get and Explore functions support offset. For more details, see performance considerations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-operators#performance-considerations",
          "webPageMainText": "Functions such as limit, autocut, and sort modify queries at the class level.\nThe limit argument restricts the number of results. These functions support limit:\nTo return sets of results, \"pages\", use offset and limit together to specify a sub-set of the query response.\nFor example, to list the first ten results, set limit: 10 and offset: 0. To display the next ten results, set offset: 10. To continue iterating over the results, increase the offset again. For more details, see performance considerations\nThe Get and Explore functions support offset.\nPagination is not a cursor-based implementation. This has the following implications:\nThe autocut function limits results based on discontinuities in the result set. Specifically, autocut looks for discontinuities, or jumps, in result metrics such as vector distance or search score.\nTo use autocut, specify how many jumps there should be in your query. The query stops returning results after the specified number of jumps.\nFor example, conside"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "It is also possible to add a cross-reference property to an existing collection definition. This requires adding reference properties in both directions, and adding two cross-references per object pair. Use cross- references to establish directional relationships between collections. Use the reference property in the collection definition before adding cross-References to it."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/cross-references#retrieve-cross-references",
          "webPageMainText": "Use cross-references to establish directional relationships between collections.\nNotes:\nInclude the reference property in the collection definition before adding cross-references to it.\nIt is also possible to add a cross-reference property to an existing collection definition.\nSpecify a cross-reference when creating an object.\nSpecify the required id and properties for the source and the target.\nThis requires adding reference properties in both directions, and adding two cross-references per object pair (from A -> to B and from B -> to A).\nCreate the JeopardyCategory collection:\nCreate the JeopardyQuestion collection including the reference property to JeopardyCategory:\nModify JeopardyCategory to add the reference to JeopardyQuestion:\nAnd add the cross-references:\nWeaviate allows creation of multiple cross-references from one source object.\nCross-references can be read as part of the object.\nDeleting a cross-reference with the same parameters used to define the cross-reference.\nWhat ha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#nearvector",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You are welcome to implement your own ideas and contribute code to Weaviate. We love to hear your ideas. Suggestions are tracked as GitHub issues, such as these in [Weaviate core] (https://github.com/weaviate/weAViate/issues)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/getting-started/suggesting-enhancements",
          "webPageMainText": "We love to hear your ideas.\nHere are some guidelines for suggesting enhancements. They are designed to make it easier for the maintainers and the community to understand your proposal, which will make it more likely to be adopted.\nSuggestions are tracked as GitHub issues, such as these in [Weaviate core]](https://github.com/weaviate/weaviate/issues). Check first for a duplicate WIP (work in progress) issue. If not, create an issue in the relevant GitHub repository with the following:\nYou are welcome to implement your own ideas and contribute code to Weaviate! We love to hear your ideas. Feel free to reach out to us and the wider community on the forum to discuss them before you get started.\nIf you want to implement your ideas, or do some work on the Weaviate code base, follow these instructions to create a local development environment.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/resources#the-role-of-memory",
          "webPageMainText": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. While you design you system, keep in mind CPU and memory management. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role.\nYou can set environment variables to manage Weaviate's resource usage, as to prevent Weaviate from using all available resources. The following environment variables are available:\nLIMIT_RESOURCES: When set to true, Weaviate automatically limits its resource usage. It sets memory usage to 80% of the total memory and uses all but one CPU core. It overrides any GOMEMLIMIT values but respects GOMAXPROCS settings.\nGOMEMLIMIT: This sets the memory limit for the Go runtime, which should be around 10-20% of the total memory available for Weaviate. It controls the aggressiveness of the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A vector is a series of numbers like [1, 0] or [0.513, 0.155, ...] Vectors like these are used to capture meaning. Modern machine learning models such as GPT-x use vectors to represent some \"essence\", or \"meaning\" of objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/overview_vectors",
          "webPageMainText": "We've covered that Weaviate is a vector database, and that a vector search is similarity-based. But, what is a vector?\nA vector in this context is just a series of numbers like [1, 0] or [0.513, 0.155, 0.983, ..., 0.001, 0.932]. Vectors like these are used to capture meaning.\nThis might seem like an odd concept. But in fact, you may have already used vectors to capture meaning without realizing it. If you have tried photo editing, or used MS Paint you might have encountered the RGB color system.\nThe RGB system uses groups of three numbers to represent colors. For example:\nIn these examples, each number can be thought of as a dial for how red, green or blue a color is.\nNow, imagine having hundreds, or even thousands, of these dials. That\u2019s how vectors are used to represent meaning. Modern machine learning models such as GPT-x, or those used with Weaviate, use vectors to represent some \"essence\", or \"meaning\" of objects. This can be done for any object type, such as text, code, images, v"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Core uses a typical Test Pyramid approach. The tests are grouped into the following three levels:Unit tests test the smallest possible unit, mostly a struct in golang. Unit tests are designed to validate the business logic and not the internals.Integration tests test anything that crosses a boundary."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/tests#unit-tests",
          "webPageMainText": "Weaviate Core follows a typical Test Pyramid approach. As Weaviate itself contains no graphical user interface (GUI), the highest level tests test the user journeys at an API level.\nThe tests are grouped into the following three levels:\nUnit tests test the smallest possible unit, mostly one \"class\" (usually a struct in golang) with its methods. Unit tests are designed to validate the business logic and not the internals.\nUnit tests are stateless and do not depend on any external programs or runtime other than the Golang-built tools. (Note: We do make use of the stretchr/testify packages. However, they are installed with any other code-level dependency and don't require running dedicated software).\nThis makes tests fast to execute, easy to adapt and easy to run with third-party tools like code watchers.\nIntegration tests test anything that crosses a boundary. A boundary could be the dependence on an external party (e.g. a third-party database) or an independent custom tool, such as the "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud. Use WCD to simplify development and confidently deploy enterprise-ready AI applications. WCD is built on Weaviate core. They share the same technology, and offer the same great features."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/weaviate-cloud-services",
          "webPageMainText": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud.\nWCD manages the infrastructure so you can focus on innovation. Use WCD to simplify development and confidently deploy enterprise-ready AI applications.\nWeaviate is more than just a vector database. Weaviate is a scalable, flexible platform. The core, open source project offers vector search, keyword, and hybrid search. It has a plugable architecture to connect with ML models and tools to help you build scalable AI applications.\nWCD is built on Weaviate core. They share the same technology, and offer the same great features. In addition, WCD handles the work of hosting your Weaviate instance. This gets you up and running fast and lets you focus on your application. WCD takes care of the operational details so you don't have to.\nThese pages document the WCD user interface (UI) and WCD specific operational features. For information about the Weaviate database, client APIs, third-party modules, and other features, see th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "NVIDIA published a new paper examining how well very large finetuned LLMs with longer context lengths compare to shorter context length RAG supported LLMs. The main finding was that \"retrieval can significantly improve the performance of LLMs regardless of their extended context window sizes\""
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper-1",
          "webPageMainText": "\nFine-tuned larger language models and longer context lengths eliminate the need for retrieval from external knowledge/vector databases, right? ... Not quite!!\nNVIDIA asked the same question last month! \nThey published a new paper examining how well very large finetuned LLMs with longer context lengths compare to shorter context length RAG supported LLMs. They explore two main questions:\nIn short, they found:\nThe main finding presented in the paper was that \"retrieval can significantly improve the performance of LLMs regardless of their extended context window sizes\". \nSome more details: \nRAG is more important than context windows: a LLM with 4K context window using simple retrieval-augmentation at generation can achieve comparable performance to finetuned LLM with 16K context window.\nRAG is also faster: Augmenting generation with retrieval not only performs better by requiring significantly less computation and is much faster at generation.\nRAG works even better as parameter count inc"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Sydney Opera House is one of the most famous buildings in the world. It was designed by Danish architect J\u00f8rn Utzon in the 1950s. The Opera House was officially opened by Queen Elizabeth II on 20 October 1973. It is now one of Australia's most popular tourist attractions."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/examples_2",
          "webPageMainText": "You can do a lot more with Weaviate than simply retrieve static information.\nLet's take a look at a couple of examples where we do more than simply retrieve objects from the database.\nWe will extract information from this Wikipedia entry.\nThe Sydney Opera House is a multi-venue performing arts centre in Sydney. Located on the foreshore of Sydney Harbour, it is widely regarded as one of the world's most famous and distinctive buildings and a masterpiece of 20th-century architecture. Designed by Danish architect J\u00f8rn Utzon, but completed by an Australian architectural team headed by Peter Hall, the building was formally opened by Queen Elizabeth II on 20 October 1973 after a gestation beginning with Utzon's 1957 selection as winner of an international design competition. The Government of New South Wales, led by the premier, Joseph Cahill, authorised work to begin in 1958 with Utzon directing construction. The government's decision to build Utzon's design is often overshadowed by circums"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Machine learning models typically output vectors and common search queries involve finding the closest set of related vectors. The amount of unstructured data that companies and users need to search through is massive. The number of objects is often in the high millions or even billions of data points. A primitive brute-force comparison can no long long be used."
              }
            ]
          },
          "url": "https://weaviate.io/blog/crud-support-in-weaviate",
          "webPageMainText": "\nWith the rising popularity of machine learning models, the demand for vector similarity search solutions has also increased dramatically. Machine learning models typically output vectors and common search queries involve finding the closest set of related vectors. For example, for a text-based vector search the search query \"landmarks in Paris\" would be encoded to a vector, it is then the job of the vector database to find the documents with the vector closest to this query. This might be a document with the title \"Eiffel Tower\" whose vector matched the search vector most closely.\nSuch a vector similarity comparison is computationally trivial if there are very few, say less than 10,000 objects to be searched through. That is not a very realistic situation, however. The amount of unstructured data that companies and users need to search through is massive. The number of objects is often in the high millions or even billions of data points. A primitive brute-force comparison can no long"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with AWS's SageMaker and Bedrock APIs allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/aws/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with AWS's SageMaker and Bedrock APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an AWS embedding model, and Weaviate will generate embeddings for various operations using the specified model and your AWS API credentials. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the AWS vectorizer integration (text2vec-aws) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide access key based AWS credentials to Weaviate for these integrations. Go to AWS to sign up and obtain an AWS access key ID and a corresp"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Many embedding models and large language models have shown great benefits, especially in English-centric contexts. semantic search and Generative AI applications need to be able to handle languages other than English. Many language models with multilingual capabilities have already been released. This blog explores the challenges of non-English languages, such as the necessity of capable language models."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-non-english-languages",
          "webPageMainText": "\nRecently, many embedding models and large language models (LLMs) have shown great benefits, especially in English-centric contexts. As English is the most spoken language in the world, many language models excel in English. However, as semantic search and Generative AI applications need to be able to handle languages other than English, many language models with multilingual capabilities have already been released.\nThis blog is inspired by a recent question in our forum asking if you can use Weaviate with the Japanese language.\n\nGenerally speaking: Yes, using a Weaviate vector database for semantic and generative search in non-English languages is possible if the embedding models and LLMs used support your language of choice.\nThis blog explores how you can use Weaviate in your search and generative AI applications with non-English languages. Specifically, this blog discusses the challenges of non-English languages, such as the necessity of capable language models and the intricacies o"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The technology that powers ChatGPT and related language models has actually been around for some time before then. In 2019, SeMi Technologies was born, later renamed to Weaviate. We\u2019ve been building and iterating on a highly performant, open source, AI Native vector database that\u2019s closely coupled with language models."
              }
            ]
          },
          "url": "https://weaviate.io/blog/enterprise-use-cases-weaviate",
          "webPageMainText": "\nThe world was taken by storm by OpenAI ChatGPT in November of 2022. The interesting thing about this is that the technology that powers ChatGPT and related language models has actually been around for some time before then and was originally discussed in this scientific paper, released by Google, in 2017. It was also around this time that we, at Weaviate, began exploring the representations of data in different formats that carried semantic meaning to these transformer models, as described by Google\u2019s paper. If you check out the Weaviate GitHub repository, you\u2019ll see that we began leveraging semantic relationships of vector embeddings as early as the publication of \u201cAttention is All You Need\u201d from Google. In 2019, SeMi Technologies was born, later renamed to Weaviate, and since then we\u2019ve been building and iterating on a highly performant, open source, AI Native vector database that\u2019s closely coupled with language models of your choosing.\n\nThe debut of ChatGPT kicked off a wave of inn"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative-aws performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance. You must provide access key based AWS credentials to use the API. You need to input both a query and a prompt (for individual responses) or a task (for all responses)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/generative-aws",
          "webPageMainText": "You must provide access key based AWS credentials to use the API, including an AWS access key and a corresponding AWS secret access key. You can set them as environment variables, or provide them at query time.\ngenerative-aws performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance.\nThe module works in two steps:\nYou can use the Generative AWS module with any other upstream modules. For example, you could use text2vec-cohere, text2vec-huggingface or text2vec-openai to vectorize and query your data, but then rely on the generative-aws module to generate a response.\nThe generative module can perform RAG for:\nYou need to input both a query and a prompt (for individual responses) or a task (for all responses).\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use generative-aws, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If not specified explicitly, the default distance metric in Weaviate iscosine. It can be set in the vectorIndexConfig field as part of the schema to any of the following types: larger distance values indicate lower similarity. If you're missing your favorite distance type and would like to contribute it, we'd be happy to review your PR."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/distances#distance-vs-certainty",
          "webPageMainText": "If not specified explicitly, the default distance metric in Weaviate is\ncosine. It can be set in the vectorIndexConfig field as part of the schema (example) to any of the following types:\nIn all cases, larger distance values indicate lower similarity. Conversely, smaller distance values indicate higher similarity.\nIf you're missing your favorite distance type and would like to contribute it to Weaviate, we'd be happy to review your PR.\nOn a typical Weaviate use case the largest portion of CPU time is spent calculating vector distances. Even with an approximate nearest neighbor index - which leads to far fewer calculations - the efficiency of distance calculations has a major impact on overall performance.\nYou can use the following overview to find the best possible combination of distance metric and CPU architecture / instruction set.\nIf you like dealing with Assembly programming, SIMD, and vector instruction sets we would love to receive your contribution for one of the combinations t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate modules are used to extend the vector database with vectorizers or functionality that can be used to query your dataset. With the release of Weaviate v1.2, we have introduced the use of transformers (DistilBERT, BERT, RoBERTa, Sentence-BERT) to vectorize and search through your data."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-2-transformer-models",
          "webPageMainText": "\nIn the v1.0 release of Weaviate (docs \u2014 GitHub) we introduced the concept of modules. Weaviate modules are used to extend the vector database with vectorizers or functionality that can be used to query your dataset. With the release of Weaviate v1.2, we have introduced the use of transformers (DistilBERT, BERT, RoBERTa, Sentence-BERT, etc) to vectorize and semantically search through your data.\nA transformer (e.g., BERT) is a deep learning model that is used for NLP tasks. Within Weaviate the transformer module can be used to vectorize and query your data.\nBy selecting the text-module in the Weaviate configuration tool, you can run Weaviate with transformers in one command. You can learn more about the Weaviate transformer module here.\n\nWeaviate configurator \u2014 selecting the Transformers module\nYou can also use custom transformer models that are compatible with Hugging Face's AutoModel and AutoTokenzier. Learn more about using custom models in Weaviate here.\nWeaviate now allows you to "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This section includes queries using the OpenAI inference endpoint. If you don't already have an OpenAI account, we recommend creating one. At the time of writing, OpenAI provides trial credits which should be sufficient for these exercises. Create a client object for persistent access to your Weaviate instance. Set the following parameters:Host URL (required)Authentication details (optional)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/hands_on",
          "webPageMainText": "This section includes queries using the OpenAI inference endpoint. If you don't already have an OpenAI account, we recommend creating one. At the time of writing, OpenAI provides trial credits which should be sufficient for these exercises.\nNow that you've set up your own Weaviate instance and installed a client, let's get hands-on with Weaviate.\nCreate a client object for persistent access to your Weaviate instance. You can set the following parameters:\nHost URL (required)\nThis is the location of your Weaviate instance. The URL resembles\nAuthentication details (optional)\nIf authentication is enabled, you MUST provide your authentication information here. Otherwise the Weaviate instance will not provide access.\nAdditional headers (optional)\nYou can provide additional headers. These headers provide API keys for inference services such as Cohere, Hugging Face or OpenAI.\nA fully configured client resembles this sample code, edited to match your Weaviate instance.\nNow, connect to your Weav"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Dynamic indexing is an experimental feature. Use with caution."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/vector-index#how-to-configure-hnsw",
          "webPageMainText": "Vector indexes facilitate efficient, vector-first data storage and retrieval.\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nAvailable starting in v1.25. Dynamic indexing is an experimental feature. Use with caution.\nUse these parameters to configure the index type and their properties. They can be set in the collection configuration.\nGenerally, the hnsw index type is recommended for most use cases. The flat index type is recommended for use cases where the data the number of objects per index is low, such as in multi-tenancy cases."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You have completed this introductory course on Weaviate. You may be interested in exploring our documentation or the Academy for more advanced courses. We are constantly improving our documentation, so keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/next_steps",
          "webPageMainText": "Congratulations! You have completed this introductory course on Weaviate.\nNow that you have completed this course, you may be interested in exploring our documentation or the Academy for more advanced courses.\nSome of our more popular resources include:\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn).\nSee you soon! \ud83d\udc4b\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-cohere module enables Weaviate to obtain vectors using Cohere. The module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways. We suggest you only set any given parameter in one place to avoid confusion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-cohere",
          "webPageMainText": "The text2vec-cohere module enables Weaviate to obtain vectors using Cohere.\nKey notes:\nThe module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways.\nWhere the same parameter can be set in multiple ways, setting it at query-time through the HTTP request header (if possible) will have the highest precedence.\nWe suggest you only set any given parameter in one place to avoid confusion.\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use text2vec-cohere, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables text2vec-cohere, sets it as the default vectorizer, and sets the API keys.\nYou can configure how the module will behave in each class through the Weaviate schema.\nThe following "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#auto-schema",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate will make the Weaviate Offering available to Customer pursuant to this Agreement, any applicable Exhibits, and the applicable Order Form. Customer shall pay those amounts due and not disputed in good faith within thirty (30) days of the date of receipt of the applicable invoice."
              }
            ]
          },
          "url": "https://weaviate.io/service/weaviate-enterprise-agreement-us",
          "webPageMainText": "Last Updated: May, 2024\nProvision of Weaviate Offering.\nSubject to the terms and conditions of this Agreement, Weaviate will make the Weaviate Offering available to Customer pursuant to this Agreement, any applicable Exhibits to this Agreement, and the applicable Order Form.\nCustomer Responsibilities. \nOpen Source Software.\nThe Weaviate Offering may include individual open source software components, each of which has its own copyright and its own applicable license conditions. These open-source software components are licensed under the terms of the applicable open-source license conditions and/or copyright notices.\nFees.\nCustomer will pay Weaviate the fees set forth in the applicable Order Form. Customer shall pay those amounts due and not disputed in good faith within thirty (30) days of the date of receipt of the applicable invoice unless a specific date for payment is set forth in such Order Form, in which case payment will be due on the date specified. Except as otherwise specifi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#specify-a-distance-metric",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#which-vector-index-is-right-for-me",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This article gives a comprehensive overview of commonly used evaluation metrics in search and recommendation systems. As recommendation systems can be viewed as a special case of information retrieval or search systems, similar metrics apply to both. We will use the pytrec_eval Python package to showcase how you can evaluate your retrieval or recommendation pipelines in your cod."
              }
            ]
          },
          "url": "https://weaviate.io/blog/retrieval-evaluation-metrics",
          "webPageMainText": "\nHow do you evaluate the quality of your search results in a Retrieval-Augmented Generation (RAG) pipeline or in a recommendation system? While many new metrics are currently emerging to evaluate the quality of retrieved contexts for RAG pipelines, there are already established metrics to objectively measure information retrieval systems.\nThis article gives a comprehensive overview of commonly used evaluation metrics in search and recommendation systems. As recommendation systems can be viewed as a special case of information retrieval or search systems, similar metrics apply to both.\nTo explain how each of the following metrics is calculated, this article uses a minimal example dataset of eight pastries - to stay in line with the bagel example our colleagues used in their recent discussion on how to choose and evaluate an embedding model - as shown below.\n\nWe will use the pytrec_eval Python package to showcase how you can evaluate your retrieval or recommendation pipelines in your cod"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A 'single prompt' generation wil perform RAG queries on each retrieved object. This is useful when you want to transform each object separately, with the same prompt. This example finds entries in \"MovieMM\" based on their similarity to this image of the International Space Station. Then, instructs the large language model to translate the title of each movie into French."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_rag/single_prompt",
          "webPageMainText": "A 'single prompt' generation wil perform RAG queries on each retrieved object. This is useful when you want to transform each object separately, with the same prompt.\nThis example finds entries in \"MovieMM\" based on their similarity to this image of the International Space Station. Then, instructs the large language model to translate the title of each movie into French.\nEach of the results are then printed out to the console.\nYou must pass on one or more properties to the single_prompt parameter through braces, as we've done here with \"... {title} ...\". This will instruct Weaviate to pass on the title property from each retrieved object to the large language model.\nEach response object is similar to that from a regular search query, with an additional generated attribute. This attribute will contain the generated output for each object.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate, the leader in open-source vector database technology, announces an entirely new pricing model for its Weaviate Cloud. Beginning today, users have the option of paying a usage-based rate for search on a per-dimension basis. Pricing begins at $0.05 per million dimensions."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-cloud-services",
          "webPageMainText": "\nAmsterdam NL - September 1, 2022\nWeaviate, the leader in open-source vector database technology, announces an entirely new pricing model for its Weaviate Cloud.\nInspired by \"pay-as-you-grow\" pricing used in cloud storage, Weaviate has introduced a new business model that makes it easier and more affordable for enterprises of any scale to take advantage of its Weaviate vector database. Beginning today, users have the option of paying a usage-based rate for search on a per-dimension basis. Pricing begins at $0.05 per million dimensions. (No, that's not a typo; the rate is five cents per million.)\n\"At this point, as we've reached 1,500,000 downloads, a lot of people know and love our open-source software, but they want us to run it for them,\" says Weaviate's co-founder Bob van Luijt.\" So, we've created a \u2018NoOps' option that allows them to pay only for what they use on our optimized Weaviate Cloud.\"\nIn addition to remarkably convenient access to the latest vector database capabilities, We"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector quantization reduces the memory footprint of the vector index by compressing the vector embeddings. Weaviate currently offers two vector quantization techniques:Product quantization is a multi-step quantization technique that is available for use with hnsw indexes in Weaivate. In neural networks, quantification reduces the values of the weights or activations of the model stored as a 32-bit floating-point number (4 bytes) to a lower precision number, such as an 8-bit integer."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-quantization#product-quantization",
          "webPageMainText": "Vector quantization reduces the memory footprint of the vector index by compressing the vector embeddings, and thus reduces deployment costs and improves the speed of the vector similarity search process.\nWeaviate currently offers two vector quantization techniques:\nIn general, quantization techniques reduce the memory footprint by representing numbers with lower precision numbers, like rounding a number to the nearest integer. In neural networks, quantization reduces the values of the weights or activations of the model stored as a 32-bit floating-point number (4 bytes) to a lower precision number, such as an 8-bit integer (1 byte).\nProduct quantization is a multi-step quantization technique that is available for use with hnsw indexes in Weaivate.\nPQ reduces the size of each vector embedding in two steps. First, it reduces the number of vector dimensions to a smaller number of \"segments\", and then each segment is quantized to a smaller number of bits from the original number of bits ("
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Dynamic indexing is an experimental feature. Use with caution."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/vector-index#hnsw-index-parameters",
          "webPageMainText": "Vector indexes facilitate efficient, vector-first data storage and retrieval.\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nAvailable starting in v1.25. Dynamic indexing is an experimental feature. Use with caution.\nUse these parameters to configure the index type and their properties. They can be set in the collection configuration.\nGenerally, the hnsw index type is recommended for most use cases. The flat index type is recommended for use cases where the data the number of objects per index is low, such as in multi-tenancy cases."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We are going to use a movie dataset sourced from TMDB. The dataset can be found in this GitHub repository. It contains bibliographic information on ~700 movies released between 1990 and 2024. We'll also use corresponding posters for each movie, which are available in the same repository."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_collections/preparation",
          "webPageMainText": "In this section you are going to populate your Weaviate instance with a movie dataset, using the multi-modal, CLIP models to embed the text and image data.\nMake sure to have your Weaviate instance set up. You should have created an instance and be able to connect to it.\nWe are going to use a movie dataset sourced from TMDB. The dataset can be found in this GitHub repository, and it contains bibliographic information on ~700 movies released between 1990 and 2024.\nAs a multimodal project, we'll also use corresponding posters for each movie, which are available in the same repository.\nNext, you will create a corresponding object collection and import the data.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Module system is a way to extend Weaviate's functionality. The user decides which modules are activated at startup through configuration. modules provide access to various machine-learning models which can be used to turn media into vectors at query and import time. We are going through the text2vec-transformers module as an example."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-modules/overview",
          "webPageMainText": "The Module system in Weaviate is a way to extend Weaviate's functionality.\nModules often provide access to various machine-learning models which can be\nused to turn media into vectors at query and import time. However, that's not\nthe only thing a module can do; any extension on functionality can be\nincorporated into a module.\nThe user decides which modules are activated at startup through configuration.\nSome modules can be combined with each other, others might be conflicting. In\nthis case startup will fail.\nA module is essentially code which compiles with Weaviate, but a module can\nalso communicate with other services. We are going through the\ntext2vec-transformers module as an example.\nFrom a high level, the motivation for a user to enable this module would be to\nhave their imported data vectorized with a transformer module (e.g. BERT,\netc.). Additionally, at query time, the query string should also be vectorized\nin the same way.\nFrom a tech level this module therefore has to provide"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Paid support is available for Serverless Clusters, Weaviate Enterprise SaaS, and Bring your Own Cloud clusters. Sandboxes and self-hosted clusters are not eligible for paid support. Professional support is email based and is available 24 hours a day, seven days a week."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/support-levels#business-critical-support",
          "webPageMainText": "Weaviate Cloud (WCD) offers multiple levels of support. You have the flexibility to choose the level of support that you need.\nSandboxes and self-hosted clusters are not eligible for paid support.\nPaid support is available for Serverless Clusters, Weaviate Enterprise SaaS, and Bring your Own Cloud clusters.\nFor Serverless instances, the default support level is Standard support. You are automatically enrolled for Standard support when you create a Serverless cluster. To switch to another level, contact our sales team\nFor Weaviate Enterprise SaaS and Bring your Own Cloud clusters, contact our sales team to discuss which level of support is right for you.\nStandard support is email based and is available during business hours.\nMonitoring. The WCD team monitors your cluster.\nSeverity determines incident response time:\nProfessional support is email based and is available 24 hours a day, seven days a week.\nSeverity 1 and Severity 2 incident response includes a  follow up phone call.\nMonitori"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Contradictory, Invented, Subjective, and Unverifiable are often sentence level and need to be removed completely to fix the issue.Entity and Relation are usually word level, and so can be fixed with small edits if you know where they occur. Check out the Quickstart tutorial, and begin building amazing apps wit us."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper18",
          "webPageMainText": "\nEntity: an entity in a statement is incorrect (eg. Christmas falls on Nov. 25th)\nRelation: semantic relationship in a statement is incorrect (eg. The mouse ate the cat.)\nContradictory: statements that entirely contradict relevant evidence from the web (eg. Raptors are yet to win an NBA final.)\nInvented: statements of concepts that do not exist in world knowledge (eg. MJ created the sideways somersault)\nSubjective: Statement that lacks universal validity - basically an opinion (eg. The Raptors are the best NBA team)\nUnverifiable: potentially factual statement but cannot be grounded in world evidence(eg. Jensen sleeps in a leather jacket.)\nEntity and Relation are usually word level, and so can be fixed with small edits if you know where they occur.\nContradictory, Invented, Subjective, and Unverifiable are often sentence level and thus need to be removed completely to fix the issue.\n\ud83d\udcbbCode\n\ud83d\udd17 arXiv Link\n\ud83d\udcdc Download paper\nCheck out the Quickstart tutorial, and begin building amazing apps wit"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This section includes references for the RESTful and GraphQL APIs. RESTful API end-points can be used to add data or obtain information about the Weaviate instance. GraphQL interface to retrieve data. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api",
          "webPageMainText": "This section includes references for the RESTful and GraphQL APIs. RESTful API end-points can be used to add data or obtain information about the Weaviate instance, and the GraphQL interface to retrieve data.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A breakdown of the different training steps that go into creating a LLM. Finetuning a 7B model to outperform GPT-4 for hallucination detection. A taxonomy of different types of hallucinations. 32k context length retreival models with sub-quadratic attention mechanism."
              }
            ]
          },
          "url": "https://weaviate.io/papers/page/2",
          "webPageMainText": "A breakdown of the different training steps that go into creating a LLM.\nFinetuning a 7B model to outperform GPT-4 for hallucination detection.\nProvides a taxonomy of different types of hallucinations.\n32k context length retreival models with sub-quadratic attention mechanism.\nUsing persuasion ot jailbreak LLM's.\nPresents a 7B parameter embedding model.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-huggingface module enables Weaviate to obtain vectors using the Hugging Face Inference API. To use the module, you must enable it in your Docker Compose file ( docker-compose.yml) You can set vectorizer behavior using the moduleConfig section under each clas."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-huggingface#how-to-use",
          "webPageMainText": "The text2vec-huggingface module enables Weaviate to obtain vectors using the Hugging Face Inference API.\nKey notes:\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use text2vec-huggingface, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables text2vec-huggingface, sets it as the default vectorizer, and sets the API keys.\nYou can configure how the module will behave in each class through the Weaviate schema.\nThe following parameters are available for the API.\nNote that you should only set one of:\nThe following example configures the Document class by setting the vectorizer to text2vec-huggingface, model to sentence-transformers/all-MiniLM-L6-v2 as well as to wait for the model to load, use GPU and use the cache.\nYou can set vectorizer behavior using the moduleConfig section under each clas"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "There are multiple ways to connect to Weaviate Cloud (WCD) The WCD console uses your email address and password for authentication. The built in Query app connects directly to clusters in your WCD organization without any additional authentication. By default, API keys are enabled for all WCD clusters."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/connect",
          "webPageMainText": "There are multiple ways to connect to Weaviate Cloud (WCD):\nConnect through the WCD console.\nConnect with APIs.\nThe Weaviate clients use API keys to authenticate. By default, API keys are enabled for all WCD clusters. For details see, Manage authentication.\nThe Weaviate server authenticates every request.\nTo retrieve your API keys, follow these steps:\nDo not hard-code your API key in your client code. Consider passing the API key as an environment variable or using a similar secure coding technique.\nThe WCD console uses your email address and password for authentication. You create the password when you create your WCD account.\nTo connect to the console, follow these steps:\nThe built in Query app connects directly to clusters in your WCD organization without any additional authentication.\nTo connect the Query app to a Weaviate instance that is not part of your WCD organization, provide an API key for the remote instance. Add the API key to the connection Headers at the bottom of the Qu"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#azure-storage",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A BM25 search is one implementation of what is commonly called a 'keyword' search. It works by matching the search terms between the query and the data objects in the index. The query will search the question and answer properties of the objects, from which question property will be boosted by a factor of 3."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_2/bm25",
          "webPageMainText": "A BM25 search is one implementation of what is commonly called a 'keyword' search. Broadly speaking, it works by matching the search terms between the query and the data objects in the index.\nWhen a user submits a BM25 query, Weaviate will look for objects that contain the search terms in the text properties of the objects. Then, it will rank the results based on how many times the search terms appear in the text properties of the objects.\nIn this way, a BM25 query is different to keyword-based filtering, which simply includes or excludes objects based on the provided set of conditions.\nA BM25 query is shown below. Each BM25 query:\nThe above query will return the top 3 objects based on its BM25F score, based on the query string \"food\". The query will search the question and answer properties of the objects, from which question property will be boosted by a factor of 3.\nTry varying the boost factor, and the query string. What happens to the results?\nIn an earlier unit, we briefly discus"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Snowpark Container Services (SPCS) runs containers inside the Snowflake ecosystem. To configure a Weaviate instance that runs in SPCS, follow the steps on this page. The code in this guide configures a sample SpcS instance. The sample instance demonstrates how to run Weaviates in Snowpark."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/spcs-integration",
          "webPageMainText": "Snowflake provides a hosted solution, Snowpark Container Services (SPCS), that runs containers inside the Snowflake ecosystem. To configure a Weaviate instance that runs in SPCS, follow the steps on this page.\nThe code in this guide configures a sample SPCS instance. The sample instance demonstrates how to run Weaviate in Snowpark. To configure your own SPCS instance, change the database name, warehouse name, image repository name, and other example values to match your deployment.\nDownload the SnowSQL client. Use the SnowSQL client to connect to Snowflake.\nConfigure roles and services.\nSet up OAUTH integration. Snowflake uses OAUTH to authenticate users to your service.\nThe SYSADMIN uses the BIND SERVICE ENDPOINT to create services.\nCreate a role, and a user, for the Weaviate instance. The Jupyter server uses the Weaviate user.\nCreate a database, an image repository, and stages. The image repository holds container images. The stages hold service specification files and files that the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#hybrid",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "DSPy is a framework for programming language models created by Stanford NLP. Weaviate is integrated with DSPy through the retriever module. You only need to connect to your Weaviated cluster through WCD or localhost, and pass in your collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/dspy",
          "webPageMainText": "DSPy is a framework for programming language models created by Stanford NLP. DSPy introduces two key concepts: programming model and optimizers.\nPrograming model: The programming model lets you define a series of components that make a language model request. Components include input and output fields, task descriptions, and calls to a vector database like Weaviate.\nOptimizers: Optimizers compile your DSPy program to tune the language model prompt and/or the weights.\nWeaviate is integrated with DSPy through the retriever module! You only need to connect to your Weaviate cluster through WCD or localhost, and pass in your collection:\nHere are a few resources on using DSPy from the Weaviate team!\nThe resources are broken into two categories: \nHands on Learning: Content framed to build your technical understanding with end-to-end tutorials. \nRead and Listen: Content designed to help develop your conceptual understanding of these technologies.\nIf you have any questions or feedback, let us k"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Paid support is available for Serverless Clusters, Weaviate Enterprise SaaS, and Bring your Own Cloud clusters. Sandboxes and self-hosted clusters are not eligible for paid support. Professional support is email based and is available 24 hours a day, seven days a week."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/support-levels#professional-support",
          "webPageMainText": "Weaviate Cloud (WCD) offers multiple levels of support. You have the flexibility to choose the level of support that you need.\nSandboxes and self-hosted clusters are not eligible for paid support.\nPaid support is available for Serverless Clusters, Weaviate Enterprise SaaS, and Bring your Own Cloud clusters.\nFor Serverless instances, the default support level is Standard support. You are automatically enrolled for Standard support when you create a Serverless cluster. To switch to another level, contact our sales team\nFor Weaviate Enterprise SaaS and Bring your Own Cloud clusters, contact our sales team to discuss which level of support is right for you.\nStandard support is email based and is available during business hours.\nMonitoring. The WCD team monitors your cluster.\nSeverity determines incident response time:\nProfessional support is email based and is available 24 hours a day, seven days a week.\nSeverity 1 and Severity 2 incident response includes a  follow up phone call.\nMonitori"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) serverless instances must be configured with the Cohere generative AI integration (generative-cohere) module. You must provide a valid Cohere API key to Weaviate for this integration. The model provider integration pages are new and still undergoing improvements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/cohere/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Cohere's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use a Cohere generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model and your Cohere API key.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the Cohere generative model to generate outputs.\n\nYour Weaviate instance must be configured with the Cohere generative AI integration (generative-cohere) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Cohere API key to Weaviate for this integration. Go to Cohere to sign up and obtain an API key.\nProvide the API key to Weaviate using one of the following methods:\nConfigure a Weaviate collecti"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " ranking models describe taking the query and each candidate document, one-by-one, as input to predict relevance. This is different from vector and lexical search where representations are computed offline and indexed for speed. Back in August, we published our thoughts on Cross Encoder Ranking."
              }
            ]
          },
          "url": "https://weaviate.io/blog/ranking-models-for-better-search",
          "webPageMainText": "\nWhether searching to present information to a human, or a large language model, quality matters. One of the low hanging fruit strategies to improve search quality are ranking models. Broadly speaking, ranking models describe taking the query and each candidate document, one-by-one, as input to predict relevance. This is different from vector and lexical search where representations are computed offline and indexed for speed. Back in August, we published our thoughts on Cross Encoder Ranking.\n\nThe blog post included this great visual to help with the visualization of combining Bi-Encoders and Cross-Encoders. This fishing example explains the concept of coarse-grained retrieval (fishing net = vector search / bm25) and manual inspection of the fish (fishermen = ranking models). Depicted with manual inspection of fish, the main cost of ranking models is speed.\nIn March, Bob van Luijt appeared on a Cohere panel to discuss \u201cAI and The Future of Search\u201d. Bob explained the effectiveness of co"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " vector databases must be able to search through a vast number of vectors at speed. This is a huge technical challenge that is only becoming more difficult over time. Approximate Nearest Neighbor (ANN) algorithms to power Weaviate are the current prevailing solution. There are many different ANN algorithms, each with different advantages and limitations."
              }
            ]
          },
          "url": "https://weaviate.io/blog/ann-algorithms-vamana-vs-hnsw",
          "webPageMainText": "\nVector databases must be able to search through a vast number of vectors at speed. This is a huge technical challenge that is only becoming more difficult over time as the vector dimensions and dataset sizes increase.\nLike many others, our current prevailing solution is to use Approximate Nearest Neighbor (ANN) algorithms to power Weaviate. But the key question is - which ones to use? There are many different ANN algorithms, each with different advantages and limitations.\nWhen we talk about a vast number of objects, today we often see use cases with hundreds of millions of vectors, but it won't take long until billions, or even trillions, will be a pretty standard use case.\nTo get vector databases to that kind of scale, we need to constantly evolve and look for more efficient solutions. A big part of this search is to explore ANN algorithms that would let us go beyond the available RAM (which is a bit of a bottleneck) without sacrificing the performance and the UX.\nIn this series of b"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Ajit is interning at Weaviate's Developer Growth team. Ajit is part of the company's developer growth team. He is also a member of the People Operations team at the company. He says that in the last six months, the company has felt a quantum shift. He also says that the company is recruiting heavily."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook",
          "webPageMainText": "Hey! I am Ajit, and I am currently interning at Weaviate's Developer Growth team...\nHow do you explain culture, how do you put a feeling into words...\nA new approach to People Operations...\nIf Weaviate was a typical human child, this is about the stage...\nOver the last few months, we have been recruiting heavily...\nThe last six months we\u2019ve felt a quantum shift at Weaviate...\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This is a preview version of this unit. Some sections are not yet complete - such as videos and quiz questions. Please check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below. We continue our discussion of chunking techniques by taking you through variable-size chunking."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking/how_2",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nWe continue our discussion of chunking techniques by taking you through variable-size chunking techniques, including some example implementations.\nNow let's look at variable-size chunking. Unlike fixed-size chunking, the chunk size here is an outcome, rather than an input parameter.\nIn variable-size chunking, some marker is used to split the text. The marker may be syntactic, such as a sentence or paragraph marker, or even structural such as a markdown header.\nA pseudocode implementation of variable-size chunking could look like this:\nWhich could be implemented in Python as below:\nOr, we could use special markers - such as Markdown headers - to split the text.\n(Since the Pro Git book is written in Asciidoc, we'll use Asciidoc headers instead - th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate offers three distinct search methods - namely vector, keyword, and hybrid searches. Each method has its unique strengths and applicabilities. This section compares these search types to equip you with the knowledge to intuit when and why to employ each of these search methodologies."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/which_search",
          "webPageMainText": "Weaviate offers three distinct search methods - namely vector, keyword, and hybrid searches.\nEach method has its unique strengths and applicabilities, making the selection critical to the success of your search-related tasks.\nThis section compares these search types to equip you with the knowledge to intuit when and why to employ each of these search methodologies.\nWe will explore how the choice of search type impacts not only the quality of the search results but also the overall performance of the search operation.\nThen, we will also discuss strategies to improve the quality of search results, as well as the performance of the search operation.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#hierarchical-navigable-small-world-hnsw-index",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model. It encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware. The ONNX-enabled images can use ONNx Runtime for faster inference processing on CPUs."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-transformers#neartext",
          "webPageMainText": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model.\ntext2vec-transformers encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nTransformer model inference speeds are usually about ten times faster with GPUs. If you have a GPU, use one of the GPU enabled models.\nIf you use text2vec-transformers without GPU acceleration, imports or nearText queries may become bottlenecks. The ONNX-enabled images can use ONNX Runtime for faster inference processing on CPUs. Look for the -onnx suffix in the image name.\nAlternatively, consider one of the following options:\nThis module is not available on Weaviate Cloud.\nTo use text2vec-transformers, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to genera"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn about the different ranking models that are used for better search results. Learn about the differences between vector libraries and vector databases. Discover how Weaviate can help you with your search queries. Learn how to build your own search queries using the new search engine. Use the new tool to help you find the right search results for your search query."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/search",
          "webPageMainText": "Dive into using Weaviate for image recognition to find the \"needle in a haystack\"!\nHybrid Search for curious Web Developers with the new Weaviate TypeScript client and Next.js\nLearn how to fine-tune Cohere's reranker and generate synthetic data using DSPy!\nWe look at how to build Multimodal applications in TypeScript and dive into everything that needs to happen in between.\nHow hybrid search works, and under the hood of Weaviate's fusion algorithms.\nLearn about the intersection between LLMs and Search\nLearn about the different ranking models that are used for better search.\nLearn about the new hybrid search feature that enables you to combine dense and sparse vectors to deliver the best of both search methods.\nLearn more about the differences between vector libraries and vector databases!\nVector Databases can run semantic queries on multi-million datasets in milliseconds. How is that possible?\nLearn about bi-encoder and cross-encoder machine learning models, and why combining them coul"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#batching",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) hosts clusters that run the Weaviate core database server. WCD runs the current production version of Weaviates core. W CD does not automatically update clusters, however if an existing cluster has a security vulnerability, WCD upgrades the cluster when a fix is released."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/version",
          "webPageMainText": "Weaviate Cloud (WCD) hosts clusters that run the Weaviate core database server. WCD runs the current production version of Weaviate core.\nWhen you provision a new cluster, WCD uses the current version of Weaviate core to set up the new cluster. You cannot select another Weaviate core version when you create a new cluster.\nWCD does not automatically update existing clusters when a new version of Weaviate core is released.\nThe WCD console informs you when a newer version is available. Consider your business needs, and upgrade your cluster when you have a suitable maintenance window.\n\nWeaviate introduces Raft, an improved cluster synchronization mechanism in v1.25. There is some downtime when you upgrade an HA cluster to 1.25 while the cluster switches to the new mechanism.\n WCD does not automatically update clusters, however if an existing cluster has a security vulnerability, WCD upgrades the cluster when a fix is released.\n For security updates, WCD upgrades the cluster to the most cur"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate Go client is compatible with Go 1.16+. The client doesn't support the old Go modules system. The current Go client version is v4.14.0. The suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviates instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/go#authentication",
          "webPageMainText": "The current Go client version is v4.14.0.\nThe Weaviate Go client is compatible with Go 1.16+.\nThe client doesn't support the old Go modules system. Create a repository for your code before you import the Weaviate client.\nCreate a repository:\nTo get the latest stable version of the Go client library, run the following:\nThis example establishes a connection to your Weaviate instance and retrieves the schema.:\nFor more comprehensive information on configuring authentication with Weaviate, refer to the authentication page.\nThe Go client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows.\nThe suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviate instance.\nEach Weaviate instance in Weaviate Cloud (WCD) is pre-configured to act as a token issuer for OIDC authentication.\nSee our WCD authentication documentation for instructions on how to authenticate against WCD with your pr"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The NER module can be added as a service to the Docker Compose file. You must have a text vectorizer like text2vec-contextionary or text2 Vec-transformers running. For maximum performance, transformer-based models should run with GPUs. There are three different NER modules available."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/ner-transformers",
          "webPageMainText": "Named Entity Recognition (NER) module is a Weaviate module to extract entities from your existing Weaviate (text) objects on the fly. Entity Extraction happens at query time. Note that for maximum performance, transformer-based models should run with GPUs. CPUs can be used, but the throughput will be lower.\nThere are currently three different NER modules available (taken from Hugging Face): dbmdz-bert-large-cased-finetuned-conll03-english, dslim-bert-base-NER, davlan-bert-base-multilingual-cased-ner-hrl.\nThe NER module can be added as a service to the Docker Compose file. You must have a text vectorizer like text2vec-contextionary or text2vec-transformers running. An example Docker Compose file for using the ner-transformers module (dbmdz-bert-large-cased-finetuned-conll03-english) in combination with the text2vec-contextionary:\nVariable explanations:\nTo make use of the modules capabilities, simply extend your query with the following new _additional property:\nThis module adds a search"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a search engine that uses inverted indices to store data and values. Data is stored as vectors, which enables semantic search. This combination of data storage is unique, and enables fast, filtered and semantic search from end-to-end. Weaviate comes containerized to make it easier for others to build their own systems."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/faq#q-does-weaviate-use-hnswlib",
          "webPageMainText": "Our goal is three-folded. Firstly, we want to make it as easy as possible for others to create their own semantic systems or vector search engines (hence, our APIs are GraphQL based). Secondly, we have a strong focus on the semantic element (the \"knowledge\" in \"vector databases,\" if you will). Our ultimate goal is to have Weaviate help you manage, index, and \"understand\" your data so that you can build newer, better, and faster applications. And thirdly, we want you to be able to run it everywhere. This is the reason why Weaviate comes containerized.\nOther database systems like Elasticsearch rely on inverted indices, which makes search super fast. Weaviate also uses inverted indices to store data and values. But additionally, Weaviate is also a vector-native search database, which means that data is stored as vectors, which enables semantic search. This combination of data storage is unique, and enables fast, filtered and semantic search from end-to-end.\nYes, we do - check out Weaviate"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#nearimage",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "1.21 adds ContainsAny and ContainsAll operators to make your filters sweeter than ever. You can use these to reduce complex chains of And or Or where filters to simple, digestible, queries that are easier on your eye and your brain. This is one of our most-requested features, and we are very excited for you to try it out."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/release_1_21",
          "webPageMainText": "\nWeaviate 1.21 is here!\nHere are the \u2b50\ufe0fhighlights\u2b50\ufe0f relating to this release:\n1.21 is already available on Weaviate Cloud - so try it out!\nFor more details, keep scrolling \u2b07\ufe0f!\n\nYou asked for it - and it\u2019s here! 1.21 adds ContainsAny and ContainsAll operators to make your filters (syntactically) sweeter than ever.\nYou can use these to reduce complex chains of And or Or where filters to simple, digestible, queries that are easier on your eye and your brain.\nThese operators allow you to filter an array property, using a query array.\nContainsAny will find all objects whose property contains one or more (i.e. any) of the query values. In other words - a series of Or statements.\nContainsAll, on the other hand, will find all objects whose property contains every single one (i.e. all) of the query values. This can replace a series of And statements.\nThis is one of our most-requested features, and we are very excited for you to try it out.\nConsider a dataset of people (class Person), where each"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "When running Weaviate with Docker or Kubernetes, you can persist its data by mounting a volume to store the data outside of the containers. Doing so will cause the Weaviates instance to also load the data from the mounted volume when it is restarted."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/persistence",
          "webPageMainText": "When running Weaviate with Docker or Kubernetes, you can persist its data by mounting a volume to store the data outside of the containers. Doing so will cause the Weaviate instance to also load the data from the mounted volume when it is restarted.\nNote that Weaviate now offers native backup modules starting with v1.15 for single-node instances, and v1.16 for multi-node instances. For older versions of Weaviate, persisting data as described here will allow you to back up Weaviate.\nWhen running Weaviate with Docker Compose, you can set the volumes variable under the weaviate service and a unique cluster hostname as an environment variable.\nIn the case you want a more verbose output, you can change the environment variable for the LOG_LEVEL\nA complete example of a Weaviate without modules but with an externally mounted volume and more verbose output:\nSee Backups.\nFor Kubernetes setup, the only thing to bear in mind is that Weaviate needs a PersistentVolumes through PersistentVolumeClaim"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with the Hugging Face Transformers library allows you to access their CLIP models' capabilities directly from Weaviate.Configure a Weaviates vector index to use the CLIP integration. The model provider integration pages are new and still undergoing improvements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings-multimodal",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with the Hugging Face Transformers library allows you to access their CLIP models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use the CLIP integration, and configure the Weaviate instance with a model image, and Weaviate will generate embeddings for various operations using the specified model in the CLIP inference container. This feature is called the vectorizer.\nAt import time, Weaviate generates multimodal object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts queries of one or more modalities into embeddings.\n\nYour Weaviate instance must be configured with the CLIP vectorizer integration (multi2vec-clip) module.\nThis integration is not available for Weaviate Cloud (WCD) serverless instances, as it requires spinning up a container with the Hugging Fac"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "RAG queries are also called 'generative' queries in Weaviate. You can access these functions through the generate submodule of the collection object. Each generative query works in addition to the regular search query. This allows you to retrieve objects and then generate outputs based on the retrieved objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_rag/setup",
          "webPageMainText": "Retrieval augmented generation (RAG) is a way to combine the best of both worlds: the retrieval capabilities of semantic search and the generation capabilities of AI models such as large language models. This allows you to retrieve objects from a Weaviate instance and then generate outputs based on the retrieved objects.\nWhen we created a collection, we specified the generative_module parameter as shown here.\nThis selects a generative module that will be used to generate outputs based on the retrieved objects. In this case, we're using the cohere module, and the Command-R family of large language models.\nAs we did before with the vectorizer module, you will require an API key from the provider of the generative module. In this case, you will need an API key from Cohere.\nRAG queries are also called 'generative' queries in Weaviate. You can access these functions through the generate submodule of the collection object.\nEach generative query works in addition to the regular search query, "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Multi-tenancy provides data isolation. Each tenant is stored on a separate shard. Data stored in one tenant is not visible to another tenant. Weaviate returns an error if you try to insert an object into a non-existent tenant. The auto-tenant feature is available from v1.25.0 for batch imports."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/multi-tenancy",
          "webPageMainText": "Multi-tenancy provides data isolation. Each tenant is stored on a separate shard. Data stored in one tenant is not visible to another tenant. If your application serves many different users, multi-tenancy keeps their data private and makes database operations more efficient.\nMulti-tenancy is disabled by default. To enable multi-tenancy, set multiTenancyConfigin the collection definition:\nBy default, Weaviate returns an error if you try to insert an object into a non-existent tenant. To change this behavior so Weaviate creates a new tenant, set autoTenantCreation to true in the collection definition.\nThe auto-tenant feature is available from v1.25.0 for batch imports, and from v1.25.2 for single object insertions as well.\nSet autoTenantCreation when you create the collection, or reconfigure the collection to update the setting as needed.\nAutomatic tenant creation is useful when you import a large number of objects. Be cautious if your data is likely to have small inconsistencies or typo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.14 is the most reliable and observable Weaviate release yet. This release includes over 25 bug fixes and a few neat features. Check out the changelog to see the complete list of features and over 25Bug fixes. In this release we fixed a critical bug, which in rare situations could result in data loss."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-14-release",
          "webPageMainText": "\nWe are excited to announce the release of Weaviate 1.14, the most reliable and observable Weaviate release yet.\nLater this week, we will release Weaviate v1.14, possibly the most boring release so far.\ud83d\ude31 Yet I'm incredibly excited about it and so should you. Why? \n(1/9)\nSee  by @etiennedi\nBesides many bug fixes and reliability improvements, we have a few neat features that you might find interesting. In short, this release covers:\n\nAt Weaviate, Reliability is one of our core values, which means that we will always strive to make our software dependable, bug-free, and behave as expected.\nAnd yes, bug fixing is not always the most exciting topic, as we often get more excited about shiny new features. But for you to truly enjoy working with Weaviate, we need to make sure that no bugs are getting in the way.\nCheck out the changelog to see the complete list of features and over 25 bug fixes.\nIn this release we fixed a critical bug, which in rare situations could result in data loss.\nThe bug"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#invertedindexconfig--indexnullstate",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default values in values.yaml may be sufficient. Make sure to set your desired Weaviate version. The yaml file is extensively documented to help you align the configuration with your setup. The configuration file is setup for:See the resource requ requeur for more information."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/kubernetes#weaviate-helm-chart",
          "webPageMainText": "Make sure to set your desired Weaviate version.\nThis can be done through either explicitly setting it as part of the values.yaml or through overwriting the default as outlined in the deployment step below.\nIf you are looking for a complete end-to-end tutorial on the topic, see the Weaviate Academy course, Weaviate on Kubernetes. The course is an end-to-end tutorial on how to use MiniKube to deploy Weaviate on Kubernetes.\nTo obtain and install the Weaviate chart on your Kubernetes cluster, take the following steps:\nAdd the Weaviate helm repo that contains the Weaviate helm chart\nGet the default values.yaml configuration file from the Weaviate helm chart:\nThe default values in values.yaml may be sufficient. However, we recommend reviewing:\nIn the values.yaml\nfile you can tweak the configuration to align it with your\nsetup. The yaml file is extensively documented to help you align the\nconfiguration with your setup.\nOut of the box, the configuration file is setup for:\nSee the resource requ"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn how to use build an image search application using the Img2vec-neural module in Weaviate. Learn how to quickly and easily back up and restore your Weaviates data with the native backup feature. Semantic search on Wikipedia dataset with Weaviated \u2013 vector database."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/how-to/page/3",
          "webPageMainText": "Recent advances in AI are breathing new life into podcasting! The Whisper speech-to-text model is a game-changer!\nLearn how to import and query the Sphere dataset in Weaviate!\nLearn how to quickly and easily back up and restore your Weaviate data with the native backup feature.\nLearn how to use build an image search application using the Img2vec-neural module in Weaviate.\nSemantic search on Wikipedia dataset with Weaviate \u2013 vector database.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.23 is already available on Weaviate Cloud - so try it out! This release includes improvements to Product Quantization (PQ) PQ requires a training step, so we created AutoPQ to take care of the training for you. In this release we have a new algorithm to determine the optimal segment size."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-23-release",
          "webPageMainText": "Weaviate 1.23 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f relating to this release:\n\n1.23 is already available on Weaviate Cloud - so try it out!\nFor more details, keep scrolling \u2b07\ufe0f!\n\n\nWeaviate introduced Product Quantization (PQ) earlier this year. Since then, we've improved how PQ works with your data. In v1.23 we've made it easier to get started. PQ requires a training step. We've heard that the training step was tricky to configure, so we created AutoPQ to take care of the training for you. Just enable AutoPQ in your system configuration. Then, any time you enable PQ on a new collection, AutoPQ takes care of training and initializes PQ for you.\nWe have other improvements too. PQ uses segments to compress vectors. In this release we have a new algorithm to determine the optimal segment size for your vectors. You can still set the segment size manually, but you shouldn't have to.\nTogether, AutoPQ and improved segment sizing make using PQ easier than ever.\n\n\nWeaviate now supports a f"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Google Cloud Next is set to go live in the U.S. next week. Google Cloud Next will be the company's cloud computing platform. The company is also set to launch its cloud-storage service in the United States. The service is expected to be available in the coming months."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/recap",
          "webPageMainText": "Here is our recap of Google Cloud Next!\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ), is a technique used to compress vectors. In Weaviate, it can be used to reduce the size of the in-memory HNSW index. PQ can improve performance and reduce resource requirements as well as costs. It can reduce the length of the vector by a factor of 6, and also thesize of each segment from a floating point number (4 bytes) to a byte."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/compression/pq",
          "webPageMainText": "Product quantization (PQ), is a technique used to compress vectors. In Weaviate, it can be used to reduce the size of the in-memory HNSW index, which can improve performance and reduce resource requirements as well as costs.\nProduct quantization compresses vectors in two ways. One, by dividing them into \"segments\", and two, quantizing each segment to be represented by one of a \"codebook\" of centroids.\nIn the diagram below, we show a vector of L dimensions, where each dimension is a floating point number. The vector is divided into L/x segments, and each segment is quantized to be represented by one of N centroids.\nAs an example, a 768-dimensional vector can be compressed into a 128-segment quantized vector of 1-byte integers.\nThis will reduce the length of the vector by a factor of 6, and also the size of each segment from a floating point number (4 bytes) to a byte, representing one of 256 centroids.\nAs a result, the size of the vector is reduced by 24 (from 768 lots of 4 byte numbers"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#instantiate-a-client",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with the Hugging Face Transformers library allows you to access their models' capabilities directly from Weaviate.Configure a Weaviates vector index to use the Transformers integration. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings#available-models",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with the Hugging Face Transformers library allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use the Transformers integration, and configure the Weaviate instance with a model image, and Weaviate will generate embeddings for various operations using the specified model in the Transformers inference container. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the Hugging Face Transformers vectorizer integration (text2vec-transformers) module.\nThis integration is not available for Weaviate Cloud (WCD) serverless instances, as it requires spinning up a container with the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a search engine that uses a data structure called vector embedding. The core function is to provide high-quality search results, going beyond simple keyword or synonym searches. To tackle this problem, semantic search uses at its core aData structure called Vector embedding (or simply, vector or embedding), which is an ar."
              }
            ]
          },
          "url": "https://weaviate.io/blog/vector-embeddings-explained",
          "webPageMainText": "The core function of Weaviate is to provide high-quality search results, going beyond simple keyword or synonym searches, and actually finding what the user means by the query, or providing an actual answer to questions the user asks.\nSemantic searches (as well as question answering) are essentially searches by similarity, such as by the meaning of text, or by what objects are contained in images. For example, consider a library of wine names and descriptions, one of which mentioning that the wine is \u201cgood with fish\u201d. A \u201cwine for seafood\u201d keyword search, or even a synonym search, won\u2019t find that wine. A meaning-based search should understand that \u201cfish\u201d is similar to \u201cseafood\u201d, and \u201cgood with X\u201d means the wine is \u201cfor X\u201d\u2014and should find the wine.\n\nHow can computers mimic our understanding of language, and similarities of words or paragraphs? To tackle this problem, semantic search uses at its core a data structure called vector embedding (or simply, vector or embedding), which is an ar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#2-load-training-data",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a cloud-based search engine. We use the OpenAI API to provide search results to users. We also use the API to create embeddings for our search results. For more information on how to use this feature, visit: http://www.weaviate.com."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/openai/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with OpenAI's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an OpenAI embedding model, and Weaviate will generate embeddings for various operations using the specified model and your OpenAI API key. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the OpenAI vectorizer integration (text2vec-openai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid OpenAI API key to Weaviate for this integration. Go to OpenAI to sign up and obtain an API key.\nProvide the API key to Weaviate using one of t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Can we use synthetic data to train future generations of LLM's? Identify a key shortcoming of LLMs in terms of their causal inference skills. Why do large language models attend better over the beginning and end of thier context? Comparing LLM performance using retreival vs longer context lengths."
              }
            ]
          },
          "url": "https://weaviate.io/papers/page/4",
          "webPageMainText": "Multimodal RAG and its benefits!\nDifferentiating between human-written language and AI-generated text.\nCan we use synthetic data to train future generations of LLM's?\nIdentify a key shortcoming of LLMs in terms of their causal inference skills.\nWhy do large language models attend better over the beginning and end of thier context?\nComparing LLM performance using retreival vs longer context lengths.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open source vector database that's used to power modern AI use cases like semantic and multimodal search and retrieval augmented generation. Integration with Snowflake\u2019s platform helps enterprises leverage the power of GenAI while ensuring data privacy.Develop Python apps faster by integrating Weaviate and Streamlit. Create interactive interfaces using your data and ML models."
              }
            ]
          },
          "url": "https://weaviate.io/partners/snowflake",
          "webPageMainText": "Weaviate + Snowflake\nLeverage generative AI capabilities within the boundaries of your Snowflake data environment.\nWeaviate is an open source vector database that's used to power modern AI use cases like semantic and multimodal search and retrieval augmented generation (RAG). Integration with Snowflake\u2019s platform helps enterprises leverage the power of GenAI while ensuring data privacy.\nEnsure all data operations, including embeddings and vector searches, remain within your secure environment.\nAugment Large Language Models (LLMs) with your own data. Deliver reliable answers using built-in modules for Cohere, OpenAI, and more.\nDevelop Python apps faster by integrating Weaviate and Streamlit. Create interactive interfaces using your data and ML models.\n\nLearn and explore the latest from Weaviate across the web.\nRunning Weaviate Vector DB in Snowflake using Snowpark Container Services\nFast, Easy and Secure LLM App Development With Snowflake Cortex\nGuide: Weaviate on SPCS\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Two new Weaviate modules integrate Google's new PaLM large language model (LLM) Google's PaLM was designed to generalize across domains and tasks while being highly efficient. The modules are available to all Weaviates users as of today, with the release of Weaviated version v1.19.1."
              }
            ]
          },
          "url": "https://weaviate.io/blog/announcing-palm-modules",
          "webPageMainText": "\nWe are thrilled to announce two brand new Weaviate modules that will help you to get the most out Google's new PaLM large language model (LLM).\nThese new modules are:\nThese modules are available to all Weaviate users as of today, with the release of Weaviate version v1.19.1. They integrate the new Vertex PaLM API with Weaviate, allowing you to hit the ground running straight away with the latest in LLM and vector database technologies.\nThe Pathways Language Model (or PaLM) is Google\u2019s own LLM. According to Google, PaLM was designed to generalize across domains and tasks while being highly efficient.\nYou can read more about in this blog or this paper, but some of the highlights from these articles are that PaLM:\nDon't take our word for it - take a look at these demo snippets from Google's blog.\n\nEdit: We now have more details on the PaLM 2 family of models, which the API is based on! Read about it here. In the blog, Google especially highlights improvements in multilingual, reasoning a"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This blog post will guide you to build a full-stack web application in Python with Weaviate and Flask. The application will take an image of a dog and return an image from the database that best matches the type of dog in an instant. You can use this to build an image-search app or a product search app."
              }
            ]
          },
          "url": "https://weaviate.io/blog/how-to-build-an-image-search-application-with-weaviate",
          "webPageMainText": "\nRecently, I was working with my colleague Marcin (an engineer from Weaviate core) on a really cool demo project. The idea was to build an image-search application for dogs, which allows a user to provide a picture of a dog, and the app would respond with the most similar breed. And if a user provides a picture of their partner (I might've tested this on my boyfriend \ud83d\ude04), it returns the breed most similar to them.\nOnce we had the demo up and running, I thought this was a perfect opportunity to share it. This blog post is the foundation for you to build another application around image recognition or product search.\nThis blog post will guide you to build a full-stack web application in Python with Weaviate and Flask. By the time you are done with the post, you will have built an image-search app! The application will take an image of a dog and return an image from the database that best matches the type of dog in an instant.\nYou are probably already aware that Weaviate can power \ud83d\ude80 fast v"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/assets/files/weaviate-architecture-overview-54e15328eb9bdfe6695f85443d892f2e.svg",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "BM25 (Best match 25) search returns objects that have the highest BM25F scores. To use BM25 keyword search, define a search string. The BM25 query string is tokenized before it is used to search for objects using the inverted index. Use offset to paginate the results."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/bm25",
          "webPageMainText": "Keyword search, also called \"BM25 (Best match 25)\" or \"sparse vector\" search, returns objects that have the highest BM25F scores.\nTo use BM25 keyword search, define a search string.\nThe response is like this:\nYou can retrieve the BM25F score values for each returned object.\nThe response is like this:\nA keyword search can be directed to only search a subset of object properties. In this example, the BM25 search only uses the question property to produce the BM25F score.\nThe response is like this:\nYou can weight how much each property affects the overall BM25F score. This example boosts the question property by a factor of 2 while the answer property remains static.\nThe response is like this:\nThe BM25 query string is tokenized before it is used to search for objects using the inverted index.\nYou must specify the tokenization method in the collection definition for each property.\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative Ollama is a module for Weaviate. It performs retrieval augmented generation, or RAG, based on the data stored in your Weaviates instance. To use generative-ollama, you must enable it in your Docker Compose file ( docker-compose.yml)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/generative-ollama",
          "webPageMainText": "generative-ollama performs retrieval augmented generation, or RAG, based on the data stored in your Weaviate instance.\nThe module works in two steps:\nYou can use the Generative Ollama module with any other upstream modules. For example, you could use text2vec-cohere, text2vec-huggingface or text2vec-openai to vectorize and query your data, but then rely on the generative-ollama module to generate a response.\nThe generative module can perform RAG for:\nYou need to input both a query and a prompt (for individual responses) or a task (for all responses).\nThis module is not available on Weaviate Cloud.\nTo use generative-ollama, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables generative-ollama.\nYou can configure how the module will behave in each collection through the Weaviate schema.\nConfigurable parameters unique to the the generative-ollama module are:\nOptionally, "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product Quantization is a way to compress vectors, allowing users to save on memory requirements. To understand how product quantization (PQ) compression works, imagine every vector you want to store is a unique house address. This address allows you to precisely locate where someone lives including country, state, city, street number, and even down to the house number."
              }
            ]
          },
          "url": "https://weaviate.io/blog/pq-rescoring",
          "webPageMainText": "\nProduct Quantization is a way to compress vectors, allowing users to save on memory requirements. To understand how product quantization (PQ) compression works, imagine every vector you want to store is a unique house address. This address allows you to precisely locate where someone lives including country, state, city, street number, and even down to the house number. The price you pay for this pin-point accuracy is that each address takes up more memory to store. Now, imagine instead of storing a unique address for each house we store just the city the house is located in. With this new representation, you can no longer precisely differentiate between houses that are all in the same city. The advantage however is that you require less memory to store the data in this new format. This is why PQ is a lossy algorithm; we lose information as a result of the compression - or in other words, you trade accuracy/recall for memory savings.\nWant to further reduce memory usage at the price of"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This course is self-contained. However, we recommend that you go through one of the 101-level courses, such as that for working with text, your own vectors, or multimodal data. This course will introduce you to data compression in Weaviate and how it can be used to reduce your resource requirements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/compression",
          "webPageMainText": "This course is self-contained. However, we recommend that you go through one of the 101-level courses, such as that for working with text, your own vectors, or multimodal data.\nAs you work with more and more data, the sheer volume of it begins to impose further and further constraints on your ability to work with it. This is especially true the closer you get to production environments, where the cost of storage and the time it takes to process data can become significant.\nThis course will introduce you to data compression in Weaviate, and how it can be used to reduce your resource requirements and in turn improve performance or reduce costs.\nWhat is product quantization (PQ), and how do you use it?\nWhat is binary quantization (BQ), and how do you use it?\nWhat compression algorithm and settings are right for me?\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-ollama module enables Weaviate to obtain vectors using Ollama. Ollamas is a tool for simplifying the process of running embedding and large language models, such as GPT-3, on your own hardware. This module is not available on Weaviates Cloud."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-ollama",
          "webPageMainText": "The text2vec-ollama module enables Weaviate to obtain vectors using Ollama. Ollama is a tool for simplifying the process of running embedding and large language models, such as GPT-3, on your own hardware. This module allows you to use Ollama to generate embeddings for your data in Weaviate.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use text2vec-ollama, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create one using the Weaviate configuration tool.\nThis configuration enables text2vec-ollama, sets it as the default vectorizer, and sets the API keys.\nYou can configure how the module will behave in each collection through the Weaviate schema.\nConfigurable parameters for the text2vec-ollama module are:\nOptionally, you can provide the apiEndpoint parameter as shown below to specify the URL of the Ollama endpoint.\nIf you are running Weaviate via Docker, with a local Ollama instance, specify host.docker.internal:<ollama-port"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a managed service that runs Weaviate for you. WCD is the fastest way to create a new instance and requires the least amount of effort for users. You can run Weaviates using containerization solutions such as Docker and Kubernetes."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/set_up#get-started-with-wcs",
          "webPageMainText": "Weaviate Cloud (WCD) is a managed service that runs Weaviate for you. You can also manage your own Weaviate instances using Docker, Kubernetes, or Embedded Weaviate.\nNo matter how you run Weaviate, the underlying code is identical. However, there are some operational differences to be aware of.\nWeaviate Cloud (WCD), is a managed SaaS service that requires no maintenance at your end.\nAs it is managed by Weaviate (the company - the software is not sentient... yet). WCD is the fastest way to create a new instance of Weaviate and requires the least amount of effort for users.\nWCD has Weaviate instances that are pre-configured for your convenience. They include a number of Weaviate modules by default. They also have built-in support for user authentication.\nWCD includes a free \"sandbox\" tier. The WCD sandbox is our recommended method of running Weaviate in this course.\nYou can run Weaviate instances using containerization solutions such as Docker and Kubernetes.\nRunning your own instance pr"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If you have any questions or feedback, let us know in the user forum. These pages can help with common questions. For additional information, try these sources. For more information about the game, visit the official site. For information on how to play the game in the UK, visit our official website."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources",
          "webPageMainText": "\u00a0\u00a0\u00a0\nThese pages can help with common questions:\nFor additional information, try these sources.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The bottleneck in knowledge work has been our rate of information discovery and consumption. Weaviate, as a vector database, can help with information cataloging and discovery. But did you know that weaviate can also summarize information during retrieval? Our summarizer module (sum-transformers) can be added to a Weaviates instance to do exactly that."
              }
            ]
          },
          "url": "https://weaviate.io/blog/solution-to-tl-drs",
          "webPageMainText": "\n(Note: You can skip to the TL;DR version below \ud83d\ude09)\nHow often do you find yourself facing a wall of text in an email, a report, or a paper, and letting out a sigh? Nobody enjoys hacking their way through boring, dense prose. Especially if it's just to see if the information is even relevant.\nIn this day and age, this is a more common problem than ever. For a while now, the bottleneck in knowledge work has been our rate of information discovery and consumption. So how do we solve this problem?\nYou probably already know that Weaviate, as a vector database, can help with information cataloging and discovery. But did you know that Weaviate can also summarize information during retrieval?\nOur summarizer module (sum-transformers) can be added to a Weaviate instance to do exactly that.\nAnd as a bonus, we will also show you how to use our new generative module (generative-openai) to do the same thing as well.\nBy the end, you will see how you can use Weaviate to reduce the amount of TL;DRs (too "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "With Weaviate, you can perform semantic searches to find similar items based on their meaning. This is done by comparing the vector embeddings of the items in the database. As we are using a multimodal model, we can search for objects based on the similarity to any of the supported modalities."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_searches/multimodal",
          "webPageMainText": "With Weaviate, you can perform semantic searches to find similar items based on their meaning. This is done by comparing the vector embeddings of the items in the database.\nAs we are using a multimodal model, we can search for objects based on their similarity to any of the supported modalities. Meaning that we can search for movies based on their similarity to a text or an image.\nThis example finds entries in \"MovieMM\" based on their similarity to this image of the International Space Station, and prints out the title and release year of the top 5 matches.\n\nThe results are based on similarity of the vector embeddings between the query and the database object. In this case, the vectorizer module generates an embedding of the input image.\nThe limit parameter here sets the maximum number of results to return.\nThe return_metadata parameter takes an instance of the MetadataQuery class to set metadata to return in the search results. The current query returns the vector distance to the quer"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate offers an optional authentication scheme using API keys and OpenID Connect (OIDC), which can enable various authorizations levels. API key and OIDC authentication can be both enabled at the same time. Weaviate Cloud (WCD) instances are pre-configured for API key authentication."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/authentication#oidc---a-systems-perspective",
          "webPageMainText": "Weaviate offers an optional authentication scheme using API keys and OpenID Connect (OIDC), which can enable various authorizations levels.\nWhen authentication is disabled, all anonymous requests will be granted access.\nIn this documentation, we cover all scenarios for your convenience:\nNote that API key and OIDC authentication can be both enabled at the same time.\nFor most use cases, the API key option offers a balance between security and ease of use. Give it a try first, unless you have specific requirements that necessitate a different approach.\nSee this page for how to set up values.yaml for authentication & authorization.\nWeaviate Cloud (WCD) instances are pre-configured for API key authentication.\nTo configure Weaviate for API key-based authentication, add the following environment variables to your configuration file.\nAn example docker-compose.yml file looks like this:\nThe example associates API keys and users.\nThere are two options for configuring the number of keys and users:"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a text-based augmented reality tool. It can be used to help users with reading comprehension and vocabulary. Weaviate can also be used in a natural language question (LLM) to help people find the correct information. The tool can be downloaded from the GitHub site."
              }
            ]
          },
          "url": "https://weaviate.io/blog/find-waldo-with-weaviate",
          "webPageMainText": "\nhttps://github.com/tuitejc/WeaviateWaldo\nOne night while doing the usual bedtime routine with my son, we started going through a \u201cWhere\u2019s Waldo\u201d book. My son happens to be fantastic at pattern recognition and we raced to see who could find him first. My son was faster than me each time. Assuming that he had obviously memorized the locations on each page, I pulled out my phone and pulled up a fresh new image. He still won!\nAfter admitting defeat to my son, I told him I\u2019d be back for a rematch. Realizing his younger eyes would always have the edge, I decided I would try and use something he didn\u2019t have. Weaviate!\nMost use cases I come across while working with users of Weaviate involve searching across text data. Retrieval Augmented Generation (RAG) use cases break up large bodies of text into smaller chunks, then use the context of a natural language question to find appropriate pieces of information, and stuff that into an LLM prompt. Finding the correct pieces of information, or chun"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default values in values.yaml may be sufficient. Make sure to set your desired Weaviate version. The yaml file is extensively documented to help you align the configuration with your setup. The configuration file is setup for:See the resource requ requeur for more information."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/kubernetes#requirements",
          "webPageMainText": "Make sure to set your desired Weaviate version.\nThis can be done through either explicitly setting it as part of the values.yaml or through overwriting the default as outlined in the deployment step below.\nIf you are looking for a complete end-to-end tutorial on the topic, see the Weaviate Academy course, Weaviate on Kubernetes. The course is an end-to-end tutorial on how to use MiniKube to deploy Weaviate on Kubernetes.\nTo obtain and install the Weaviate chart on your Kubernetes cluster, take the following steps:\nAdd the Weaviate helm repo that contains the Weaviate helm chart\nGet the default values.yaml configuration file from the Weaviate helm chart:\nThe default values in values.yaml may be sufficient. However, we recommend reviewing:\nIn the values.yaml\nfile you can tweak the configuration to align it with your\nsetup. The yaml file is extensively documented to help you align the\nconfiguration with your setup.\nOut of the box, the configuration file is setup for:\nSee the resource requ"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn how to work with any data and your own vectors, using Weaviate and a pre- vectorized movie dataset. You will learn how to search through that data using vector, keyword and hybrid searches, as well as filters. Use large language models to augment and transform retrieved data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors",
          "webPageMainText": "In this project-based course, you will learn how to work with any data and your own vectors, using Weaviate and a pre-vectorized movie dataset.\nYou will get hands-on experience on how to store and index objects and corresponding vectors. You will learn how to search through that data using vector, keyword and hybrid searches, as well as filters. You will also learn how to use Weaviate's retrieval augmented generation (RAG) capabilities to generate outputs based on the retrieved objects.\nSet up a Weaviate instance and connect to it.\nCreate a collection and import data with your own vectors.\nLearn how to use search functions in Weaviate.\nUse large language models to augment and transform retrieved data.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud has short-term, sandbox clusters and permanent, serverless clusters. To create a cluster, click the 'Create cluster' button on the WCD Dashboard page. The sandbox is free for 14 days, the sandbox expires and all data is deleted. To retrieve a copy of your sandbox data before it is deleted, use the cursor API."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/quickstart#explore-the-details-panel",
          "webPageMainText": "This Quickstart guide shows you how to get started with Weaviate Cloud (WCD).\n\nWhen you log into the WCD web console, the Dashboard tab lists your clusters. There are no clusters when you log in to a new account. WCD has short-term, sandbox clusters and permanent, serverless clusters.\nTo create a cluster, click the 'Create cluster' button on the WCD Dashboard page.\n\nFollow the steps to create a cluster:\nTo create a sandbox cluster, follow these steps:\nIt takes a minute or two to create the new cluster. When the cluster is ready, WCD displays a check mark (\u2714\ufe0f) next to the cluster name.\nThe sandbox is free for 14 days. After 14 days, the sandbox expires and all data is deleted. To retrieve a copy of your sandbox data before it is deleted, use the cursor API.To preserve your data and upgrade to a paid instance, contact us for help.\nServerless clusters require billing details. WCD prompts you to add billing details if you have not already added them.\nTo create a serverless cluster, follow "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this section, we will explore data import, including details of the batch import process. We will discuss points such as how vectors are imported, what a batch import is, how to manage errors, and some advice on optimization. Before you start this tutorial, you should follow the steps in the tutorials to have:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/import#import-setup",
          "webPageMainText": "In this section, we will explore data import, including details of the batch import process. We will discuss points such as how vectors are imported, what a batch import is, how to manage errors, and some advice on optimization.\nBefore you start this tutorial, you should follow the steps in the tutorials to have:\nWe will use the dataset below. We suggest that you download it to your working directory.\nDownload jeopardy_tiny.json\nAs mentioned in the schema tutorial, the schema specifies the data structure for Weaviate.\nSo the data import must map properties of each record to those of the relevant class in the schema. In this case, the relevant class is Question as defined in the previous section.\nEach Weaviate data object is structured as follows:\nMost commonly, Weaviate users import data through a Weaviate client library.\nIt is worth noting, however, that data is ultimately added through the RESTful API, either through the objects endpoint or the batch endpoint.\nAs the names suggest, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We've released a beta version of our new TypeScript client. It's available for you to try out on npm under the new name: weaviate-client. We\u2019ve made a lot of changes that mirror our client refresh in Python. We have better TypeScript support, a collections-first approach, and performance improvements."
              }
            ]
          },
          "url": "https://weaviate.io/blog/typescript-client-beta",
          "webPageMainText": "\nWe've released a beta version of our new TypeScript client. It's available for you to try out on npm under the new name: weaviate-client. We\u2019d also love any feedback you can share on the client and your experience using it. Please open an issue on the client GitHub repository. Besides the package name change, we\u2019ve made a lot of changes that mirror our client refresh in Python to bring the two closer to each other. We have better TypeScript support, a collections-first approach, and performance improvements.\nYou can try it here - Experimental clients.\nWith first-hand developer experience in mind, we\u2019re committed to making sure that the client libraries we provide are true to the optimum developer experience of each community. We got a lot of feedback on things we could do better in our TypeScript client and we\u2019re thrilled to share this beta version with you.\nWe recently released an update to our Python client. With TypeScript being the second most popular language choice for developer"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#configuration",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Follow these examples to migrate data manually when using a backup is not possible. The examples use two different Weaviate instances, exposed through different ports. The same process can be used for two different instances as well. These scripts should migrate cross-references as well as cursor-based exports."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/migrate",
          "webPageMainText": "Follow these examples to migrate data manually when using a backup is not possible. They cover all permutations between:\n  The examples use two different Weaviate instances, exposed through different ports. The same process can be used for two different instances as well.\n  Cross-references in Weaviate are properties. As such, you can retrieve cross-reference as a part of the object.\nThese scripts should migrate cross-references as well.\nCross-references are properties. As such, these cursor-based exports will include them.\nDuring restoration, restore the cross-referenced (i.e. \"to\") object first, then the object that contains the cross-reference (i.e. \"from\" object).\nCreate a collection (e.g. WineReview) at the target instance, matching the collection (e.g. WineReview) at the source instance.\nMigrate:\nThe migrate_data_from_weaviate_to_weaviate function is called to migrate the data.\nCreate a collection (e.g. WineReview) at the target instance, matching the collection (e.g. WineReview)"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C. The strength of consistency can be determined by applying the following conditions:The data schema in Weaviates is strongly consistent."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/consistency",
          "webPageMainText": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match.\nSchema consistency is extremely important, as the schema defines the structure, or the blueprint, of the data. For this reason, Weaviate uses a strong consistency protocol and Raft consensus algorithm for schema replication.\nData objects, on the other hand, are eventually consistent, which means that all nodes will eventually contain the most updated data if the data is not updated for a while. Weaviate uses a leaderless design with eventual consistency for data replication.\nThis difference reflects the trade-off inherent in consistency and availability, as described in the CAP Theorem. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C.\nThe strength of consistency can be determined by applying the following conditions:\nThe data schema in Weaviate is strongly consistent. Once you use Weaviate, the data schema is rarely chang"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Image search uses an image as a search input to perform vector similarity search.Configure an image vectorizer module for your collection to use images as search inputs. Use the Near Image operator to execute image search. Vote for the feature request. DYI code below."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/image",
          "webPageMainText": "Image search uses an image as a search input to perform vector similarity search.\nConfigure image search\nTo use images as search inputs, configure an image vectorizer module for your collection.\nFor details, see the modules reference page:\nUse the Near Image operator to execute image search.\nIf your query image is stored in a file, you can use the client library to search by its filename.\nNot available yet. Vote for the feature request. DYI code below.\nNot available yet. Vote for the feature request. DYI code below.\nYou can search by a base64 representation of an image:\nYou can create a base64 representation of an online image, and use it as input for similarity search as shown above.\nA Near Image search can be combined with any other operators (like filter, limit, etc.), just as other similarity search operators.\nSee the similarity search page for more details.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The vector index is a key component of Weaviate's search capabilities. It allows you to search for vectors based on their similarity to a query vector. Each index is configurable, allowing you to tune its performance to your specific use case. This course is self-contained. We recommend that you go through one of the 101-level courses, such as that for working with text."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/vector_index",
          "webPageMainText": "This course is self-contained. However, we recommend that you go through one of the 101-level courses, such as that for working with text, your own vectors, or multimodal data.\nThe vector index is a key component of Weaviate's search capabilities. It allows you to search for vectors based on their similarity to a query vector, and to retrieve the objects that are associated with those vectors.\nWeaviate offers multiple types of vector indexes, each with its own strengths and weaknesses. Each index is also configurable, allowing you to tune its performance to your specific use case.\nThis course will introduce you to the different types of vector indexes available in Weaviate, and how to configure them to best suit your use case.\nWhat is a vector index, and why is it important?\nLearn about the HNSW index type, and how to tune it for your use case.\nLearn about the flat index type, and how to tune it for your use case.\nLearn about the dynamic index type, and how to tune it for your use case"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_collections",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If not specified explicitly, the default distance metric in Weaviate iscosine. It can be set in the vectorIndexConfig field as part of the schema to any of the following types: larger distance values indicate lower similarity. If you're missing your favorite distance type and would like to contribute it, we'd be happy to review your PR."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/distances#available-distance-metrics",
          "webPageMainText": "If not specified explicitly, the default distance metric in Weaviate is\ncosine. It can be set in the vectorIndexConfig field as part of the schema (example) to any of the following types:\nIn all cases, larger distance values indicate lower similarity. Conversely, smaller distance values indicate higher similarity.\nIf you're missing your favorite distance type and would like to contribute it to Weaviate, we'd be happy to review your PR.\nOn a typical Weaviate use case the largest portion of CPU time is spent calculating vector distances. Even with an approximate nearest neighbor index - which leads to far fewer calculations - the efficiency of distance calculations has a major impact on overall performance.\nYou can use the following overview to find the best possible combination of distance metric and CPU architecture / instruction set.\nIf you like dealing with Assembly programming, SIMD, and vector instruction sets we would love to receive your contribution for one of the combinations t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-openai module enables Weaviate to obtain vectors using OpenAI or Azure OpenAI. The module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways. We suggest you only set any given parameter in one place to avoid confusion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-openai",
          "webPageMainText": "The text2vec-openai module enables Weaviate to obtain vectors using OpenAI or Azure OpenAI.\nKey notes:\nThe module usage instructions may vary based on whether you are using OpenAI directly or Azure OpenAI. Please make sure that you are following the right instructions for your service provider.\nFor example, the following may vary:\nThe module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways.\nWhere the same parameter can be set in multiple ways, setting it at query-time through the HTTP request header (if possible) will have the highest precedence.\nWe suggest you only set any given parameter in one place to avoid confusion.\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use text2vec-openai, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create o"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-openai module enables Weaviate to obtain vectors using OpenAI or Azure OpenAI. The module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways. We suggest you only set any given parameter in one place to avoid confusion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-openai#how-to-use",
          "webPageMainText": "The text2vec-openai module enables Weaviate to obtain vectors using OpenAI or Azure OpenAI.\nKey notes:\nThe module usage instructions may vary based on whether you are using OpenAI directly or Azure OpenAI. Please make sure that you are following the right instructions for your service provider.\nFor example, the following may vary:\nThe module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways.\nWhere the same parameter can be set in multiple ways, setting it at query-time through the HTTP request header (if possible) will have the highest precedence.\nWe suggest you only set any given parameter in one place to avoid confusion.\nIf you use Weaviate Cloud (WCD), this module is already enabled and pre-configured. You cannot edit the configuration in WCD.\nTo use text2vec-openai, you must enable it in your Docker Compose file (docker-compose.yml). You can do so manually, or create o"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The img2vec-neural module enables Weaviate to obtain vectors locally using a resnet50 model. It encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware. For new projects, we recommend using the multi2vec -clip module instead. This uses CLIP models, which uses a more modern model architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/img2vec-neural#nearimage",
          "webPageMainText": "For new projects, we recommend using the multi2vec-clip module instead of img2vec-neural. This uses CLIP models, which uses a more modern model architecture than resnet models used in img2vec-neural. CLIP models are also multi-modal, meaning they can handle both images and text and therefore applicable to a wider range of use cases.\nThe img2vec-neural module enables Weaviate to obtain vectors locally images using a resnet50 model.\nimg2vec-neural encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use img2vec-neural, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nThis configuration enables img2vec-neural, sets it as the default v"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C. The strength of consistency can be determined by applying the following conditions:The data schema in Weaviates is strongly consistent."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/consistency#repairs",
          "webPageMainText": "Data consistency is a property of a database that refers to whether data in different nodes do or do not match.\nSchema consistency is extremely important, as the schema defines the structure, or the blueprint, of the data. For this reason, Weaviate uses a strong consistency protocol and Raft consensus algorithm for schema replication.\nData objects, on the other hand, are eventually consistent, which means that all nodes will eventually contain the most updated data if the data is not updated for a while. Weaviate uses a leaderless design with eventual consistency for data replication.\nThis difference reflects the trade-off inherent in consistency and availability, as described in the CAP Theorem. In Weaviate, data consistency is tunable, so it's up to you how you make the trade-off between A and C.\nThe strength of consistency can be determined by applying the following conditions:\nThe data schema in Weaviate is strongly consistent. Once you use Weaviate, the data schema is rarely chang"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#hnsw-with-product-quantization-pq",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative search is a powerful tool that can transform your relationship with data. Instead of just simply fetching data from the database, Weaviate can transform the data before delivering it to you. To use generative search, a generative-xxx module must be enabled in the Weaviates instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_2/generative",
          "webPageMainText": "The core concept behind generative search is that instead of just simply fetching data from the database, Weaviate can transform the data before delivering it to you.\nThis ability to transform data makes generative search a powerful tool that can transform your relationship with data. Instead of a database simply being a store of information, it can work with your data to deliver outputs based on the data and a set of instructions.\nTo use generative search, a generative-xxx module must be enabled in the Weaviate instance.\nIf you are using WCD, generative modules are enabled by default (see docs. Otherwise, you must configure your Weaviate instance to make sure that a generative module is enabled.\nThis is outside the scope of this unit, but you can refer to the module configuration for information on how to configure each module.\nIf only one generative module is enabled for the Weaviate instance, Weaviate will automatically use that module for all generative tasks.\nOn the other hand, if"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "How to select an embedding model for your search and retrieval-augmented generation system. How to use OpenAI's embedding models trained with Matryoshka Representation Learning in a vector database like Weaviate. Learn how to optimize your prompts using DSPy compilers."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/how-to",
          "webPageMainText": "How to use OpenAI's embedding models trained with Matryoshka Representation Learning in a vector database like Weaviate\nHow to select an embedding model for your search and retrieval-augmented generation system.\nHow to implement a local Retrieval-Augmented Generation pipeline with Ollama language models and a self-hosted Weaviate vector database via Docker in\u00a0Python.\nLearn how to vectorize ~50 million objects and ingest into Weaviate using Modal!\nDive into using Weaviate for image recognition to find the \"needle in a haystack\"!\nOne prompt does not fit all language models. Learn how to optimize your prompts using DSPy compilers.\nHybrid Search for curious Web Developers with the new Weaviate TypeScript client and Next.js\nHurricane is a web application to demonstrate Generative Feedback Loops with blog posts.\nVerba is an open source Retrieval Augmented Generation (RAG) application built using a modular, customizable architecture that makes it easy for anyone to use AI methods to get perso"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.23 is already available on Weaviate Cloud - so try it out! This release includes improvements to Product Quantization (PQ) PQ requires a training step, so we created AutoPQ to take care of the training for you. In this release we have a new algorithm to determine the optimal segment size."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/release_1_23",
          "webPageMainText": "Weaviate 1.23 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f relating to this release:\n\n1.23 is already available on Weaviate Cloud - so try it out!\nFor more details, keep scrolling \u2b07\ufe0f!\n\n\nWeaviate introduced Product Quantization (PQ) earlier this year. Since then, we've improved how PQ works with your data. In v1.23 we've made it easier to get started. PQ requires a training step. We've heard that the training step was tricky to configure, so we created AutoPQ to take care of the training for you. Just enable AutoPQ in your system configuration. Then, any time you enable PQ on a new collection, AutoPQ takes care of training and initializes PQ for you.\nWe have other improvements too. PQ uses segments to compress vectors. In this release we have a new algorithm to determine the optimal segment size for your vectors. You can still set the segment size manually, but you shouldn't have to.\nTogether, AutoPQ and improved segment sizing make using PQ easier than ever.\n\n\nWeaviate now supports a f"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Filters let you include, or exclude, particular objects from your result set based on provided conditions. Add a filter to your query, to limit the result set. To filter with two or more conditions, use And or Or to define the relationship between the conditions. To create a nested filter, follow these steps."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/filters",
          "webPageMainText": "Filters let you include, or exclude, particular objects from your result set based on provided conditions.\nFor a list of filter operators, see the API reference page.\nAdd a filter to your query, to limit the result set.\nThe output is like this:\nTo filter with two or more conditions, use And or Or to define the relationship between the conditions.\n  The v4 Python client API provides  filtering by any_of, or all_of, as well as using & or | operators.\n  Use Filters.and and Filters.or methods to combine filters in the JS/TS v3 API.\n  These methods take variadic arguments (e.g. Filters.and(f1, f2, f3, ...)). To pass an array (e.g. fs) as an argument, provide it like so: Filters.and(...fs) which will spread the array into its elements.\nThe output is like this:\nYou can group and nest filters.\nThe output is like this:\nTo create a nested filter, follow these steps.\nFilters work with search operators like nearXXX, hybrid, and bm25.\nThe output is like this:\nThe ContainsAny operator works on text "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate can be accessed using the Python client library. You can check whether the Weaviate instance is up using the is_live function. We will not include the try-finally blocks in the remaining code snippets. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/setup_weaviate/communicate",
          "webPageMainText": "Here, we'll perform basic operations to communicate with Weaviate using the Python client library.\nYou can check whether the Weaviate instance is up using the is_live function.\nYou can retrieve meta information about the Weaviate instance using the meta function.\nThis will print the server meta information to the console. The output will look similar to the following:\nAfter you have finished using the Weaviate client, you should close the connection. This frees up resources and ensures that the connection is properly closed.\nWe suggest using a try-finally block as a best practice. For brevity, we will not include the try-finally blocks in the remaining code snippets.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Unlock the power of vector search with our guides. Our guides will help you conquer vector embeddings and build better AI applications. We'll also share some tips on how to use the technology in your own business. For more information on our guides, visit our guides page."
              }
            ]
          },
          "url": "https://weaviate.io/learn/knowledgecards",
          "webPageMainText": "Unlock the power of vector search. Our guides will help you conquer vector embeddings and build better AI applications.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Using a garbage-collected language is a trade-off between development complexity and execution time. The new GOMEMLIMIT feature can help you both increase GC-related performance as well as avoid GC- related out-of-memory situations. In this article, I will invite you on a journey."
              }
            ]
          },
          "url": "https://weaviate.io/blog/gomemlimit-a-game-changer-for-high-memory-applications",
          "webPageMainText": "\nRunning out of memory is never fun, but it's incredibly frustrating when you've already taken some precautions and calculated your exact memory needs. \"My application requires 4GB of memory. How is it possible I ran out of memory on my 6GB machine!?\". As it turns out, this was a real possibility in a garbage collected (\"GC\")  language like Golang. The emphasis is on the word \"was\" because Go 1.19 changes everything: The new GOMEMLIMIT feature can help you both increase GC-related performance as well as avoid GC-related out-of-memory (\"OOM\") situations.\nIn this article, I will invite you on a journey. We will cover:\nIn a garbage-collected language, such as Go, C#, or Java, the programmer doesn't have to deallocate objects manually after using them. A GC cycle runs periodically to collect memory no longer needed and ensure it can be assigned again. Using a garbage-collected language is a trade-off between development complexity and execution time. Some CPU time has to be spent at runtim"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This vector database benchmark is designed to measure and illustrate Weaviate's Approximate Nearest Neighbor (ANN) performance for a range of real-life use cases. The benchmark is open source, so you can reproduce the results yourself. For good starting point values and performance tuning advice, see HNSW Configuration Tips."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/benchmarks/ann",
          "webPageMainText": "This vector database benchmark is designed to measure and illustrate Weaviate's Approximate Nearest Neighbor (ANN) performance for a range of real-life use cases.\nThis is not a comparative benchmark that runs Weaviate against competing vector database solutions. \nTo discuss trade-offs with other solutions, contact sales.\nTo make the most of this vector database benchmark, you can look at it from different perspectives:\nFor each benchmark test, we set these HNSW parameters:\nFor good starting point values and performance tuning advice, see HNSW Configuration Tips.\nFor each set of parameters, we've run 10,000 requests, and we measured the following metrics:\nBy request, we mean:\nAn unfiltered vector search across the entire dataset for the given test. All\nlatency and throughput results represent the end-to-end time that your\nusers would also experience. In particular, these means:\nThis benchmark is open source, so you can reproduce the results yourself.\nThis section contains datasets model"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers object-level query functions. They are collectively referred to as Get queries within. A Get query requires the target collection to be specified. Metadata retrieval is optional in both GraphQL and gRPC calls. You can use retrieve groups of objects that match the query. The number of groups and objects per group can be limited."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/get#vector-search-operators",
          "webPageMainText": "This page covers object-level query functions. They are collectively referred to as Get queries within.\nA Get query requires the target collection to be specified.\nIn GraphQL calls, the properties to be retrieved to be must be specified explicitly.\nIn gRPC calls, all properties are fetched by default.\nMetadata retrieval is optional in both GraphQL and gRPC calls.\nEach Get query can include any of the following types of arguments:\nThe above query will result in something like the following:\nWithout any arguments, the objects are retrieved according to their ID.\nAccordingly, such a Get query is not suitable for a substantive object retrieval strategy. Consider the Cursor API for that purpose.\nYou can use retrieve groups of objects that match the query.\nThe groups are defined by a property, and the number of groups and objects per group can be limited.\n  The other clients do not yet natively support groupby operations. Please use \"raw\" graphql queries to perform groupby operations.\nWhere "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "As Weaviate\u2019s head of developer relations, my job is all about connecting with developers in our open-source community. I prefer giving talks in person as opposed to remotely. I need that person-to-person connection. I want to help other team members become effective advocates in their own far-flung developer communities."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/creating-great-talks",
          "webPageMainText": "\nAs Weaviate\u2019s head of developer relations, my job is all about connecting with developers in our open-source community. That means going to events and taking every public speaking opportunity. And, since Weaviate is a remote-first company with employees on several continents, I\u2019m also engaged in helping other team members to become effective advocates in their own far-flung developer communities. Not to unnecessarily typecast a diverse group, but many developers aren\u2019t natural performers. All the more reason, then, to write this post.\nWeaviate - the vector search technology that we create - is like a great toolbox.  It doesn't do anything by itself. But in capable hands - of builders, dreamers and creators - it can be used to build amazing things. So, it's super important that we connect with \u201cdoers\u201d and developers all over the world.\nEven though we\u2019ve all adapted to remote work, I prefer giving talks in person as opposed to remotely. I need that person-to-person connection. I want pe"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "VIT works by using GPT-4 to generate instructions for corresponding images and captions. This dataset is used to train LLaVA to learn to follow instructions and understand images. A vision encoder (CLIP ViT 40) is combined with an LLM to process text and images and generate text."
              }
            ]
          },
          "url": "https://weaviate.io/papers/vit",
          "webPageMainText": "\nHow do you teach a Large Language Model to see? Here's a breakdown!\nThis paper proposes a technique called Visual Instruction Tuning that is now used by many of the language vision models we see in the field such as LLaVA, GPT4-Vision and Gemini etc.\nThe paper introduces a method to generate multimodal language-image instruction-following data using a language-only GPT-4 model. This data is then used to train LLaVA, a model that combines a vision encoder and a large language model (LLM) for general-purpose visual and language understanding.\nVIT works by using GPT-4 to generate instructions for corresponding images and captions. This dataset is used to train LLaVA to learn to follow instructions and understand images. A vision encoder (CLIP ViT 40) is combined with an LLM (Vicuna) to process text and images and generate text.\nLLaVA consists of two main components:\nVision Encoder (VE): A pre-trained vision encoder (e.g. CLIP) that takes an image as input and generates a visual embedding"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The average human hears and learns from about 1 billion words in their entire lifetime. This might be an over-approximation, but it is in the correct ballpark because 1 billion seconds is about 30 years. From this, we can infer that the way humans learn is fundamentally different from how our current state-of-the-art models learn."
              }
            ]
          },
          "url": "https://weaviate.io/blog/multimodal-RAG",
          "webPageMainText": "\nThe average human hears and learns from about 1 billion words in their entire lifetime. This might be an over-approximation, but it is in the correct ballpark because 1 billion seconds is about 30 years and we don\u2019t hear more than a few words per second. Accounting for sleeping, eating, and other activities; doing some back-of-the-napkin calculations, we can arrive at the above number.\nThe issue, however, is that current Large Language Models(LLMs) are trained on trillions of tokens, many orders of magnitude more data than we ever see in our lifetime, and yet they still don\u2019t have as vivid of an understanding of the causal relationships that exist in the world. From this, we can infer that the way humans learn is fundamentally different from how our current state-of-the-art models learn.\nHumans have a remarkable ability to learn and build world models through the integration of multiple sensory inputs. Our combination of senses work synergistically to provide us with rich and diverse "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Kubernetes is an open-source container orchestration platform. It means that you can use Kubernetes to deploy, scale, and manage containerized applications. Here, you learn how to do this using Minikube, a handy tool that allows you to run a Kuberne cluster on your local machine."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/deployment/k8s/kubernetes_basics",
          "webPageMainText": "Kubernetes is an open-source container orchestration platform. It means that you can use Kubernetes to deploy, scale, and manage containerized applications.\nIn production, Kubernetes is used to manage a cluster of nodes, such as those located on cloud providers like AWS, Google Cloud, or Azure, or on your own on-premises infrastructure.\nHere, you learn how to do this using Minikube, a handy tool that allows you to run a Kubernetes cluster on your local machine for development and testing purposes.\nIf you are looking to deploy Weaviate on a production Kubernetes cluster, the steps are similar. You will just need to replace Minikube with your production Kubernetes cluster.\nAs there are many variations in Kubernetes deployments, we recommend you follow the deployment instructions provided by your cloud provider or Kubernetes distribution for this purpose.\nFor this tutorial, you will need the following tools:\nIf you don't have any of these tools installed, you can follow the installation i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Google AI Studio and Google Vertex AI APIs allows you to access their models' capabilities directly from Weaviate. At the time of writing (November 2023), AI Studio is not available in all regions. The model provider integration pages are new and still undergoing improvements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/google/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Google AI Studio and Google Vertex AI APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use a Google AI embedding model, and Weaviate will generate embeddings for various operations using the specified model and your Google AI API key. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nAt the time of writing (November 2023), AI Studio is not available in all regions. See this page for the latest information.\nYour Weaviate instance must be configured with the Google AI vectorizer integration (text2vec-palm) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou mus"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Binary quantization (BQ), is a technique used to compress vectors. In Weaviate, it can be used to reduce the size of the in-memory HNSW index or the disk-based flat index. BQ is a relatively simple algorithm, but can perform well in the right circumstances."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/compression/bq",
          "webPageMainText": "Binary quantization (BQ), is a technique used to compress vectors. In Weaviate, it can be used to reduce the size of the in-memory HNSW index or the disk-based flat index.\nFor HNSW, BQ can decrease its memory footprint and thus improve performance and reduce resource requirements as well as costs. For the flat index, BQ can reduce the size of the index on disk, which can improve performance.\nBinary quantization compresses vectors by reducing each dimension to a single bit, either 0 or 1.\nIn other words, a n-dimensional vector composed of n floating point numbers is compressed to a n-dimensional vector composed of n bits.\nThis will reduce the size of the vector by a factor of 32 (from 32 bits per float to 1 bit per dimension).\nBQ is a relatively simple algorithm, but can perform well in the right circumstances. It is particularly suitable for high-dimensional vectors, where even with BQ, the vector can retain a high degree of information.\nWe suggest using BQ for vectors that have been d"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate TypeScript client supports TypeScript and JavaScript. The v3 client supports server side development (Node.js hosted). See v3 packages for details. If your application is browser based, consider using the TypeScript clients v2 and v3. The default gRPC port is 50051. To map the Weaviates gR PC port in your Docker container to a local port, add this code to your docker-compose.yml file."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript/v2_v3_migration",
          "webPageMainText": "The Weaviate TypeScript client supports TypeScript and JavaScript.\nThe v3 client supports server side development (Node.js hosted). See v3 packages for details. If your application is browser based, consider using the TypeScript client v2.\nTo install the TypeScript client v3, follow these steps:\nUpdate Node.js\nThe v3 client requires Node v18 or higher.\nInstall the new client package\nUpgrade Weaviate\nThe v3 client requires Weaviate core 1.23.7 or higher. Whenever possible, use the latest versions of Weaviate core and the Weaviate client.\nOpen a gRPC port\nThe default gRPC port is 50051.\n To map the Weaviate gRPC port in your Docker container to a local port, add this code to your docker-compose.yml file:\nThe weaviate object is the main entry point for all API operations. The v3 client instantiates the weaviate object and creates a connection to your Weaviate instance.\nIn most cases, you should use one of the connection helper functions to connect to your Weaviate instance:\nYou can also u"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Filters let you include, or exclude, particular objects from your result set based on provided conditions. Add a filter to your query, to limit the result set. To filter with two or more conditions, use And or Or to define the relationship between the conditions. To create a nested filter, follow these steps."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/filters#nest-filters",
          "webPageMainText": "Filters let you include, or exclude, particular objects from your result set based on provided conditions.\nFor a list of filter operators, see the API reference page.\nAdd a filter to your query, to limit the result set.\nThe output is like this:\nTo filter with two or more conditions, use And or Or to define the relationship between the conditions.\n  The v4 Python client API provides  filtering by any_of, or all_of, as well as using & or | operators.\n  Use Filters.and and Filters.or methods to combine filters in the JS/TS v3 API.\n  These methods take variadic arguments (e.g. Filters.and(f1, f2, f3, ...)). To pass an array (e.g. fs) as an argument, provide it like so: Filters.and(...fs) which will spread the array into its elements.\nThe output is like this:\nYou can group and nest filters.\nThe output is like this:\nTo create a nested filter, follow these steps.\nFilters work with search operators like nearXXX, hybrid, and bm25.\nThe output is like this:\nThe ContainsAny operator works on text "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is not a continuously deployed application, as it is published as releases and users install Weaviate themselves. Nevertheless, we aim to treat it with the same level of CI/CD-maturity as one would a continuous deployedapplication. It is therefore not feasible to allow for true trunk-based development."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/cicd",
          "webPageMainText": "Weaviate is not a continuously deployed application, as it is published as releases\nand users install Weaviate themselves. Nevertheless, we aim to treat it with\nthe same level of CI/CD-maturity as one would a continuously deployed\napplication.\nAs Weaviate is open-source, we welcome everyone's contributions. It is therefore\nnot feasible to allow for true trunk-based development. Outside contributors\ndon't have write access to our master/main branches. And the \"GitHub flow\"\n(small PRs for every contribution) is well established in the OSS community.\nNevertheless, we believe in the benefits of trunk-based development and want to\nget as close to it as possible.\nIn practice this means:\nKeep every single commit production ready. Do not use the comfort of a branch\nto temporarily ignore quality standards, knowing that you can still fix them\nbefore creating a Pull Request. As a rule of thumb, every commit should have a\npassing test suite and should not contain anything that you wouldn't want to"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Google Vertex AI APIs allows you to access their models' capabilities directly from Weaviate. You must provide valid API credentials to Weavia. For vector and hybrid search operations, Weaviates converts queries of one or more modalities into embeddings."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/google/embeddings-multimodal",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Google Vertex AI APIs allows you to access their models' capabilities directly from Weaviate.\nMultimodal embeddings are currently not available to Google AI Studio users.\nConfigure a Weaviate vector index to use a Google AI embedding model, and Weaviate will generate embeddings for various operations using the specified model and your Google AI API key. This feature is called the vectorizer.\nAt import time, Weaviate generates multimodal object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts queries of one or more modalities into embeddings.\n\nYour Weaviate instance must be configured with the Google AI vectorizer integration (multi2vec-palm) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide valid API credentials to Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate provides powerful filtered vector search capabilities. You can eliminate candidates in your \"fuzzy\" vector search based on individual properties. Thanks to Weaviate's efficient pre-filtering mechanism, you can keep the recall high - even when filters are very restrictive."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/prefiltering#migration-to-roaring-bitmaps",
          "webPageMainText": "Weaviate provides powerful filtered vector search capabilities, meaning that you can eliminate candidates in your \"fuzzy\" vector search based on individual properties. Thanks to Weaviate's efficient pre-filtering mechanism, you can keep the recall high - even when filters are very restrictive. Additionally, the process is efficient and has minimal overhead compared to an unfiltered vector search.\nSystems that cannot make use of pre-filtering typically have to make use of post-filtering. This is an approach where a vector search is performed first and then some results are removed which do not match the filter. This leads to two major disadvantages:\nThe limitations of post-filtering are overcome by pre-filtering. Pre-Filtering describes an approach where eligible candidates are determined before a vector search is started. The vector search then only considers candidates that are present on the \"allow\" list.\nSome authors make a distinction between \"pre-filtering\" and \"single-stage filte"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A filter is a way to specify additional criteria to be applied to the results. There are a number of available filters in Weaviate. The where filter is analogous to the WHERE clause in a SQL query. As in the SQL clause, the where filter can be used to apply a boolean conditional to the data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_1/filters",
          "webPageMainText": "So far, you've seen different query functions such as Get, and Aggregate, and search operators such as nearVector, nearObject and nearText.\nNow, let's take a look at filters.\nA filter is a way to specify additional criteria to be applied to the results. There are a number of available filters in Weaviate.\nThere exist many available filters, but we do not need to cover them all at this moment. For now, let's explore a few of the most commonly used filters:\nThe where filter is analogous to the WHERE clause in a SQL query. As in the SQL clause, the where filter can be used to apply a boolean conditional to the data.\nWe ran an example query like this earlier:\nWhich returned these answers:\nSo let's extend our query to now include a where argument that uses a Like operator.\nCan you guess how you would expect the earlier response to change, if at all?\nHere is the actual response:\nObserve that the results have changed. The previous results have been removed as they do not contain the text rock"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Semantic search overcomes the shortcomings of keyword-based search. Bi-Encoder models are fast, but less accurate, while Cross-Encoders are more accurate, but slow. Luckily, we can combine them in a search pipeline to benefit from both models."
              }
            ]
          },
          "url": "https://weaviate.io/blog/cross-encoders-as-reranker",
          "webPageMainText": "\nSemantic search overcomes the shortcomings of keyword-based search. If you search for \"programming for data scientists\", a keyword search will find \"An intro to programming for data scientists\", but it won't return \"Python for Machine Learning use-cases\".\nVector databases can use machine learning to capture the context and semantics of data and search queries. Usually, machine learning models have a tradeoff between high accuracy and speed. The higher the accuracy, the more computationally expensive the model is. If we talk about search or Information Retrieval, we would like to see accurate search results, encompassing wide-range queries, whilst retaining high speed.\nIn search, or semantic matching of sentences, we can see this tradeoff in Bi-Encoder models compared with Cross-Encoder models. Bi-Encoder models are fast, but less accurate, while Cross-Encoders are more accurate, but slow. Luckily, we can combine them in a search pipeline to benefit from both models!\nIn this article, y"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with the Hugging Face Transformers library allows you to access their CLIP models' capabilities directly from Weaviate.Configure a Weaviates vector index to use the CLIP integration. You can build a custom CLIP model image to use with Weaviated."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings-multimodal-custom-image",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with the Hugging Face Transformers library allows you to access their CLIP models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use the CLIP integration, and configure the Weaviate instance with a model image, and Weaviate will generate embeddings for various operations using the specified model in the CLIP inference container. This feature is called the vectorizer.\nThis page shows how to build a custom CLIP model image and configure Weaviate with it, for users whose desired model is not available in the pre-built images.\nOnce a custom image is built and configured, usage patterns are identical to the pre-built images.\nYou can build a custom CLIP model image to use with Weaviate. This can be a public model from the Hugging Face model hub, or a compatible private or local model.\nAny public SBERT CLIP models f"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) instances come with modules pre-configured. Weaviate's functionality can be customized by using modules. This page explains how to enable and configure modules. At the instance level, you can: enable modules by setting the appropriate environment variables as shown below."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/modules",
          "webPageMainText": "Weaviate's functionality can be customized by using modules. This page explains how to enable and configure modules.\nAt the instance (i.e. Weaviate cluster) level, you can:\nThis can be done by setting the appropriate environment variables as shown below.\nWeaviate Cloud (WCD) instances come with modules pre-configured. See this page for details.\nYou can enable modules by specifying the list of modules in the ENABLE_MODULES variable. For example, this code enables the text2vec-contextionary module.\nTo enable multiple modules, add them in a comma-separated list.\nThis example code enables the 'text2vec-huggingface, generative-cohere, and qna-openai modules.\nYou may need to specify additional environment variables to configure each module where applicable. For example, the backup-s3 module requires the backup S3 bucket to be set via BACKUP_S3_BUCKET, and the text2vec-contextionary module requires the inference API location via TRANSFORMERS_INFERENCE_API.\nRefer to the individual module docum"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Over the past six months, Weaviate has doubled in size; we\u2019re now nearly 30 people. At this point, we have team members based in Europe, the U.S., South America, and Australia. Some colleagues who have been working closely on the same team for months have never met face-to-face."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/first-company-workation",
          "webPageMainText": "\nOver the past six months, Weaviate has doubled in size; we\u2019re now nearly 30 people. At this point, we have team members based in Europe, the U.S., South America, and Australia. Some colleagues who have been working closely on the same team for months have never met face-to-face. So, we\u2019re super-excited that in a couple of weeks, we\u2019ll all be in the same place, at the same time, for the first time. As a bonus, it\u2019s in Italy!\nOur location is The Workation Village in the Piemonte region of Italy. This was an actual village for centuries, though like many Italian hill-towns, it lost most of its population in recent decades. A group of entrepreneurs have restored the buildings, and created an idyllic rural campus. They describe it as \u201cA magical place in nature for team retreats and company offsites - to reconnect in the remote age and to be inspired.\u201d\nWe\u2019re committed to our remote-first structure. Despite the distance between us, we put a lot of effort into creating a cohesive team spirit."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Schema endpoint is for creating, reading, updating and deleting collections (also called collections) and properties. From v1.5.0 onwards, manual creation of a schema is optional. You can specify as few parameters as the collection name. For more details on these parameters, see the Schema configuration reference page."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/schema",
          "webPageMainText": "The schema endpoint is for creating, reading, updating and deleting collections (also called collections) and properties. The overall configuration is referred to as the schema.\nThe response will contain an array of objects.\nCreate a new data object collection in the schema.\nFrom v1.5.0 onwards, manual creation of a schema is optional. Learn more about Auto Schema.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nFor more details on these parameters, see the schema configuration reference page.\nYou can specify as few parameters as the collection name.\nOr you can manually specify any number of the possible parameters:\nRetrieves the configuration of a single collection in the schema.\nRemove a collection (and all its data objects).\nUpdate settings of an existing collection. Use this endpoint to alter an existing collection in the schema.\nSome settings are immut"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud has short-term, sandbox clusters and permanent, serverless clusters. To create a cluster, click the 'Create cluster' button on the WCD Dashboard page. The sandbox is free for 14 days, the sandbox expires and all data is deleted. To retrieve a copy of your sandbox data before it is deleted, use the cursor API."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/quickstart",
          "webPageMainText": "This Quickstart guide shows you how to get started with Weaviate Cloud (WCD).\n\nWhen you log into the WCD web console, the Dashboard tab lists your clusters. There are no clusters when you log in to a new account. WCD has short-term, sandbox clusters and permanent, serverless clusters.\nTo create a cluster, click the 'Create cluster' button on the WCD Dashboard page.\n\nFollow the steps to create a cluster:\nTo create a sandbox cluster, follow these steps:\nIt takes a minute or two to create the new cluster. When the cluster is ready, WCD displays a check mark (\u2714\ufe0f) next to the cluster name.\nThe sandbox is free for 14 days. After 14 days, the sandbox expires and all data is deleted. To retrieve a copy of your sandbox data before it is deleted, use the cursor API.To preserve your data and upgrade to a paid instance, contact us for help.\nServerless clusters require billing details. WCD prompts you to add billing details if you have not already added them.\nTo create a serverless cluster, follow "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page contains information about how you can attach your own ML model to Weaviate. A custom vectorizer module is, for example, a model that is able to transform data (e.g. text or image data) to embeddings. This way, you can use Weaviates to scale your ML and NLP models."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/other-modules/custom-modules#a-replace-parts-of-an-existing-module",
          "webPageMainText": "Besides using one of the out-of-the-box vectorization models, you can also attach your own machine learning model to Weaviate. This way, you can use Weaviate to scale your ML and NLP models, since Weaviate takes care of efficient data storage and retrieval. A custom vectorizer module is, for example, a model that you trained on your own training data, that is able to transform data (e.g. text or image data) to embeddings.\nIf you have model that already fits with an existing model architecture (e.g. Transformers), you don't have to write any custom code and you can just run this Transformer model with the existing text2vec-transformer module.\nThis page contains information about how you can attach your own ML model to Weaviate. You will need to attach your ML model to Weaviate's Module API as a module. First, there is some information about how (vectorizer/embedding) modules in Weaviate work.\nQuick links:\nRecorded during the Weaviate meetup \u2013 custom modules section starts @ 13:30min\nTo "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#invertedindexconfig--bm25",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This API client is compatible with Java 8 and beyond. The current Java client version is v4.7.0. The Java client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows. The suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviates instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/java",
          "webPageMainText": "The current Java client version is v4.7.0.\nThe package and import paths have been updated from technology.semi.weaviate to io.weaviate.\nSee the Migration Guide for more info.\nTo get the latest stable version of the Java client library, add this dependency to your project:\nThis API client is compatible with Java 8 and beyond.\nYou can use the client in your project as follows:\nFor more comprehensive information on configuring authentication with Weaviate, refer to the authentication page.\nThe Java client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows.\nThe suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviate instance.\nEach Weaviate instance in Weaviate Cloud (WCD) is pre-configured to act as a token issuer for OIDC authentication.\nSee our WCD authentication documentation for instructions on how to authenticate against WCD with your preferred Weaviate client.\nIf you"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "When OpenAI launched ChatGPT at the end of 2022, more than one million people had tried the model in just a week. Since then, OpenAI has been iteratively improving the underlying model, announcing the release of GPT (Generative Pretrained Transformer) 4.0."
              }
            ]
          },
          "url": "https://weaviate.io/blog/what-are-llms",
          "webPageMainText": "\nIn this blog we discuss:\nWhen OpenAI launched ChatGPT at the end of 2022, more than one million people had tried the model in just a week and that trend has only continued with monthly active users for the chatbot service reaching over 100 Million, quicker than any service before, as reported by Reuters and Yahoo Finance. Since then, OpenAI has been iteratively improving the underlying model, announcing the release of GPT (Generative Pretrained Transformer) 4.0 last week, with new and improved capabilities. It wouldn\u2019t be hyperbole to say that Natural Language Processing (NLP) and Generative Large Language Models (LLMs) have taken the world by storm.\n\nThough ChatGPT was not the first AI chatbot that has been released to the public, what really surprised people about this particular service was the breadth and depth of knowledge it had and its ability to articulate that knowledge with human-like responses. Aside from this, the generative aspect of this model is also quite apparent as i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate v3 TypeScript client is now stable. Weaviate TypeScript and Next.js are now available in the same place. We're pleased to share that the Weaviates v3. TypeScript clients are now stable! We're also happy to announce that the next version of the Next.JS client is also now available."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/javascript",
          "webPageMainText": "We're pleased to share that the Weaviate v3 TypeScript client is now stable!\nHybrid Search for curious Web Developers with the new Weaviate TypeScript client and Next.js\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Use the after operator to retrieve all objects from a Weaviate instance. The after operator retrieves objects of a class based on the order of ids. You can pass the id of the last retrieved object as a cursor to start the next page. The offset parameter is a flexible way to page results as it allows use with parameters like sort."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/objects#create-a-data-object",
          "webPageMainText": "Use the after operator.\nList data objects in reverse order of creation. The data will be returned as an array of objects.\nA: This Aggregate query will output a total object count in a class.\nWithout any restrictions (across classes, default limit = 25):\nWith optional query params:\nYou can use limit and offset for paging results.\nThe offset parameter is a flexible way to page results as it allows use with parameters such as sort. It is limited by the value of QUERY_MAXIMUM_RESULTS which sets the maximum total number of objects that can be listed using this parameter.\nGet the first 10 objects:\nGet the second batch of 10 objects:\nGet the next batch of 10 objects:\nYou can use the after operator to retrieve all objects from a Weaviate instance . The after operator (\"Cursor API\") retrieves objects of a class based on the order of ids. You can pass the id of the last retrieved object as a cursor to start the next page.\nIt is not possible to use the after operator without specifying a class.\nF"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#change-logs",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Synthetic data is quite promising, but to see how far we can push the limit with it, this paper investigates what happens when text produced by a version of GPT forms most of the training dataset. What happens to GPT versions GPT-{n} as generation n increases? In short, it was found that \"model-collapse\" occurs."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper-4",
          "webPageMainText": "\nCan we use synthetic, LLM generated, data to train the next generations of bigger and better LLMs? How far will synthetic data take us in the pursuit of AGI?\ud83e\udd14\nA paper(https://arxiv.org/abs/2305.17493) from researchers at Oxford and Cambridge addressed these questions earlier this year.\nSynthetic data is quite promising, but to see how far we can push the limit with it, this paper investigates what happens when text produced by a version of GPT forms most of the training dataset of following models. What happens to GPT versions GPT-{n} as generation n increases?\n\nIn short, it was found that \"model-collapse\" occurs \u2013 a degenerative process whereby, over time, models forget the true underlying data distribution. Over time, you start losing information about the true distribution, which first starts with tails disappearing, and over the generations learned behaviors start converging to a point estimate with very small variance.\nIn other words - using synthetic data works at first but rely"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The multi2vec-clip module enables Weaviate to obtain vectors locally from text or images using a CLIP model. It encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware. As of Weaviates v1.24.2, you can use multiple inference containers."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-clip#neartext",
          "webPageMainText": "The multi2vec-clip module enables Weaviate to obtain vectors locally from text or images using a CLIP model.\nmulti2vec-clip encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use multi2vec-clip, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nAs of Weaviate v1.24.2, you can use multiple inference containers with multi2vec-clip. This allows you to use different models for different collections by setting the inferenceUrl in the collection configuration.\nThis configuration enables multi2vec-clip, sets it as the default vectorizer, and sets the parameters for the Docker container, including setting it to use multi2vec-clip:sentence"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Binoculars is a technique that requires no training and can 0-shot detect 90% of LLM-generated content at a 0.01% false positive rate. Human tokens are, on average more surprising to LLMs than other LLM tokens. They use this insight to identify a classification threshold."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper24",
          "webPageMainText": "\nCan you reliably tell apart fake, LLM-generated, text from human-written text?\ud83e\udd16\u2696\ufe0f\ud83d\udc71\nBinoculars is a technique that requires no training and can 0-shot detect 90% of LLM-generated content at a 0.01% false positive rate.\nHuman tokens are, on average more surprising to LLMs than other LLM tokens. They use this insight to identify a classification threshold.\nGiven two LLMs, M1 and M2. Their main insight is that human text should diverge from M1 more than M2 diverges from M1, provided the LLMs M1 and M2 are more similar to each other than they are to a human.\nThey look at the text in question through the lenses of two different LMs and calculate two perplexity scores:\nPerplexity of the text using an \"observer\" LLM(M1).\nCompute all the next-token predictions that a \"performer\" LLM(M2) would make at each position in the string, and compute their perplexity according to the \"observer\" LLM(M1).\nThen, they take the ratio of the two PPL scores: PPL1/PPL2. \nIf the string is written by a machine, w"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The TypeScript client can be used for both JavaScript and TypeScript scripts. The client is version v3.0.5. The suitable authentication options and methods for the client largely depend on the client's version of Weaviate. Use the TypeScript v3 client for new projects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript/typescript-v2",
          "webPageMainText": "The TypeScript client is version v3.0.5. Use the TypeScript v3 client for new projects.\nThe TypeScript client can be used for both JavaScript and TypeScript scripts.\nTo install the TypeScript client library package, use npm.\nOnce installed, you can use the client in your TypeScript and JavaScript scripts, as shown in the following examples.\nIf you are having any issues with the import statement in TypeScript (e.g. if weaviate is undefined), try adding \"esModuleInterop\": true to your \"compilerOptions\" in tsconfig.json.\nThe type definitions can be found under the types subdirectory of the package in the *.d.ts files, for example as shown on the npm package page.\nFor more comprehensive information on configuring authentication with Weaviate, refer to the authentication page.\nThe TypeScript client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows.\nThe suitable authentication options and methods for the client largely depend on the spe"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets. The fusion method and the relative weights are configurable. The search rankings are part of the object metadata. Weaviate uses the score to order the search results. To see the object rankings, set the explain score field in your query."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/hybrid#fusion-ranking-method",
          "webPageMainText": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets.\nThe fusion method and the relative weights are configurable.\nCombine the results of a vector search and a keyword search. The search uses a single query string.\nThe output is like this:\nA hybrid search on a collection that has named vectors must specify a target vector. Weaviate uses the query vector to search the target vector space.\nThe output is like this:\nTo see the object rankings, set the explain score field in your query. The search rankings are part of the object metadata. Weaviate uses the score to order the search results.\nThe output is like this:\nHybrid search results can favor the keyword component or the vector component. To change the relative weights of the keyword and vector components, set the alpha value in your query.\nThe output is like this:\nRelative Score Fusion is the default fusion method starting in v1.24.\nThe output is like this:\nFor a discussion of"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate (we-vee-eight) is an open source, AI-native vector database. Just bring your text data to Weaviate and it will do the rest. Multiple deployment options are available to cater for different users and use cases. All options offer vectorizer and RAG module integration."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate#what-is-weaviate",
          "webPageMainText": "Weaviate (we-vee-eight) is an open source, AI-native vector database. Use this documentation to get started with Weaviate and to learn how to get the most out of Weaviate's features.\nStart with the Quickstart tutorial - an end-to-end demo that takes 15-30 minutes.\nPlease visit our forum. The Weaviate team and our awesome community can help.\nGetting Started\nMultiple deployment options are available to cater for different users and use cases. All options offer vectorizer and RAG module integration.\nChoose your next step. Weaviate is flexible and can be used in many contexts and scenarios.\nJust bring your text data to Weaviate and it will do the rest.\nJust populate Weaviate with your text data and start using powerful vector, keyword and hybrid search capabilities.\nAnd use our integrations to build generative ai tools with your data.\nDo you prefer to work with your own vectors? No problem.\nYou can add your own vectors to Weaviate and still benefit from all of its indexing and search capab"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Unstructured data is especially hard to index, manage and understand. Since around 80% of all data is unstructured, it is hard to actually search and retrieve insights from most of the data. Searching by fuzzy terms and classification of rich data like free text becomes possible with Weaviate. It uses AI-driven indexing and search technologies."
              }
            ]
          },
          "url": "https://weaviate.io/blog/understand-your-unstructured-data",
          "webPageMainText": "\nThese days, more and more organizations are adopting a data-driven culture. Business processes and customer experience benefit from good data collection, management and analysis. But in order to really benefit from available data, it is essential to also understand the unstructured data, like free text in PDF documents, emails, invoices or voice transcriptions. Unstructured data is especially hard to index, manage and understand. Since around 80% of all data is unstructured, it is hard to actually search and retrieve insights from most of the data.\nThe Weaviate vector database unlocks the potential of unstructured data. Searching by fuzzy terms and classification of rich data like free text becomes possible with Weaviate. It uses AI-driven indexing and search technologies to enable real-time text processing. With machine learning methods, Weaviate automatically classifies texts. Finding information you are looking for and providing recommendations is possible because knowledge and inf"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.19 brings a set of great features, performance improvements, and fixes. A downgrade to v1.18 will no longer be supported. You can now group Get search results based on a specific property. The groups and objectsPerGroup limits are custom."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-19-release#grpc-api-support-experimental",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.19, which brings a set of great features, performance improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\nKeep in mind that after upgrading to v1.19 a downgrade to v1.18 will no longer be supported. If you anticipate having to downgrade, please create a backup before upgrading! If a backup is done with v1.18 before upgrading, you can always go back to v1.18 if you wish.\n\nWith the introduction of this feature, you can now group Get search results based on a specific property.\nTake a collection of Passage objects for example, each object belonging to a Document. If searching through Passage objects, you can group the results according to any property of the Passage, including the cross-reference property that represents the Document each Passage is associated with.\nThe groups and objectsPerGroup limits are customi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this unit, you learned about additional types of queries, including keyword (BM25), hybrid, generative and QnA searches. Combined with the tools that you learned earlier in Queries 1, you are now armed with a variety of search tools. Each of these tools allow you to interrogate the data differently."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_2/wrap_up",
          "webPageMainText": "In this unit, you learned about additional types of queries, including keyword (BM25), hybrid, generative and QnA searches. Combined with the tools that you learned earlier in Queries 1, you are now armed with a variety of search tools.\nEach of these tools allow you to interrogate the data differently. Being aware of how each type works will allow you to formulate the right query for your tasks.\nBM25 searches for example can be used for precise keyword searches, and a hybrid search allows you to combine results of both BM25 and vector searches. Meanwhile, generative searches and QnA searches transform your data before it is delivered to the user. These searches leverage the power of language models, bringing your data to life and allowing Weaviate to go further than simple data retrieval.\nHaving finished this unit, you should be able to:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate modules are options components to enhance Weaviate's functionality. The structure of the module name (x2vec) informs you of what the module does. For example, if you use the text2vec modules, the GraphQL filter nearText becomes available."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/modules",
          "webPageMainText": "In this guide, you will get an introduction to the role that modules play in Weaviate.\nAs their name suggest, Weaviate modules are options components to enhance Weaviate's functionality, such as to vectorize data or process results (e.g., question answering). The structure of the module name (x2vec) informs you of what the module does. E.g., text2vec generates text embeddings, img2vec image embeddings, etc.\nVectorizers and rerankers are used for vector search, which goes both for vectorizing the data objects and the queries. For example, if you use the text2vec modules, the GraphQL filter nearText becomes available. It will automatically vectorize your query and match it against the vectors stored in the index.\nYou can set up the vectorization per class as follows:\nNext, you need to tell Weaviate what you want to have vectorized. Only the payload, or do you also want to include the class name and the property name?\nThe reason you can index class names and property names is that they so"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#indexfilterable-and-indexsearchable",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate v3 TypeScript client is now stable. We're pleased to share that the Weaviate. v3 typeScript clients are now stable! We're also happy to announce the release of Weaviates. v4 TypeScript clients. We've released a new version of the client for TypeScript users."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/clients",
          "webPageMainText": "We're pleased to share that the Weaviate v3 TypeScript client is now stable!\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Recent breakthroughs in Large Language Model (LLM) technology are positioned to transition many areas of software. Search and Database technologies have an interesting entanglement with LLMs. There are cases where Search improves the capabilities of LLMs as well as where inversely, LLMs improve the capabilities. We will break down 5 key components of the intersection between LLMs and Search."
              }
            ]
          },
          "url": "https://weaviate.io/blog/llms-and-search",
          "webPageMainText": "\nThe recent breakthroughs in Large Language Model (LLM) technology are positioned to transition many areas of software. Search and Database technologies particularly have an interesting entanglement with LLMs. There are cases where Search improves the capabilities of LLMs as well as where inversely, LLMs improve the capabilities of Search. In this blog post, we will break down 5 key components of the intersection between LLMs and Search.\nWe will also conclude with some thoughts on how Generative Feedback Loops fit into this picture.\nSince the inception of large language models (LLMs), developers and researchers have tested the capabilities of combining information retrieval and text generation. By augmenting the LLM with a search engine, we no longer need to fine-tune the LLM to reason about our particular data.This method is known as Retrieval-augmented Generation (RAG).\nWithout RAG, an LLM is only as smart as the data it was trained on. Meaning, LLMs can only generate text based pure"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with the Hugging Face Transformers library allows you to access their models' capabilities directly from Weaviate. This page shows how to build a custom Transformers model image and configure Weaviates with it. Once a custom image is built, usage patterns are identical to the pre-built images."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings-custom-image",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with the Hugging Face Transformers library allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use the Transformers integration, and configure the Weaviate instance with a model image, and Weaviate will generate embeddings for various operations using the specified model in the Transformers inference container. This feature is called the vectorizer.\nThis page shows how to build a custom Transformers model image and configure Weaviate with it, for users whose desired model is not available in the pre-built images.\nOnce a custom image is built and configured, usage patterns are identical to the pre-built images.\nYou can build a custom Transformers model image to use with Weaviate. This can be a public model from the Hugging Face model hub, or a compatible private or local model.\nEmb"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Large Language Models are heralding a new era in information technology. To better understand this revolution, it\u2019s important to consider the historical context. The printing press significantly reduced the cost of reproducing information. The internet cut out the middleman, making the distribution of information virtually free."
              }
            ]
          },
          "url": "https://weaviate.io/blog/generative-feedback-loops-with-llms",
          "webPageMainText": "\nLarge Language Models are heralding a new era in information technology. To better understand this revolution, it\u2019s important to consider the historical context. The printing press significantly reduced the cost of reproducing information, while the internet cut out the middleman, making the distribution of information virtually free. In Aggregation Theory, Ben Thompson writes about how the free distribution of the internet allowed companies to modularize (or unbundle) services and focus on user experience. Ben states that \u201ccompanies that win the user experience can generate a virtuous cycle where their ownership of consumers/users attracts suppliers which improves the user experience\u201d.\nEnter Large Language Models (LLMs), a world changing technology that enables transforming and generating information at incredible speeds and low cost. LLMs present the opportunity to expedite the virtuous cycle Aggregation Theory describes by commoditizing the human effort traditionally required to de"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open source project that is hosted on GitHub. GitHub uses issues to request features and to track projects. Weaviate uses your feedback to plan future releases. If an issue is important to you, upvote it to let us know. Alternatively, join our forum to discuss the roadmap in more detail."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/roadmap",
          "webPageMainText": "Weaviate is an open source project that is hosted on GitHub. GitHub uses issues to request features and to track projects. This page highlights some of the issues that Weaviate is working on for upcoming releases. \nWeaviate uses your feedback to plan future releases. If an issue is important to you, upvote it to let us know. To upvote an issue, click the  icon in GitHub. The backlog lists some open issues. If you have other suggestions, open a new issue.\nTo join a discussion on GitHub, click on the issue title, and then add a comment in the discussion section. Alternatively, join our forum to discuss the roadmap in more detail.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue. Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/filters#wildcard-literal-matches-with-like",
          "webPageMainText": "Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion. The operator used for filtering is also called a where filter.\nA filter may consist of one or more conditions, which are combined using the And or Or operators. Each condition consists of a property path, an operator, and a value.\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\nFor example, this filter will only allow objects from the class Article with a wordCount that is GreaterThan than 1000.\nThe where filter is an algebraic object, which takes the following arguments:\nIf the operator is And or Or, the operands are a list of where filters.\nWeaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue.\nThe behavior for the Equal operator on multi-word textual properties in where filters depends on the tokenization of the property.\nSee the Schema p"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The TypeScript client v3 supports Node.js server based development. To develop a browser based application, use the v2 client. If you have older code that uses the JavaScript client, update to the v3 client. The v2 version is still available in npm, however you should not use it to begin new projects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript#changelog",
          "webPageMainText": "The TypeScript client supports code that is written in TypeScript or JavaScript.\nThe TypeScript client v3 supports Node.js server based development. It does not support browser based web client development. To develop a browser based application, use the v2 client.\nThe v3 client is the current TypeScript client. If you have code written for the v2 client, you should migrate it to v3.\nThe v2 client version is still available in npm, however you should not use it to begin new projects.\nIf you have suggestions or comments on how to improve the new client, let us know:\nThe v3 TypeScript client replaces the v2 JavaScript only client. The JavaScript client is no longer supported. If you have older code that uses the JavaScript client, update to the TypeScript client.\nThese charts show the Weaviate client releases associated with Weaviate core releases.\nSee the client change logs on GitHub.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.15.1 has been released. This release includes two big community contributions from Aakash Thatte and Dasith Edirisinghe. We hope to see many more big and small contributions in the coming months and years. Read below to learn more about each of these points in more detail."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-15-release",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.15, which is packed with great features, significant performance improvements, new distance metrics and modules, and many smaller improvements and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\nWe have published a patch release v1.15.1.\nTo learn more check the Weaviate 1.15.1 patch release blog.\n\n\ud83d\ude00We are extremely happy about this release, as it includes two big community contributions from Aakash Thatte and Dasith Edirisinghe. Over the last few weeks, they collaborated with our engineers to make their contributions.\n\ud83d\ude80Aakash implemented the two new distance metrics, while Dasith contributed by implementing the two new Weaviate modules.\n  \ud83d\udc55We will send some Weaviate t-shirts to Aakash and Dasith soon.\n\ud83e\udd17We hope to see many more big and small contributions in the coming months and years. #CommunityRocks\n\nCreating and restoring "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Single vector collections are valid and continue to use the original collection syntax."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/multi-vector",
          "webPageMainText": "Weaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nSingle vector collections are valid and continue to use the original collection syntax. However, if you configure multiple vectors, you must use the new, named vector syntax.\nStarting in v4.5.0, the Python client supports named vectors.\nWeaviate collections require a schema. Use the schema definition to configure the vector spaces for each data object.\nData values can be stored as properties, vectors or both. In this example, each data object has two named vectors, jeopardy_questions_ve"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This tutorial is built with Next.js and Weaviate. It uses a beta version of the v3 TypeScript Client. Find out more about the new client here - Experimental clients. To understand hybrid search, we first need to understand the two technologies that power it - vector search and keyword search."
              }
            ]
          },
          "url": "https://weaviate.io/blog/hybrid-search-for-web-developers",
          "webPageMainText": "\nThis tutorial is built with Next.js and Weaviate. It uses a beta version of the v3 TypeScript Client. Find out more about the new client here - Experimental clients.\nWhen the question of search arises, two popular techniques take up most of the conversation: vector search and keyword search. But which should you use? Sometimes, the answer is both, which luckily for us happens to be hybrid search - the best of both worlds!\nIn this article, we\u2019ll get into the technology that powers hybrid search, learn how to use it in Weaviate and build a Next.js Application powered by hybrid search in Weaviate.\nTo understand hybrid search, we first need to understand the two technologies that power it - vector search and keyword search.\nVector search, also known as semantic search, uses machine learning to grasp text context, not just keywords. It converts text to numerical vectors, finding matches based on conceptual similarity for accurate, relevant search results. Behind the scenes, it uses approxi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This short course introduces you to Weaviate, and what it can do. You will develop intuitions about not only how weaviate works, but also how vectors work, and how vector searches work. The course is designed to teach you how to use Weaviates in your daily life."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/theory",
          "webPageMainText": "This short course introduces you to Weaviate, and what it can do.\nYou will develop intuitions about not only how Weaviate works, but also how vectors work, and how vector searches work.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This section helps you to get started with Weaviate. Use the weekly Newsquiz to test your knowledge of stories you saw on CNN.com. Visit CNN.co/Newsquiz each week for a chance to win a $1,000 prize for your best story."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/starter-guides",
          "webPageMainText": "This section helps you to get started with Weaviate.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Embedded Weaviate is a new deployment model that runs a Weaviates instance from your application code. It creates a permanent datastore in the location set in your persistence_data_path. The next time the client runs, it starts a new instance of Embedded weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/embedded",
          "webPageMainText": "Embedded Weaviate is experimental software. APIs and parameters may change.\nEmbedded Weaviate is a new deployment model that runs a Weaviate instance from your application code rather than from a stand-alone Weaviate server installation.\nWhen Embedded Weaviate starts for the first time, it creates a permanent datastore in the location set in your persistence_data_path. When your client exits, the Embedded Weaviate instance also exits, but the data persists . The next time the client runs, it starts a new instance of Embedded Weaviate. New Embedded Weaviate instances use the data that is saved in the datastore.\nWhen you exit the client, the Embedded Weaviate instance also exits.\nTo pass additional configuration details to your embedded instance, use a custom connection:\nTo configure Embedded Weaviate, set these variables in your instantiation code or pass them as parameters when you invoke your client. You can also pass them as system environment variables. All parameters are optional.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Voyage AI's APIs allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/voyageai/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Voyage AI's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an Voyage AI embedding model, and Weaviate will generate embeddings for various operations using the specified model and your Voyage AI API key. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the Voyage AI vectorizer integration (text2vec-voyageai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Voyage AI API key to Weaviate for this integration. Go to Voyage AI to sign up and obtain an API key.\nProvide the API key to Wea"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is more than just a database. It\u2019s a flexible platform for building powerful, production-ready AI applications. Our open source vector database and surrounding offerings are designed to support developers and teams of all sizes on their AI journey. Get the best of vector and keyword techniques with Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io",
          "webPageMainText": "Bring intuitive applications to life with less  hallucination, data leakage, and vendor lock-in\nImprove search experiences by merging vector and keyword techniques. Deliver contextual, precise results across all of your data in any modality, with less effort.\nBuild trustworthy generative AI applications using your own data, with privacy and security top-of-mind. Surface relevant and accurate answers using your favorite LLMs.\nMake your dataset smarter by enriching it with AI-generated answers. Improve personalization and spend less time on manual data cleaning.\nSoftware development is changing. Our open source vector database and surrounding offerings are designed to support developers and teams of all sizes on their AI journey.\nWeaviate is more than just a database. It\u2019s a flexible platform for building powerful, production-ready AI applications.\nOpen source with a strong community. Resources to help developers of all levels build production-ready AI apps.\nGet the best of vector and ke"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Large Language Models (LLMs) have revolutionized the way we interact and communicate with computers. LLMs are a versatile tool that is seen in many applications like chatbots, content creation, and much more. LangChain helps overcome many limitations of LLMs such as hallucination and limited input lengths."
              }
            ]
          },
          "url": "https://weaviate.io/blog/combining-langchain-and-weaviate",
          "webPageMainText": "\nLarge Language Models (LLMs) have revolutionized the way we interact and communicate with computers. These machines can understand and generate human-like language on a massive scale. LLMs are a versatile tool that is seen in many applications like chatbots, content creation, and much more. Despite being a powerful tool, LLMs have the drawback of being too general. Fortunately, there are emerging technologies that help solve this limitation.\nLangChain is one of the most exciting new tools in AI. LangChain helps overcome many limitations of LLMs such as hallucination and limited input lengths. Hallucination refers to where the LLM generates a response that is not supported by the input or context \u2013 meaning it will output text that is irrelevant, inconsistent, or misleading. As you can imagine, this is a huge problem in many applications. LLMs have a limited input length when referring to the scale of inputting a book or pages of search results. LangChain has various techniques implemen"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The results are based on a keyword search score using what's called the BM25f algorithm. You can also perform keyword (BM25) searches to find items based on their keyword similarity, or hybrid searches that combine BM25 and semantic/ vector searches. The limit parameter here sets the maximum number of results to return."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_searches/keyword_hybrid",
          "webPageMainText": "You can also perform keyword (BM25) searches to find items based on their keyword similarity, or hybrid searches that combine BM25 and semantic/vector searches.\nThis example finds entries in \"Movie\" with the highest keyword search scores for the term \"history\", and prints out the title and release year of the top 5 matches.\nThe results are based on a keyword search score using what's called the BM25f algorithm.\nThe limit parameter here sets the maximum number of results to return.\nThe return_metadata parameter takes an instance of the MetadataQuery class to set metadata to return in the search results. The current query returns the score, which is the BM25 score of the result.\nThis example finds entries in \"Movie\" with the highest hybrid search scores for the term \"history\", and prints out the title and release year of the top 5 matches.\nThe results are based on a hybrid search score. A hybrid search blends results of BM25 and semantic/vector searches.\nAs we are using custom vectors, w"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.20 is a new release of Weaviate. This release includes a number of new features. The most important new feature is the ability to store data from up to millions of tenants in a single setup. This means that scaling your business or infrastructure to include data from a large group of users is easier and faster than ever."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-20-release",
          "webPageMainText": "\nWeaviate 1.20 is here!\nAs always, a brand-new release means a set of brand-new features. Here are the \u2b50\ufe0fhighlights\u2b50\ufe0f:\nWe hope we've whetted your appetite - so what're you waiting for?! Keep scrolling \u2b07\ufe0f!\nDowngrading from 1.20.x to a 1.19.x or lower is not possible.\nPlease proceed with caution, such as by making a backup of your data & schema, or cluster before upgrading.\nStore data from up to millions of tenants in a single setup.\n\n\nWe\u2019ll keep this brief as Etienne covered this in great detail in this blog post. The key point, though, is that Weaviate now makes it easy to store data from up to millions of tenants in a single setup.\nThis means that scaling your business or infrastructure to include data from a large group of users is easier and faster than ever. We have worked with our community on this feature to ensure that your compliance needs are met as well as performance needs, while keeping the experience a smooth one for everybody. Our multi-tenancy implementation allows for h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "I heard of Weaviate through a video by the Youtuber Fireship. I have since used it whenever I needed a vector database for one of my side projects. Philip invited me to intern in his team after seeing our Hackathon project. I didn\u2019t hesitate long to take one semester off from my computer science bachelor."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/reflections-and-insights-on-my-internship-at-weaviate",
          "webPageMainText": "\nHey! I am Ajit, and I am currently interning at Weaviate's Developer Growth team. In this blog post, I reflect on the previous months and weeks to give you a sense of what it\u2019s like to be an intern at such a fast-growing, cutting-edge startup in a highly competitive space.\nI heard of Weaviate quite early through a video by the  Youtuber Fireship and have since used it whenever I needed a vector database for one of my side projects. One such occasion was a hackathon hosted by Anthropic last autumn, where I also met Philip, the Head of Developer Growth at Weaviate. We immediately struck up a conversation about Weaviate and the industry at large. Especially after seeing our Hackathon project, Philip invited me to intern in his team.\nPhilip\u2019s elaborations around Weaviate during the hackathon were highly interesting, and the prospect of working on something I had used myself in the past was exciting - and so I didn\u2019t hesitate long to take one semester off from my computer science bachelor "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The concept of word embeddings is similar to a supermarket. All the coordinates combined represent a multidimensional hyperspace (often around 300 dimensions) and words that  can be embedded. Weaviate uses a machine-learning algorithm called GloVe to turn individual words into embedDings."
              }
            ]
          },
          "url": "https://weaviate.io/blog/history-of-weaviate",
          "webPageMainText": "\nIn this article, I want to share the history of Weaviate, how the concept was born, and where we are heading towards in the near future.\nSomewhere early 2015 I was introduced to the concept of word embeddings through the publication of an article that contained a machine-learning algorithm to turn individual words into embeddings called GloVe.\nIf you are new to the world of word embeddings, a metaphor to understand them is in the form of a supermarket. The supermarket itself is a space in which products are stored based on the category they are in. Inside, you can find an apple by moving your shopping cart to the right coordinates in the fruit section and when you look around you, you'll find similar products like oranges, limes, bananas, etcetera, and you also know that a cucumber will be closer by than washing powder.\nThis is the same way a word embedding is structured. All the coordinates combined represent a multidimensional hyperspace (often around 300 dimensions) and words that "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate provides powerful filtered vector search capabilities. You can eliminate candidates in your \"fuzzy\" vector search based on individual properties. Thanks to Weaviate's efficient pre-filtering mechanism, you can keep the recall high - even when filters are very restrictive."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/prefiltering#flat-search-cutoff",
          "webPageMainText": "Weaviate provides powerful filtered vector search capabilities, meaning that you can eliminate candidates in your \"fuzzy\" vector search based on individual properties. Thanks to Weaviate's efficient pre-filtering mechanism, you can keep the recall high - even when filters are very restrictive. Additionally, the process is efficient and has minimal overhead compared to an unfiltered vector search.\nSystems that cannot make use of pre-filtering typically have to make use of post-filtering. This is an approach where a vector search is performed first and then some results are removed which do not match the filter. This leads to two major disadvantages:\nThe limitations of post-filtering are overcome by pre-filtering. Pre-Filtering describes an approach where eligible candidates are determined before a vector search is started. The vector search then only considers candidates that are present on the \"allow\" list.\nSome authors make a distinction between \"pre-filtering\" and \"single-stage filte"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#hnsw",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The vector database is cementing its place in the new AI stack. Conversations have changed since our last big conference. GenAI projects are moving forward and teams have a better idea of the stack they need to achieve their goals. People gravitated toward our booth because we were open source."
              }
            ]
          },
          "url": "https://weaviate.io/blog/google-next-recap",
          "webPageMainText": "\nTeam Weaviate attended our first Google Cloud Next and we had a blast! We connected with folks from our community, made lots of new friends, and shared our latest product features and trend predictions. Check out some of the highlights from our week in Vegas and a few things we learned along the way.\nOur team spoke with hundreds of people who came by our booth \u2013 whether they were learning about genAI for the first time or were elbows deep into their latest application in production. Here are some observations from our folks on site:\nThe vector database is cementing its place in the new AI stack. Conversations have changed since our last big conference. GenAI projects are moving forward and teams have a better idea of the stack they need to achieve their goals. We talked with a lot of people who had hands-on experience with vector databases, where six months ago most were still just learning what a vector database was.\nEnterprises \ud83d\udc9a open source. People gravitated toward our booth becau"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " vector databases use many techniques and algorithms to improve performance. efficient distance calculations between high-dimensional vectors is a requirement for a good vector database. 40%-60% of the CPU time is spent doing vector distance calculations. If you want to learn how to leverage algorithmic and hardware optimizations to make vector search 40% faster keep reading."
              }
            ]
          },
          "url": "https://weaviate.io/blog/intel",
          "webPageMainText": "\nOverview of Key Sections:\nWhat\u2019s the most important calculation a vector database needs to do over and over again? What simple operation does it spend the majority of its time performing?\nIf you guessed vector distance calculations \u2026 BINGO! \ud83c\udf89\nWhile vector databases use many techniques and algorithms to improve performance (including locality graphs, quantization, hash based approaches), at the end of the day, efficient distance calculations between high-dimensional vectors is a requirement for a good vector database. In fact, when profiling Weaviate indexed using HNSW, we find that 40%-60% of the CPU time is spent doing vector distance calculations.\nSo when someone tells us that they can make this quintessential process much faster they have our full attention! If you want to learn how to leverage algorithmic and hardware optimizations to make vector search 40% faster keep reading!\nIn this post we\u2019ll do a technical deep dive into different implementations for vector distance calculati"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Module system is a way to extend Weaviate's functionality. The user decides which modules are activated at startup through configuration. modules provide access to various machine-learning models which can be used to turn media into vectors at query and import time. We are going through the text2vec-transformers module as an example."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-modules/overview#module-characteristics",
          "webPageMainText": "The Module system in Weaviate is a way to extend Weaviate's functionality.\nModules often provide access to various machine-learning models which can be\nused to turn media into vectors at query and import time. However, that's not\nthe only thing a module can do; any extension on functionality can be\nincorporated into a module.\nThe user decides which modules are activated at startup through configuration.\nSome modules can be combined with each other, others might be conflicting. In\nthis case startup will fail.\nA module is essentially code which compiles with Weaviate, but a module can\nalso communicate with other services. We are going through the\ntext2vec-transformers module as an example.\nFrom a high level, the motivation for a user to enable this module would be to\nhave their imported data vectorized with a transformer module (e.g. BERT,\netc.). Additionally, at query time, the query string should also be vectorized\nin the same way.\nFrom a tech level this module therefore has to provide"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The latest Weaviate Python client library can be installed using pip. The client library is tested on Python 3.8 and later. The latest major version is v4 (e.g. 4.x.x). If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/setup_weaviate/client",
          "webPageMainText": "The latest Weaviate Python client library can be installed using pip. The client library is tested on Python 3.8 and later. Install it using the following command:\nThe latest major version is v4 (e.g. 4.x.x). You can check the version like so:\nFrom Python, you can load the Weaviate client library like so:\nThe client provides sets of helper classes (e.g. under weaviate.classes) and functions to make it easier to interact with Weaviate.\nNext, we'll show you how create a Weaviate instance and connect to it.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model. To use this module, you must enable it in your Docker Compose file. For production use cases, we recommend using other modules that use a more modern, transformer-based architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-contextionary#extending-the-contextionary-v1modulestext2vec-contextionaryextensions",
          "webPageMainText": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model.\nKey notes:\nAs a lightweight model, it is well suited for testing purposes.\nFor production use cases, we recommend using other modules that use a more modern, transformer-based architecture.\nThis module is not available on Weaviate Cloud.\nTo use text2vec-contextionary, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nContextionary:\nThis configuration enables text2vec-contextionary, sets it as the default vectorizer, and sets the parameters for the Contextionary Docker container.\nYou can configure how the module will behave in each class through the Weaviate schema.\nYou can set vectorizer behavior using the moduleConfig section under each class and property:\nIf you are using this module and are vectorizing the class or property name, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this section, we will explore data import, including details of the batch import process. We will discuss points such as how vectors are imported, what a batch import is, how to manage errors, and some advice on optimization. Before you start this tutorial, you should follow the steps in the tutorials to have:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/tutorials/import#batch-import-process",
          "webPageMainText": "In this section, we will explore data import, including details of the batch import process. We will discuss points such as how vectors are imported, what a batch import is, how to manage errors, and some advice on optimization.\nBefore you start this tutorial, you should follow the steps in the tutorials to have:\nWe will use the dataset below. We suggest that you download it to your working directory.\nDownload jeopardy_tiny.json\nAs mentioned in the schema tutorial, the schema specifies the data structure for Weaviate.\nSo the data import must map properties of each record to those of the relevant class in the schema. In this case, the relevant class is Question as defined in the previous section.\nEach Weaviate data object is structured as follows:\nMost commonly, Weaviate users import data through a Weaviate client library.\nIt is worth noting, however, that data is ultimately added through the RESTful API, either through the objects endpoint or the batch endpoint.\nAs the names suggest, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with OctoAI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/octoai",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nOctoAI offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with OctoAI's APIs, allowing users to leverage OctoAI's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nOctoAI's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with OctoAI's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformation steps.\nOctoAI embedding integration page\n\nOctoAI's generative AI models can generate human-like text based on given prompts and contexts.\nWeaviate's generative AI integration enables u"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate Cloud is a fully managed vector database service. It's the easiest way to get a vector database up and running within minutes. The service is free to use, but there are plans to make it available for paid use in the future. For more information on how to use the service, visit:\u00a0www.weaviate.com."
              }
            ]
          },
          "url": "https://weaviate.io/blog/wcs-public-beta",
          "webPageMainText": "\nLast November, we quietly introduced the private beta of the Weaviate Cloud Service, a fully managed vector database as a service. Today we are announcing a big upgrade to the Weaviate Cloud and availability of the public beta release of the service.\nThe Weaviate Cloud enables AI application developers to use the open source Weaviate vector database as a fully managed cloud service. It\u2019s the easiest way to get a vector database cluster up and running within minutes, so you can get right to loading, vectorizing, and searching your data.\nDuring the Weaviate Cloud private beta, we had several thousand people create free Weaviate Cloud sandboxes and try it out. We\u2019d like to thank everyone who tried it and gave us feedback; it was extremely helpful. We look forward to hearing about your experience with the new (and future versions), which you can still try for free here.\nHere\u2019s a quick overview of what\u2019s new and what\u2019s coming next.\nOne of the biggest changes from the private beta to today\u2019"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Configure your connection to provide authentication parameters and API keys for Weaviate and third-party services. Connect with services like Cohere, Hugging Face, and OpenAI to use their models with your data. To configure a connection, you need the following information:Weaviate Cloud (WCD), the dashboard has a \"Details\" button."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/starter-guides/connect",
          "webPageMainText": "Learn how to connect to Weaviate.\nConfigure your connection to provide authentication parameters and API keys for Weaviate and third-party services. Connect with services like Cohere, Hugging Face, and OpenAI to use their models with your data.\nTo configure a connection, you need the following information:\nWeaviate Cloud (WCD) If you are using Weaviate Cloud (WCD), the dashboard has a \"Details\" button. Click the button to get the following information:\nDocker and Kubernetes If you are using Docker or Kubernetes, your URL will depend on how the container is configured to provide access.\nDocker instances by default use the http://localhost:8080 address.\nEmbedded Weaviate If you are using Embedded Weaviate, you do not need to specify a URL when you create the client. Embedded instances usually don't need authentication credentials. For details, see the Embedded Weaviate documentation.\nThese examples use environment variables to store connection details and sensitive information such as AP"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors/nv_queries",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with a variety of self-hosted and API-based models from a range of providers. This enables an enhanced developed experience. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread. Back to the page you came from."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate integrates with a variety of self-hosted and API-based models from a range of providers.\nThis enables an enhanced developed experience, such as the ability to:\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The sum-transformers module can be added as a service to the Docker Compose file. As the name indicates, the summarization module can produce a summary of Weaviate text objects at query time. For maximum performance of your queries, transformer-based models should run with GPUs."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/sum-transformers",
          "webPageMainText": "As the name indicates, the summarization module can produce a summary of Weaviate text objects at query time.\nFor example, it allows us to run a query on our data in Weaviate, which can take a text like this:\nand transform it to a short sentence like this:\nFor maximum performance of your queries, transformer-based models should run with GPUs.\nCPUs can be used, however, this will significantly slow down your queries.\nHere is the current list of available SUM modules - sourced from Hugging Face Model Hub:\nThe sum-transformers module can be added as a service to the Docker Compose file. You must have a text vectorizer like text2vec-contextionary or text2vec-transformers running.\nAn example Docker Compose file for using the sum-transformers module (with the facebook-bart-large-cnn model) in combination with the text2vec-contextionary vectorizer module is below:\nVariable explanations:\nTo make use of the modules capabilities, extend your query with the following new _additional property:\nThi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page has links to the developer release notes for the Weaviate core database and the client libraries. For descriptive notes on recent major releases, follow the links in the table of contents at the left of this page. For older releases, see the blog pages at Weaviates.io."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes",
          "webPageMainText": "This page has links to the developer release notes for the Weaviate core database and the client libraries. To see release notes for a particular version, click on the version number.\nFor descriptive notes on recent major releases, follow the links in the table of contents at the left of this page. For descriptive notes on older releases, see the blog pages at Weaviate.io.\nFor links to the Weaviate Core releases, expand this section.\nFor links to the Python Client releases, expand this section.\nThe JavaScript client is no longer maintained. The TypeScript client accepts code written in JavaScript and TypeScript. Migrate your JavaScript client code to the TypeScript client.\nFor links to the TypeScript Client releases, expand this section.\nFor links to the JavaScript Client releases, expand this section.\nFor links to the Go Client releases, expand this section.\nFor links to the Java Client releases, expand this section.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model. It encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware. The ONNX-enabled images can use ONNx Runtime for faster inference processing on CPUs."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-transformers#pre-built-images",
          "webPageMainText": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model.\ntext2vec-transformers encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nTransformer model inference speeds are usually about ten times faster with GPUs. If you have a GPU, use one of the GPU enabled models.\nIf you use text2vec-transformers without GPU acceleration, imports or nearText queries may become bottlenecks. The ONNX-enabled images can use ONNX Runtime for faster inference processing on CPUs. Look for the -onnx suffix in the image name.\nAlternatively, consider one of the following options:\nThis module is not available on Weaviate Cloud.\nTo use text2vec-transformers, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to genera"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a persistent and fault-tolerant database. This page gives you an overview of how objects and vectors are stored within Weaviate and how an inverted index is created at import time. Each class in Weaviates user-defined schema leads to the creation of an index internally. An index is a wrapper type comprised of one or many shards."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/storage",
          "webPageMainText": "Weaviate is a persistent and fault-tolerant database. This page gives you an overview of how objects and vectors are stored within Weaviate and how an inverted index is created at import time.\nThe components mentioned on this page aid Weaviate in creating some of its unique features:\nEach class in Weaviate's user-defined schema leads to the creation of an index internally. An index is a wrapper type that is comprised of one or many shards. Shards within an index are self-contained storage units. Multiple shards can be used to distribute the load among multiple server nodes automatically.\nEach shard houses three main components:\nWeaviate doesn't rely on any third-party databases. The three components of a shard are all housed within Weaviate. This means that there are no runtime dependencies to other services and all components will scale equally with Weaviate.\nSince version v1.5.0, the object and inverted store are implemented using an LSM-Tree approach. This means that data can be ing"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "With named vectors, you can store multiple vectors per one object, then search for the object using any of the vector spaces. This provides a great deal of flexibility in how you can represent and search for your data. This course will teach you how to use named vectors through the lens of multimodality."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors",
          "webPageMainText": "Sometimes, you might wish to provide multiple ways to represent the same data. For example, you might want to represent an article using its body, its title, or both.\nNamed vectors enable this capability. With named vectors, you can store multiple vectors per one object, then search for the object using any of the vector spaces. This provides a great deal of flexibility in how you can represent and search for your data.\nThis course will teach you how to use named vectors through the lens of multimodality. It will show you how to use named vectors to represent and search for movies, using their text properties such as the title or the summary, or their visual properties such as the poster.\nIf you do not wish to use multimodal data, that's okay! The concepts you learn in this course can be applied to any kind of data, or any kind of vectorizer.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "GraphQL uses 'metadata' to retrieve data. The fields id, vector, certainty, distance, featureProjection and classification are available by default. Additional properties may be available for each query, depending on the query type as well as enabled Weaviate modules. For examples, see the related how to page."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-properties#id",
          "webPageMainText": "Various 'additional properties', also called 'metadata', can be retrieved in queries.\nThe fields id, vector, certainty, distance, featureProjection and classification are available by default.\nFurther additional properties may be available for each query, depending on the query type as well as enabled Weaviate modules.\nNote that only the id is available from cross-referenced objects.\nIn GraphQL queries, all additional properties to be retrieved can be set through the reserved _additional{} property.\nEach of the client libraries may handle this differently. See the examples below.\nAn example query getting the UUID and the distance.\nUse the id field to fetch the object UUID.\nUse the vector field to fetch the vector representation of the data object\nThe generate field can be used to perform a generative search.\nA generate query will cause corresponding additional result fields to be available, such as singleResult, groupedResult and error.\nFor examples, see the related how-to page.\nThe re"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This example uses the .dynamic() method to create a dynamic batcher, which automatically determines and updates the batch size during the import process. There are also other batcher types, like .fixed_size() for specifying the number of objects per batch. The data is converted from a string to the correct data types for Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_collections/import_data",
          "webPageMainText": "This example imports the movie data into our collection.\nThe code:\nWe use the requests library to load the data from the source, in this case a JSON file. The data is then converted to a Pandas DataFrame for easier manipulation.\nThen, we create a collection object (with client.collections.get) so we can interact with the collection.\nThe batch object is a context manager that allows you to add objects to the batcher. This is useful when you have a large amount of data to import, as it abstracts away the complexity of managing the batch size and when to send the batch.\nThis example uses the .dynamic() method to create a dynamic batcher, which automatically determines and updates the batch size during the import process. There are also other batcher types, like .fixed_size() for specifying the number of objects per batch, and .rate_limit() for specifying the number of objects per minute.\nThe data is converted from a string to the correct data types for Weaviate. For example, the release_d"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a fully managed Weaviate instance that runs in the cloud. It's a great way to get started as it requires no installation or maintenance. To connect to the WCD instance, you need to use the cluster URL and the API key."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/setup_weaviate/create_instance/create_wcs",
          "webPageMainText": "Here, you will create a Weaviate Cloud (WCD) instance. WCD is a fully managed Weaviate instance that runs in the cloud. It's a great way to get started with Weaviate, as it requires no installation or maintenance.\nGo to the WCD Console and log in with your credentials. If you don't have an account yet, you can sign up by clicking on the Register here link from the login screen.\nFrom the console, go to the Dashboard and click on the Create cluster button. From the following screen:\nClick on the Create button to create your Weaviate instance. The process will take a few minutes.\nOnce the instance is created, you will be able see its details by clicking on the Details button. Find the cluster URL and the API key.\nYou will need these details to connect to your Weaviate instance.\nTo connect to the Weaviate Cloud (WCD) instance, you need to use the cluster URL and the API key. You can find these details in the WCD Console.\nUse the connect_to_wcs function to connect to your WCD instance.\nSome"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Pagination is not a cursor-based implementation. This has the following implications: The autocut function limits results based on discontinuities in the result set. The query stops returning results after the specified number of jumps. The Get and Explore functions support offset. For more details, see performance considerations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-operators#sorting-api",
          "webPageMainText": "Functions such as limit, autocut, and sort modify queries at the class level.\nThe limit argument restricts the number of results. These functions support limit:\nTo return sets of results, \"pages\", use offset and limit together to specify a sub-set of the query response.\nFor example, to list the first ten results, set limit: 10 and offset: 0. To display the next ten results, set offset: 10. To continue iterating over the results, increase the offset again. For more details, see performance considerations\nThe Get and Explore functions support offset.\nPagination is not a cursor-based implementation. This has the following implications:\nThe autocut function limits results based on discontinuities in the result set. Specifically, autocut looks for discontinuities, or jumps, in result metrics such as vector distance or search score.\nTo use autocut, specify how many jumps there should be in your query. The query stops returning results after the specified number of jumps.\nFor example, conside"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate stores data objects in class-based collections. Each data object in Weaviate belongs to a collection and has one or more properties. Data objects are represented as JSON-documents. Objects normally include a vector that is derived from a machine learning model. The vector is also called an embedding or a vector embedding."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/data#cross-references",
          "webPageMainText": "Each data object in Weaviate belongs to a collection and has one or more properties.\nWeaviate stores data objects in class-based collections. Data objects are represented as JSON-documents. Objects normally include a vector that is derived from a machine learning model. The vector is also called an embedding or a vector embedding.\nEach collection contains objects of the same class. The objects are defined by a common schema.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nImagine we need to store information about an author named Alice Munro. In JSON format the data looks like this:\nYou can also attach vector representations to your data objects. Vectors are arrays of numbers that are stored under the \"vector\" property.\nIn this example, the Alice Munro data object has a small vector. The vector is some information about Alice, maybe a story or an image, that a machine "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#property-level-module-settings",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "When collaborating with git, each commit provides a frozen snapshot of work for you or others to review. Good practice is to create a commit per \"logical change\", so that each commit represents a \"unit\" of work done. Another big part of creating good commits is writing good commit messages."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/getting-started/commit-guidelines",
          "webPageMainText": "When collaborating with git, each commit provides a frozen snapshot of work for you or others to review. It is good practice is to create a commit per \"logical change\", so that each commit represents a \"unit\" of work done.\nYou might have heard that changing one variable at a time during scientific experimentation makes the output and therefore its effect easier to interpret. In the same way, creating one commit per logical change or theme helps the maintainer understand and review your work. It will also create logical, isolated checkpoints from which changes can be integrated into other branches.\nAnother big part of creating good commits is writing good commit messages. Writing good commit messages helps the whole team. It will help others understand what you have done, and help you become a better software developer.\nExamples of good commit messages include:\nExample of bad commit messages, with reasons, include:\nNote: Some people prefer to use an imperative present tense in commit me"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has been recruiting heavily after a successful Series B round. The company has been mentioned at Google I/O and a Gartner conference. This has got me thinking about the nature of recruiting. What personality traits or \u201csoft skills\u201d are we looking for in prospective employees?"
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/hiring-at-weaviate-finding-our-perfect-matches",
          "webPageMainText": "\nOver the last few months, we have been recruiting heavily.\nOur successful Series B round both encouraged us to ramp up hiring and focused attention on Weaviate. We\u2019ve also recently been mentioned at Google I/O and a Gartner conference. And of course ChatGPT and generative AI are suddenly pop-culture obsessions, which has increased interest in AI-native applications.\nA year ago, few people had heard of us; most didn\u2019t even know what a vector database was or how one might be used. But thanks to all this recent attention, we now hear from many more applicants\u2013often before we\u2019ve even announced a new opening. Instead of looking for people, people are often now looking for us. This has got me thinking about the nature of recruiting, and the challenges of finding the (technical) skills that we need in people who share our values and will fit in here at Weaviate.\nSo, how have we scaled our hiring  process? And what personality traits or \u201csoft skills\u201d are we looking for in prospective employee"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A 'single prompt' generation wil perform RAG queries on each retrieved object. This is useful when you want to transform each object separately, with the same prompt. This example finds entries in \"Movie\" based on their similarity to the input vector. Then, instructs the large language model to translate the title of each movie into French."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_rag/single_prompt",
          "webPageMainText": "A 'single prompt' generation wil perform RAG queries on each retrieved object. This is useful when you want to transform each object separately, with the same prompt.\nThis example finds entries in \"Movie\" based on their similarity to the input vector. Then, instructs the large language model to translate the title of each movie into French.\nEach of the results are then printed out to the console.\nYou must pass on one or more properties to the single_prompt parameter through braces, as we've done here with \"... {title} ...\". This will instruct Weaviate to pass on the title property from each retrieved object to the large language model.\nEach response object is similar to that from a regular search query, with an additional generated attribute. This attribute will contain the generated output for each object.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You have completed this introductory course on Weaviate. You may be interested in exploring our documentation or the Academy for more advanced courses. We are constantly improving our documentation, so keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/next_steps",
          "webPageMainText": "Congratulations! You have completed this introductory course on Weaviate.\nNow that you have completed this course, you may be interested in exploring our documentation or the Academy for more advanced courses.\nSome of our more popular resources include:\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn).\nSee you soon! \ud83d\udc4b\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The technology behind these images is called diffusion models. These models not only have the ability to dream up photo-realistic images when prompted with text input but can also modify given images to add details, replace objects or even paint in a given artists style. See below for the Mona Lisa drip painted in the style of Jackson Pollock!"
              }
            ]
          },
          "url": "https://weaviate.io/blog/how-ai-creates-art",
          "webPageMainText": "\nOne of the major developments this past year were the advancements made in machine learning models that can create beautiful and novel images such as the ones below. Though machine learning models with the capability to create images have existed for a while, this previous year we saw a marked improvement in the quality and photo-realism of the images created by these models.\n\nModels like DALL\u00b7E 2, Stable Diffusion and others which are the technologies underlying many platforms such as Lensa and Midjourney are being used by millions of people and are quickly becoming main stream as people realize their potential.\nThese models not only have the ability to dream up photo-realistic images when prompted with text input but can also modify given images to add details, replace objects or even paint in a given artists style. See below for the Mona Lisa drip painted in the style of Jackson Pollock!\n\nThe technology behind these images is called diffusion models. In this post I aim to provide a"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/objects/patch/objects/%7BclassName%7D/%7Bid%7D",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Bug reports are tracked as GitHub issues. Check first for a duplicate WIP (work in progress) issue. If not, open an issue in that repository with a complete, specific and accurate description. We also encourage you to check out this more detailed guide on Writing great Bug Reports from our team."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/getting-started/reporting-bugs",
          "webPageMainText": "We include brief guidelines below for submitting bug reports. These guidelines are designed to make it easier for the maintainers and the community to understand the report and to quash that bug.\nBug reports are tracked as GitHub issues, such as these in [Weaviate core]](https://github.com/weaviate/weaviate/issues).\nOnce you've determined which repository your bug is related to, check first for a duplicate WIP (work in progress) issue.\nIf not, open an issue in that repository with a complete, specific and accurate description. We recommend using this template.\nWe also encourage you to check out this more detailed guide on Writing great Bug Reports from our team.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud. Use WCD to simplify development and confidently deploy enterprise-ready AI applications. WCD is built on Weaviate core. They share the same technology, and offer the same great features."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs#serverless",
          "webPageMainText": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud.\nWCD manages the infrastructure so you can focus on innovation. Use WCD to simplify development and confidently deploy enterprise-ready AI applications.\nWeaviate is more than just a vector database. Weaviate is a scalable, flexible platform. The core, open source project offers vector search, keyword, and hybrid search. It has a plugable architecture to connect with ML models and tools to help you build scalable AI applications.\nWCD is built on Weaviate core. They share the same technology, and offer the same great features. In addition, WCD handles the work of hosting your Weaviate instance. This gets you up and running fast and lets you focus on your application. WCD takes care of the operational details so you don't have to.\nThese pages document the WCD user interface (UI) and WCD specific operational features. For information about the Weaviate database, client APIs, third-party modules, and other features, see th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "By default, API keys are enabled for all WCD clusters. There are two types of API key, ReadOnly and Admin.Serverless clusters have an administrator key and a read-only key. If you have a Serverless cluster, you can create and delete API keys."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/manage-api-keys",
          "webPageMainText": "By default, API keys are enabled for all WCD clusters.\nThere are two types of API key, ReadOnly and Admin.\nServerless clusters have an administrator key and a read-only key. If you have a Serverless cluster, you can create and delete API keys.\nSandbox clusters have an administrator key. You cannot modify the Sandbox key.\nIf you have a Serverless cluster, you can create new API keys.\nThis action restarts the cluster. If you have a stand-alone cluster, there is a short downtime while the cluster restarts. There is no downtime if you have a high availability cluster.\nTo create a new API key, follow these steps:\nIf you have a Serverless cluster, you can delete API keys.\nThis action restarts the cluster. If you have a stand-alone cluster, there is a short downtime while the cluster restarts. There is no downtime if you have a high availability cluster.\nTo delete an API key, follow these steps:\nTo retrieve your API keys, follow these steps:\nFor help with Serverless, Enterprise SaaS, and Brin"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This section includes reference guides for reader & generator modules, such as the QA module, NER module and the Summarization module. This section includes guide guides for QA and NER modules, as well as other modules. The guide also includes guides for the NER and Summarizing modules."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules",
          "webPageMainText": "This section includes reference guides for reader & generator modules, such as the QA module, NER module and the Summarization module.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#ve",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate collections support multiple, named vectors. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object. Dynamic indexing is an experimental feature. Use with caution."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema/vector-index#weaviates-vector-index",
          "webPageMainText": "Vector indexes facilitate efficient, vector-first data storage and retrieval.\nWeaviate collections support multiple, named vectors.\nCollections can have multiple, named vectors. Each vector is independent. Each vector space has its own index, its own compression, and its own vectorizer. This means you can create vectors for properties, use different vectorization models, and apply different metrics to the same object.\nYou do not have to use multiple vectors in your collections, but if you do, you need to adjust your queries to specify a target vector for vector or hybrid queries.\nAvailable starting in v1.25. Dynamic indexing is an experimental feature. Use with caution.\nUse these parameters to configure the index type and their properties. They can be set in the collection configuration.\nGenerally, the hnsw index type is recommended for most use cases. The flat index type is recommended for use cases where the data the number of objects per index is low, such as in multi-tenancy cases."
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate integrates with both AWS Sagemaker and Bedrock. This allows users to perform semantic and hybrid data analysis. Weaviate is a free, open source, cloud-based service that can be used by anyone with an internet connection. We are happy to help you with any questions you may have."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/aws",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nAWS offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with AWS's APIs, allowing users to leverage AWS's models directly within the Weaviate database.\nWeaviate integrates with both AWS Sagemaker and Bedrock.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\nAmazon SageMaker is a fully managed service where you can build, train and deploy ML models. Amazon Bedrock is a fully managed service that offers a choice of high-performing foundation models (FMs) from leading AI companies.\n\nAWS's embedding models transform text data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with AWS's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid sea"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#property-level-settings",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn how to work with multimodal data using Weaviate and a movie dataset. Get hands-on experience on how to store and index text and image data to be searchable together by meaning. Use large language models to augment and transform retrieved data. Learn how to use search functions in Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data",
          "webPageMainText": "In this project-based course, you will learn how to work with multimodal data using Weaviate and a movie dataset.\nYou will get hands-on experience on how to store and index text and image data to be searchable together by meaning, using Weaviate's vectorization capabilities. You will learn how to search through that data using multimodal search methods, as well as filters. You will also learn how to use Weaviate's retrieval augmented generation (RAG) capabilities to generate outputs based on the retrieved objects.\nCreate a local Weaviate instance for multimodal data.\nCreate a collection and import multimodal data, and have Weaviate create vectors for you.\nLearn how to use search functions in Weaviate.\nUse large language models to augment and transform retrieved data.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default docker image doesn't need any configuration. To customize your instance, edit the configuration settings in the docker-compose.yml file. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally. You can use environment variables to control your Weaviates setup, authentication and authorization."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/docker-compose",
          "webPageMainText": "Weaviate supports deployment with Docker. If you use the default values, you don't need a docker-compose.yml file to run the image. To customize your instance, edit the configuration settings in the docker-compose.yml file.\nThe default docker image doesn't need any configuration. To run a basic Weaviate instance, run this command from a terminal:\nThe command sets the following default values:\nWe prepared a starter Docker Compose file, which will let you:\nSave the text below as docker-compose.yml:\nEdit the docker-compose.yml file to add your local configuration. To start your Weaviate instance, run this command in your shell:\nThe Configurator can generate a docker-compose.yml file for you. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally (i.e. text2vec-transformers, or multi2vec-clip)\nYou can use environment variables to control your Weaviate setup, authentication and authorization, module settings, and data storage settings.\nA comprehensi"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/schema/post/schema",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Core uses a typical Test Pyramid approach. The tests are grouped into the following three levels:Unit tests test the smallest possible unit, mostly a struct in golang. Unit tests are designed to validate the business logic and not the internals.Integration tests test anything that crosses a boundary."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/tests#run-the-whole-pipeline",
          "webPageMainText": "Weaviate Core follows a typical Test Pyramid approach. As Weaviate itself contains no graphical user interface (GUI), the highest level tests test the user journeys at an API level.\nThe tests are grouped into the following three levels:\nUnit tests test the smallest possible unit, mostly one \"class\" (usually a struct in golang) with its methods. Unit tests are designed to validate the business logic and not the internals.\nUnit tests are stateless and do not depend on any external programs or runtime other than the Golang-built tools. (Note: We do make use of the stretchr/testify packages. However, they are installed with any other code-level dependency and don't require running dedicated software).\nThis makes tests fast to execute, easy to adapt and easy to run with third-party tools like code watchers.\nIntegration tests test anything that crosses a boundary. A boundary could be the dependence on an external party (e.g. a third-party database) or an independent custom tool, such as the "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is about teamwork, sharing responsibility and learning from one another. We believe that the next wave of software infrastructure is AI-first and that a strong open-source community is a basis for creatinghigh-quality software. To create an experience that resonates with others, we must surpass expectations."
              }
            ]
          },
          "url": "https://weaviate.io/company/about-us",
          "webPageMainText": "We believe that the next wave of software infrastructure is AI-first and that a strong open-source community is a basis for creatinghigh-quality software.\nOur values are the foundation of our culture.They unite us as a team and guide our decisions in better ways for our people, business, and future.\nOur people make it all happen. They are kind, respectful and show empathy towards others. They are generous with their time. Our people make working at Weaviate a joy. Their kindness is the magic, which contributes to our success.\nWeaviate is about teamwork, sharing responsibility and learning from one another. We combine our different perspectives and support each other to move forward. If you need them, your colleagues are there for you to lend a helping hand.\nTo create an experience that resonates with others, we must surpass expectations. So be ambitious, take ownership and dream big dreams. We do what\u2019s good for our customers and our community. If striving for excellence is part of you"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A database index is a data structure that organizes data to make searches more efficient. A vector index is designed to improve users' experience of searching for items in a large database. The choice and configuration of your vector index can significantly impact the performance of your imports as well as searches."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/vector_index/overview",
          "webPageMainText": "A database index is a data structure that organizes data to make searches more efficient. Think of it as a table of contents in a book, or an index in a library, that helps you find the information you need quickly.\nA vector index is a specialized type of index that is designed to store and search vectors.\nThe choice and configuration of your vector index can significantly impact the performance of your imports as well as searches, and the resource requirements of your Weaviate instance.\nFor this reason, the vector index a critical component in Weaviate.\nDatabases can quickly grow very large, to the point where time to search for a specific item can become unacceptably long, or the resources required to search become too high.\nA vector index is designed to improve users' experience of searching for items in a large database.\nIt usually makes a trade-off to balance three key factors: search speed, accuracy, and resource requirements.\nMany different types of vector indexes exist. A major"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_rag",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Sign up now and start building with your 14-day free trial. Pricing is based on dimensions stored and chosen SLA tier. The exact calculation can be found in the FAQ (not inclusive of discounts and taxes).All Packages include:Price per 1M vector dimensions stored per month.Phone Escalation response time: Severity 1."
              }
            ]
          },
          "url": "https://weaviate.io/pricing",
          "webPageMainText": "Pricing\nSign up now and start building with your 14-day free trial.\nOur ecosystem is designed to give you the capabilities to build and test your applications for free. When you are ready to move to production, simply pick a plan that best suits your needs.\nfrom $  25  /mo\nfrom $  135  /mo\nfrom $  450  /mo\nOur pricing is based on dimensions stored and chosen SLA tier. The exact calculation can be found in the FAQ (not inclusive of discounts and taxes).\nAll Packages include:\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $25/mo\n$0.095\n\n1bd\n2bd\n3bd\n5bd\nfrom $135/mo\n$0.145\n\n\n4h (24/7)\n8h (24/7)\n1bd\n2bd\nfrom $450/mo\n$0.175\n\n\n1h (24/7)\n4h (24/7)\n8h (24/7)\n1bd\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeverity 2\nSeverity 3\nSeverity 4\nfrom $25/mo\n$0.095\n\n1bd\n2bd\n3bd\n5bd\nPrice per 1M vector dimensions stored per month\nPhone Escalation\nResponse time: Severity 1\nSeve"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A 'grouped task' generation wil perform RAG queries on a set of retrieved objects. This is useful when you want to transform the set of objects as a whole, with one prompt. For grouped_task queries, you simply pass on the prompt to the grouped_ task parameter. You can also pass on a list of properties to be used. This can be useful to reduce the amount of data passed on to the large language model."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_rag/grouped_task",
          "webPageMainText": "A 'grouped task' generation wil perform RAG queries on the set of retrieved objects. This is useful when you want to transform the set of objects as a whole, with one prompt.\nThis example finds entries in \"MovieMM\" based on their similarity to this image of the International Space Station. Then, instructs the large language model to find commonalities between them.\nEach of the results are then printed out to the console.\nFor grouped_task queries, you simply pass on the prompt to the grouped_task parameter. This will instruct Weaviate to pass on the:\nto the large language model.\nYou can also pass on a list of properties to be used, as the grouped_properties parameter. This can be useful to reduce the amount of data passed on to the large language model and omit irrelevant properties.\nA RAG query with the grouped_task parameter will return a response with an additional generated attribute. This attribute will contain the generated output for the set of objects.\nIf you have any questions "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model. It encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware. The ONNX-enabled images can use ONNx Runtime for faster inference processing on CPUs."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-transformers#build-a-model",
          "webPageMainText": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model.\ntext2vec-transformers encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nTransformer model inference speeds are usually about ten times faster with GPUs. If you have a GPU, use one of the GPU enabled models.\nIf you use text2vec-transformers without GPU acceleration, imports or nearText queries may become bottlenecks. The ONNX-enabled images can use ONNX Runtime for faster inference processing on CPUs. Look for the -onnx suffix in the image name.\nAlternatively, consider one of the following options:\nThis module is not available on Weaviate Cloud.\nTo use text2vec-transformers, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to genera"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/resources#an-example-calculation",
          "webPageMainText": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. While you design you system, keep in mind CPU and memory management. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role.\nYou can set environment variables to manage Weaviate's resource usage, as to prevent Weaviate from using all available resources. The following environment variables are available:\nLIMIT_RESOURCES: When set to true, Weaviate automatically limits its resource usage. It sets memory usage to 80% of the total memory and uses all but one CPU core. It overrides any GOMEMLIMIT values but respects GOMAXPROCS settings.\nGOMEMLIMIT: This sets the memory limit for the Go runtime, which should be around 10-20% of the total memory available for Weaviate. It controls the aggressiveness of the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a cloud-based service that lets users create, edit, and share content. Weaviate uses the AWS SageMaker and Bedrock APIs to create and edit content. You must provide access key based AWS credentials to use this service. We are open to feedback from users on how we can improve."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/aws/generative",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with AWS's SageMaker and Bedrock APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate collection to use a AWS generative AI model, and Weaviate will perform retrieval augmented generation (RAG) using the specified model and your AWS API credentials.\nMore specifically, Weaviate will perform a search, retrieve the most relevant objects, and then pass them to the AWS generative model to generate outputs.\n\nYour Weaviate instance must be configured with the AWS generative AI integration (generative-aws) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide access key based AWS credentials to Weaviate for these integrations. Go to AWS to sign up and obtain an AWS access key ID and a corresponding AWS secret access key.\nProvide the API credenti"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate supports two types of indices. One of Weaviate's core strengths is combining the ANN index with an inverted index. Only those algorithms which support CRUD can be used in Weaviates. The system is plug-and-playable so that we can always add other algorithms in the future."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/indexing#inverted-index",
          "webPageMainText": "Weaviate supports two types of indices.\nYou can configure indices in Weaviate per class. One of Weaviate's core strengths is combining the ANN index with an inverted index.\nSome things to bear in mind:\nWhat's important to know, is that the \"A\" in ANN (i.e., the \"approximate\") comes with a trade-off. That is, the index is approximate and, therefore not always 100% accurate. This is what the experts mean when they talk about the \"recall of the algorithm.\"\nThere are different ANN algorithms, you can find a nice overview of them on this website. Only those algorithms which support CRUD can be used in Weaviate (we want that sweet database UX) and Weaviate's ANN system is completely plug-and-playable so that we can always add other algorithms in the future.\nLet's take a look a few ANN settings in an example schema.\n(note that we've removed some JSON that's irrelevant to the topic at hand).\nAs shown above, there are quite a few configurable parameters available for an ANN index. Modifying the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The latest Weaviate Python client library can be installed using pip. The client library is tested on Python 3.8 and later. The latest major version is v4 (e.g. 4.x.x). If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/setup_weaviate/client",
          "webPageMainText": "The latest Weaviate Python client library can be installed using pip. The client library is tested on Python 3.8 and later. Install it using the following command:\nThe latest major version is v4 (e.g. 4.x.x). You can check the version like so:\nFrom Python, you can load the Weaviate client library like so:\nThe client provides sets of helper classes (e.g. under weaviate.classes) and functions to make it easier to interact with Weaviate.\nNext, we'll show you how create a Weaviate instance and connect to it.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This course was written for the Weaviate Python client API (v3), and is now deprecated. In this section, we will delve deeper by reviewing the various vector search methods. You will also discover filters that can be employed to accompany search operators. For instance, you will learn how to search for data objects that exclude specific criteria."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_1",
          "webPageMainText": "This course was written for the Weaviate Python client API (v3), and is now deprecated.\nIf you are new to Weaviate, we recommend you start with one of the 100-level courses written with the v4 client API, such as those for working with text data, your own vectors, or multimodal data.\nIn this unit, you will learn how to efficiently retrieve relevant objects or aggregated information from Weaviate.\nYou have already encountered some examples of vector searches. In this section, we will delve deeper by reviewing the various vector search methods available in Weaviate, such as nearVector, nearObject, and nearText.\nAlong with vector search methods, you will also discover filters that can be employed to accompany search operators. For instance, you will learn how to search for data objects that exclude specific criteria.\nAs we examine these capabilities, we will simultaneously use them as a means to gain insight into the inner workings of Weaviate.\nUpon completing this unit, you will possess "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Azure OpenAI's APIs allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/openai-azure/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Azure OpenAI's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an Azure OpenAI embedding model, and Weaviate will generate embeddings for various operations using the specified model and your Azure OpenAI API key. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the Azure OpenAI vectorizer integration (text2vec-openai) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Azure OpenAI API key to Weaviate for this integration. Go to Azure OpenAI to sign up and obtain an API key.\nProvide th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The cross-reference type is the graph element of Weaviate. It allows you to link to any number of instances of a given class. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/datatypes#datatype-phonenumber",
          "webPageMainText": "When creating a property, Weaviate needs to know what type of data you will give it. Weaviate accepts the following types:\nRefer to this section on how to configure the tokenization behavior of a text property.\nPrior to v1.19, Weaviate supported an additional datatype string, which was differentiated by tokenization behavior to text. As of v1.19, this type is deprecated and will be removed in a future release.\nUse text instead of string. text supports the tokenization options that are available through string.\nThe cross-reference type is the graph element of Weaviate: you can create a link from one object to another. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema. For example:\nThe cross-reference type objects are arrays by default. This allows you to link to any number of instances of a given class (including zero).\nIn the above example, our objects "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers the search operators that can be used in queries. Only one search operator can be added to queries on the collection level. These operators are available in all Weaviate instances regardless of configuration.Module-specific search operators are made available in certain Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/search-operators#nearobject",
          "webPageMainText": "This page covers the search operators that can be used in queries, such as vector search operators (nearText, nearVector, nearObject, etc), keyword search operator (bm25), hybrid search operator (hybrid).\nOnly one search operator can be added to queries on the collection level.\nThese operators are available in all Weaviate instances regardless of configuration.\nModule-specific search operators are made available in certain Weaviate modules.\nBy adding relevant modules, you can use the following operators:\nnearXXX operators allow you to find data objects based on their vector similarity to the query. They query can be a raw vector (nearVector) or an object UUID (nearObject).\nIf the appropriate vectorizer model is enabled, a text query (nearText), an image (nearImage), or another media input may be be used as the query.\nAll vector search operators can be used with a certainty or distance threshold specified, as well as a limit operator or an autocut operator to specify the desired similar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "ChatGPT is built on top of GPT 4.0 which is a large language model which doesn\u2019t understand mathematical and algebraic reasoning as well as it does written language. Using the WolframAlpha plugin as a \u201cmath-mode\u201d when needing to solve mathematical problems makes perfect sense. The value for these plugins is greatest when they help make up for a current short-coming."
              }
            ]
          },
          "url": "https://weaviate.io/blog/how-to-chatgpt-plugin",
          "webPageMainText": "\nA couple weeks back in our blog on ChatGPT plugins we talked about the potential for plugins to help expand ChatGPT\u2019s functionality by allowing it to leverage third-party resources to act upon the conversations that you have with it. The value for these plugins is greatest when they help make up for a current short-coming that ChatGPT has. For example ChatGPT is built on top of GPT 4.0 which is a large language model which doesn\u2019t understand mathematical and algebraic reasoning as well as it does written language and thus using the WolframAlpha plugin as a \u201cmath-mode\u201d when needing to solve mathematical problems makes perfect sense!\nAnother short-coming of ChatGPT we spoke about was that it lacks the use of context in answering your questions unless this context is specifically conveyed in the body of the prompt. The solution to this shortcoming was the ChatGPT retrieval plugin which connects ChatGPT to a vector database which provides a robust solution to the above problem. The vector"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You can retrieve metadata about the Weaviate instance, such as:returns:If you have any questions or feedback, let us know in the user forum.  Weaviates are free to download and to use for as long as you want. For more information, visit the official website."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/meta",
          "webPageMainText": "You can retrieve metadata about the Weaviate instance, such as:\nreturns:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You have completed this course on named vectors. We hope you found it helpful and informative. There are many more resources available to help you continue your learning journey. We are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors/next_steps",
          "webPageMainText": "Congratulations! You have completed this course on named vectors. We hope you found it helpful and informative.\nThere are many more resources available to help you continue your learning journey with named vectors.\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn).\nSee you soon! \ud83d\udc4b\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The sum-transformers module can be added as a service to the Docker Compose file. As the name indicates, the summarization module can produce a summary of Weaviate text objects at query time. For maximum performance of your queries, transformer-based models should run with GPUs."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/sum-transformers#use-another-summarization-module-from-hugging-face",
          "webPageMainText": "As the name indicates, the summarization module can produce a summary of Weaviate text objects at query time.\nFor example, it allows us to run a query on our data in Weaviate, which can take a text like this:\nand transform it to a short sentence like this:\nFor maximum performance of your queries, transformer-based models should run with GPUs.\nCPUs can be used, however, this will significantly slow down your queries.\nHere is the current list of available SUM modules - sourced from Hugging Face Model Hub:\nThe sum-transformers module can be added as a service to the Docker Compose file. You must have a text vectorizer like text2vec-contextionary or text2vec-transformers running.\nAn example Docker Compose file for using the sum-transformers module (with the facebook-bart-large-cnn model) in combination with the text2vec-contextionary vectorizer module is below:\nVariable explanations:\nTo make use of the modules capabilities, extend your query with the following new _additional property:\nThi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector search returns the objects with most similar vectors to that of the query. To search a collection that has named vectors, use the target vector field to specify which named vector to search. To set a similarity threshold between the search and target vectors, define a maximum distance (or certainty)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/similarity#search-with-a-vector",
          "webPageMainText": "Vector search returns the objects with most similar vectors to that of the query.\nTo search a collection that has named vectors, use the target vector field to specify which named vector to search.\nThe output is like this:\nUse the Near Text operator to find objects with the nearest vector to an input text.\nThe output is like this:\nUse the Near Image operator to find objects with the nearest vector to an image.\nThis example uses a base64 representation of an image.\nSee Image search for more information.\nIf you have an object ID, use the Near Object operator to find similar objects to that object.\nIf you have an input vector, use the Near Vector operator to find objects with similar vectors\nTo set a similarity threshold between the search and target vectors, define a maximum distance (or certainty).\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\nTo limit results to groups of similar distances to the query, use the autocut fil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Rebranding was an opportunity to reflect on who we are now and where we're going. It's a chance to evaluate messaging, visual identity, and our overall brand strategy. It was an even bigger deal for me because as a graphic designer, creating a new corporate identity from a clean sheet of paper is a rare treat."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/creating-a-playful-new-identity-for-weaviate",
          "webPageMainText": "\nIn January 2023, SeMI Technologies became Weaviate as we aligned our company under the brand of our well-known vector-search product. Adopting Weaviate as the name for our company created the opportunity, and gave us an incentive, to develop a new graphic identity.\nRebranding was an opportunity to reflect on who we are now and where we're going. It's a chance to evaluate messaging, visual identity, and our overall brand strategy; and to get creative and build something great together.\nIt was an even bigger deal for me because as a graphic designer, creating a new corporate identity from a clean sheet of paper is a rare treat. (And if you\u2019re wondering, my creative process typically does start on paper!)\n\nExploration of Weaviate logo, sketches (2018)\n\nFirst Weaviate logo concept (2018)\nI began with a review of other companies in the space, or adjacent to it\u2014both to get a sense of the visual language being used, and to rule out any solutions that might be confusingly similar to another c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page contains information about how you can attach your own ML model to Weaviate. A custom vectorizer module is, for example, a model that is able to transform data (e.g. text or image data) to embeddings. This way, you can use Weaviates to scale your ML and NLP models."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/other-modules/custom-modules",
          "webPageMainText": "Besides using one of the out-of-the-box vectorization models, you can also attach your own machine learning model to Weaviate. This way, you can use Weaviate to scale your ML and NLP models, since Weaviate takes care of efficient data storage and retrieval. A custom vectorizer module is, for example, a model that you trained on your own training data, that is able to transform data (e.g. text or image data) to embeddings.\nIf you have model that already fits with an existing model architecture (e.g. Transformers), you don't have to write any custom code and you can just run this Transformer model with the existing text2vec-transformer module.\nThis page contains information about how you can attach your own ML model to Weaviate. You will need to attach your ML model to Weaviate's Module API as a module. First, there is some information about how (vectorizer/embedding) modules in Weaviate work.\nQuick links:\nRecorded during the Weaviate meetup \u2013 custom modules section starts @ 13:30min\nTo "
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/well-known",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "HNSW, or \"Hierarchical Navigable Small World\", is a powerful and flexible vector index type. It allows for fast and accurate searches of high-dimensional vectors. It also has the advantage of being very scalable, while being tunable to allow for different trade-offs between search speed, accuracy, and resource requirements."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/vector_index/hnsw",
          "webPageMainText": "HNSW, or \"Hierarchical Navigable Small World\", is a powerful and flexible vector index type that allows for fast and accurate searches of high-dimensional vectors.\nIt also has the advantage of being very scalable, while being tunable to allow for different trade-offs between search speed, accuracy, and resource requirements.\nHNSW is the default index type in Weaviate, and if you are not sure which index type to use, you should start with HNSW.\nHNSW is all about creating connections between vectors in a way that allows for both fast global traversal of the graph and accurate search of similar vectors.\nIt does this by creating multiple layers of vectors, where each layer includes a subset of the vectors in the layer below. This means that as you move up the layers, finding the correct general area of the graph becomes faster.\nAnd once the general area is found, the search then becomes more local, by moving down the layers, where more of the vectors are included.\nUltimately, the search re"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Configure reranking. To rerank search results, enable a reranker module for your collection. Reranking modules reorder the search result set according to a different set of criteria or a different (e.g. more expensive) algorithm. If multiple rerankers are enabled, specify the module you want to use in the moduleConfig section."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/rerank",
          "webPageMainText": "Reranking modules reorder the search result set according to a different set of criteria or a different (e.g. more expensive) algorithm.\nConfigure reranking\nTo rerank search results, enable a reranker module for your collection. For details, see the reranker's reference page:\nA collection can have multiple rerankers. If multiple reranker modules are enabled, specify the module you want to use in the moduleConfig section of your schema.\nAny vector-based search on collections with named vectors configured must include a target vector name in the query. This allows Weaviate to find the correct vector to compare with the query vector.\nTo rerank the results of a vector search, configure the object properties to sort on.\nThe response should look like this:\nTo rerank the results of a keyword search, configure the object properties to sort on.\nThe response should look like this:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate uses the Raft consensus algorithm for schema replication, implemented with Hashicorp's raft library. A schema change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. This architecture ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/cluster-architecture#data-replication-leaderless",
          "webPageMainText": "This page describes how the nodes or clusters in Weaviate's replication design behave.\nIn Weaviate, schema replication and data replication are separate. For the schema, Weaviate uses the Raft consensus algorithm with strong consistency. For data replication, Weaviate uses a leaderless design with eventual consistency.\nWeaviate uses the Raft consensus algorithm for schema replication, implemented with Hashicorp's raft library.\nRaft ensures that schema changes are consistent across the cluster. A schema change is forwarded to the leader node, which applies the change to its log before replicating it to the follower nodes. Once a majority of nodes have acknowledged the change, the leader commits the change to the log. The leader then notifies the followers, which apply the change to their logs.\nThis architecture ensures that schema changes are consistent across the cluster, even in the event of (a minority of) node failures.\nAs a result, a Weaviate cluster will include a leader node that"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/schema/post/schema/%7BclassName%7D/tenants",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a vector database, which uses AI and machine learning to organize and search data in a completely new way. With over 1.6 million downloads, Weaviate continues to grow. We are looking for ambitious people globally. Join us to expand and grow our community of users!"
              }
            ]
          },
          "url": "https://weaviate.io/company/careers",
          "webPageMainText": "At Weaviate we are committed to our values - the foundation of our company. They guide our decisions in ways that are better for our people, our business, and the future.\nWeaviate is a remote-first company that has big ambitions. Our product Weaviate is a vector database, which uses AI and machine learning to organize and search data in a completely new way.\nWith over 1.6 million downloads, Weaviate continues to grow. We are looking for ambitious people globally. Join us, so we can expand and grow our community of users!\nIntroduce yourself. Tell us about your ambitions and life goals. We\u2019d like to know about you as a person - so feel free to tell us about your pet, hobbies or whatever it is that makes you smile. We\u2019ll tell you about Weaviate, our challenges and what it\u2019s like working for a remote company. Ask anything you like.\nMember of the People & Culture team\n30 min\nYou will have the chance to talk about your experience in greater depth. Give us insights into how your skills fit th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The nodes endpoint accepts a GET request and returns information about relevant nodes in the cluster. The query can be for the entire cluster, or for a particular collection. The nodes have the following fields:The following command will retrieve summary information about all nodes in a cluster:Example output:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/nodes",
          "webPageMainText": "The nodes endpoint accepts a GET request and returns information about relevant nodes in the cluster. The query can be for the entire cluster, or for a particular collection.\nOr\nThe nodes endpoint returns an array of nodes. The nodes have the following fields:\nThe following command will retrieve summary information about all nodes in the cluster:\nExample output:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.18 introduces Faster Filtering through Bitmap Indexing, HNSW-PQ, Cursor API, and more. Weaviate v1.2 introduced support for transformers (DistilBERT, BERT, RoBERTa, Sentence-BERT) to vectorize and semantically search through your data."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/release/page/2",
          "webPageMainText": "Weaviate 1.18 introduces Faster Filtering through Bitmap Indexing, HNSW-PQ, Cursor API, and more! Learn all about it.\nWeaviate 1.17 introduces Replication, Hybrid Search, BM25, Faster Startup and Imports and more. Learn all about it.\nWeaviate 1.16 introduces New Filter Operators, Distributed Backups, Centroid Module, Node Status API, Azure-based OIDC, and more. Lear all about it.\nTwo weeks after the 1.15 release, we have a patch (v1.15.1) release for you, which brings 15 bug fixes and 2 UX improvements.\nWeaviate 1.15 introduces Cloud-native Backups, Memory Optimizations, faster Filtered Aggregations and Ordered Imports, new Distance Metrics and new Weaviate modules.\nPress Release: Pay-as-you-grow comes to Vector Search.\nLearn what is new in Weaviate 1.14, the most reliable and observable Weaviate release yet!\nWeaviate v1.2 introduced support for transformers (DistilBERT, BERT, RoBERTa, Sentence-BERT, etc) to vectorize and semantically search through your data.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The year 2023 was all about dynamic experimentation at Weaviate. Vector databases became a strong and recognized foundation in building ever more effective AI applications, enabling chatbots, agents, and advanced search systems. Our 2023 global online hackathons proved to be vibrant innovation hubs, fostering diversity and inclusion in co-working."
              }
            ]
          },
          "url": "https://weaviate.io/blog/2023-recap",
          "webPageMainText": "\nIt\u2019s hard to imagine that less than a year ago, so very few people even knew about the concept of vector databases and how AI could benefit from them. Those who did still had many questions about how they worked and whether they could at all be helpful.\nMeanwhile, curiosity and interest in AI spiked, especially after OpenAI launched ChatGPT. Curiosity has sped up our progress and made more people aware of the opportunities AI offers, transforming our landscape. Let's all take a moment to reflect and appreciate the start of a momentous change in how we can communicate, learn, teach, and collaborate so much faster and more effectively by leveraging AI.\nThe year 2023 was all about dynamic experimentation at Weaviate. Vector databases became a strong and recognized foundation in building ever more effective AI applications, enabling chatbots, agents, and advanced search systems.\nOur 2023 global online hackathons proved to be vibrant innovation hubs, fostering diversity and inclusion in co"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open-source vector database with a built-in NLP model called the Contextionary. Learn how the AI-first vector database unlocks the potential of unstructured data and why this is important. Learn what makes Weaviate unique."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/concepts/page/4",
          "webPageMainText": "Weaviate is an open-source vector database with a built-in NLP model called the Contextionary. Learn what makes Weaviate unique.\nLearn how the AI-first vector database Weaviate unlocks the potential of unstructured data and why this is important.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a tool that allows users to search Wikipedia articles. The tool can search for articles about cities in Europe, for example. It takes a fraction of a second for the results to appear on the user's screen. Weaviate can be downloaded for free from the Google Play store and the App Store."
              }
            ]
          },
          "url": "https://weaviate.io/blog/why-is-vector-search-so-fast",
          "webPageMainText": "\nWhenever I talk about vector search, I like to demonstrate it with an example of a semantic search. To add the wow factor, I like to run my queries on a Wikipedia dataset, which is populated with over 28 million paragraphs sourced from Wikipedia.\nFor example, I can query Weaviate for articles related to: \"urban planning in Europe\", and the vector database (in the case of my demo \u2013 Weaviate) responds with a series of articles about the topic, such as \"The cities designed to be capitals\".\nYou can try it for yourself by following this link, which is already pre-populated with the above question. Press the play button, to see the magic happen.\nHere is the thing, finding the correct answer in a gigantic repository of unstructured data is not the most impressive part of this demonstration (I mean, it is very impressive), but it is the \ud83d\ude80 speed at which it all happens. It takes a fraction of a second for the UI to show the results.\nWe are talking about a semantic search query, which takes mil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#shardingconfig",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.25 introduces Raft as the consensus algorithm for its database. This change requires a migration of the entire schema. The cluster requires some downtime for the migration. The length of the downtime depends on the size of the database. We suggest performing this upgrade at a least disruptive time."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/migration/weaviate-1-25",
          "webPageMainText": "This migration guide assumes that you have:\nWeaviate 1.25 introduces Raft as the consensus algorithm for its database schema, in order to improve its fault tolerance. This change requires a migration of the entire schema.\nAs a result, to migrate from a pre-1.25 version of Weaviate to 1.25 on kubernetes, you must follow these steps:\nFor more details, refer to the upgrade instructions below.\nTo downgrade from 1.25 to a pre-1.25 version, you must perform a POST request to the v1/cluster/schema-v1 endpoint to downgrade the schema. Then, you must similarly delete the deployed StatefulSet and downgrade Weaviate to the desired version.\nFor more details, refer to the downgrade instructions below.\nThis upgrade requires a schema migration. The cluster requires some downtime for the migration. The length of the downtime depends on the size of the database.\nWe suggest performing this upgrade at a least disruptive time, or even provisioning a secondary cluster while the main cluster is being restar"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You can also perform keyword (BM25) searches to find items based on their keyword similarity, or hybrid searches that combine BM25 and semantic/ vector searches. The limit parameter here sets the maximum number of results to return. The return_metadata parameter takes an instance of the MetadataQuery class to set metadata to return in the search results."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_searches/keyword_hybrid",
          "webPageMainText": "You can also perform keyword (BM25) searches to find items based on their keyword similarity, or hybrid searches that combine BM25 and semantic/vector searches.\nThis example finds entries in \"MovieMM\" with the highest keyword search scores for the term \"history\", and prints out the title and release year of the top 5 matches.\nThe results are based on a keyword search score using what's called the BM25f algorithm.\nThe limit parameter here sets the maximum number of results to return.\nThe return_metadata parameter takes an instance of the MetadataQuery class to set metadata to return in the search results. The current query returns the score, which is the BM25 score of the result.\nThis example finds entries in \"MovieMM\" with the highest hybrid search scores for the term \"history\", and prints out the title and release year of the top 5 matches.\nThe results are based on a hybrid search score. A hybrid search blends results of BM25 and semantic/vector searches.\nThe limit parameter here sets"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Two weeks after the v1.15.0 release, which introduced backups and more, we fixed over 15 bugs. This release addresses fixes and improvements around: This started as a single bug investigation, but quickly this led to a discovery of five others. There was an issue when trying to update objects without vectors, but then you would add a vector later. That could lead to cryptic error messages like \"incompatible vector dimensions: 0 vs. 128\"."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-15-1-release",
          "webPageMainText": "\nWe usually wouldn't write a whole blog post about a patch release. But when I chatted with Sebastian (the regular author of our \"big\" release blog posts series), about the contents of Weaviate v1.15.1 patch, we quickly realized that this release is too important to end up as a side note somewhere.\nSo, instead, I have the pleasure of introducing you to the latest patch release. Two weeks after the v1.15.0 release, which introduced backups and more, we fixed over 15 bugs.\nIn summary, this release addresses fixes and improvements around:\nThis started as a single bug investigation, but quickly this led to a discovery of five others. There was an issue when trying to update objects without vectors, but then you would add a vector later. That could lead to cryptic error messages like \"incompatible vector dimensions: 0 vs. 128\". We were able to narrow this down to an issue in Weaviate's LSM store implementation, but we found five other bugs when we fixed the problem. Among them:\nIn short, th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The gRPC API is faster than the REST API. Use it to improve import speeds. Batch imports are an efficient way to add multiple data objects and cross-references. To create a bulk import job, follow these steps:The following example adds objects to the MyCollection collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/import#batch-vectorization",
          "webPageMainText": "Batch imports are an efficient way to add multiple data objects and cross-references.\nTo create a bulk import job, follow these steps:\nThe following example adds objects to the MyCollection collection.\nThe gRPC API is faster than the REST API. Use the gRPC API to improve import speeds.\nThe Python client uses gRPC by default. See the client page for additional batch import configuration options.\nThe TypeScript client v3 uses gRPC by default.\nTo use the gRPC API with the Java client, add the setGRPCHost field to your client connection code. Update setGRPCSecured if you use an encrypted connection.\nTo use the gRPC API with the Go client, add the GrpcConfig field to your client connection code. Update Secured if you use an encrypted connection.\nTo use the gRPC API with the Spark connector, add the grpc:host field to your client connection code. Update grpc:secured if you use an encrypted connection.\nWeaviate generates an UUID for each object. Object IDs must be unique. If you set object ID"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate TypeScript client supports TypeScript and JavaScript. The v3 client supports server side development (Node.js hosted). See v3 packages for details. If your application is browser based, consider using the TypeScript clients v2 and v3. The default gRPC port is 50051. To map the Weaviates gR PC port in your Docker container to a local port, add this code to your docker-compose.yml file."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript/v2_v3_migration#node-support-only",
          "webPageMainText": "The Weaviate TypeScript client supports TypeScript and JavaScript.\nThe v3 client supports server side development (Node.js hosted). See v3 packages for details. If your application is browser based, consider using the TypeScript client v2.\nTo install the TypeScript client v3, follow these steps:\nUpdate Node.js\nThe v3 client requires Node v18 or higher.\nInstall the new client package\nUpgrade Weaviate\nThe v3 client requires Weaviate core 1.23.7 or higher. Whenever possible, use the latest versions of Weaviate core and the Weaviate client.\nOpen a gRPC port\nThe default gRPC port is 50051.\n To map the Weaviate gRPC port in your Docker container to a local port, add this code to your docker-compose.yml file:\nThe weaviate object is the main entry point for all API operations. The v3 client instantiates the weaviate object and creates a connection to your Weaviate instance.\nIn most cases, you should use one of the connection helper functions to connect to your Weaviate instance:\nYou can also u"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page briefly covers the required resources and setup, including the Weaviate Python client library, and a Weaviates instance. This course is self-contained. However, we recommend that you go through one of the 101-level courses, such as that for working with text, your own vectors, or multimodal data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors/nv_preparation",
          "webPageMainText": "This course is self-contained. However, we recommend that you go through one of the 101-level courses, such as that for working with text, your own vectors, or multimodal data.\nThis page briefly covers the required resources and setup, including the Weaviate Python client library, and a Weaviate instance with the multi-modal vectorizer.\nInstall the latest (v4, e.g. 4.5.0) Weaviate Python client library with:\nInstall Docker on your machine. We recommend following the official Docker installation guide.\nCreate a new directory and navigate to it in your terminal. Then, create a new file called docker-compose.yml and add the following content:\nRun the following command to start Weaviate:\nOnce the instance is created, you can access it at http://localhost:8080.\nTo connect to the Weaviate instance, use the connect_to_local function. We also provide API keys here for any inference APIs (e.g. OpenAI, Cohere, Google, AWS etc.) that Weaviate may use.\nYou can check whether the Weaviate instance i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Every model, out of 17 tested, provided a near-random performance on the task and was unable to perform pure causal reasoning. Researchers at the Max Planck Institute showed that this is a very big shortcoming of all of the LLMs they tested as of June 2023."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper-3",
          "webPageMainText": "\nCan large language models infer causation from correlation? \nAnd if they can't automatically bridge the gap from correlation to causation, then can we at least fine-tune them to improve at this task?\nThese two questions were addressed by researchers at the Max Planck Institute(https://arxiv.org/abs/2306.05836). \nWe know that the success of LLM's arises from capturing a vast set of statistical correlations among words, but how well can these correlations be used to infer deeper causal relationships behind the words? \nThey showed that this is a very big shortcoming of all of the LLMs they tested as of June 2023.\nSome details:\nUsing a dataset, they created called Corr2Cause, they assessed an LLM's ability to take multiple correlational statements as input and accurately determine the causal relationships between these same variables.\nEvery model, out of 17 tested, provided a near-random performance on the task and was unable to perform pure causal reasoning. \nFurthermore, they tested tha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We use the sentence-transformers/all-MiniLM-L6-v2 model to generate the vectors. We access it here through the Hugging Face API for convenience. You could also use the transformers library, if you would like to perform the generation locally."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/object_collections/generate_vectors",
          "webPageMainText": "Since we are using custom vectors, we need to generate them ourselves.\nThis step is optional, as the next section shows you how to download and use the pre-generated vectors. But if you are interested in how to generate vectors, read on.\nThis example creates embeddings for the movie dataset:\nThis will generate a vector for each movie in the dataset, which we can use when adding the movies to Weaviate.\nWe use the sentence-transformers/all-MiniLM-L6-v2 model to generate the vectors. We access it here through the Hugging Face API for convenience. You could also use the transformers library, if you would like to perform the generation locally.\nWe combine the movie title and overview to create a source string for the model. This is the text that the model will \"translate\" into a vector.\nWe use a buffer to store the concatenated strings, and then get the embeddings in batches. This is a good practice to limit the number of requests to the model, and to avoid timeouts.\nThe embeddings are then"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets. The fusion method and the relative weights are configurable. The search rankings are part of the object metadata. Weaviate uses the score to order the search results. To see the object rankings, set the explain score field in your query."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/hybrid#change-the-ranking-method",
          "webPageMainText": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets.\nThe fusion method and the relative weights are configurable.\nCombine the results of a vector search and a keyword search. The search uses a single query string.\nThe output is like this:\nA hybrid search on a collection that has named vectors must specify a target vector. Weaviate uses the query vector to search the target vector space.\nThe output is like this:\nTo see the object rankings, set the explain score field in your query. The search rankings are part of the object metadata. Weaviate uses the score to order the search results.\nThe output is like this:\nHybrid search results can favor the keyword component or the vector component. To change the relative weights of the keyword and vector components, set the alpha value in your query.\nThe output is like this:\nRelative Score Fusion is the default fusion method starting in v1.24.\nThe output is like this:\nFor a discussion of"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "GraphQL is a query language built on using graph data structures. It is an efficient method of data retrieval and mutation. Weaviate offers GraphQL and gRPC APIs for queries. We recommend using a Weaviates client library, which abstracts away the underlying API calls."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql",
          "webPageMainText": "Weaviate offers GraphQL and gRPC APIs for queries.\nWe recommend using a Weaviate client library, which abstracts away the underlying API calls and makes it easier to integrate Weaviate into your application.\nHowever, you can query Weaviate directly using GraphQL with a POST request to the /graphql endpoint, or write your own gRPC calls based on the gRPC protobuf specification.\nAll references have their individual subpages. Click on one of the references below for more information.\nGraphQL is a query language built on using graph data structures. It is an efficient method of data retrieval and mutation, since it mitigates the common over-fetching and under-fetching problems of other query languages.\nGraphQL is case-sensitive (reference), so make sure to use the correct casing when writing your queries.\nYou can POST a GraphQL query to Weaviate as follows:\nA GraphQL JSON object is defined as:\nGraphQL queries follow a defined structure. Queries are structured as follows:\nGraphQL integer da"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate can expose Prometheus-compatible metrics for monitoring. A standard Prometheus/Grafana setup can be used to visualize metrics on various dashboards. Metrics are typically scraped into a time-series database, such as Prometheus. Weaviate will expose the metrics at <hostname>:2112/metrics."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/monitoring",
          "webPageMainText": "Weaviate can expose Prometheus-compatible metrics for monitoring. A standard\nPrometheus/Grafana setup can be used to visualize metrics on various\ndashboards.\nMetrics can be used to measure request latencies, import\nspeed, time spent on vector vs object storage, memory usage, application usage,\nand more.\nTo tell Weaviate to collect metrics and expose them in a Prometheus-compatible\nformat, all that's required is to set the following environment variable:\nBy default, Weaviate will expose the metrics at <hostname>:2112/metrics. You\ncan optionally change the port to a custom port using the following environment\nvariable:\nMetrics are typically scraped into a time-series database, such as Prometheus.\nHow you consume metrics depends on your setup and environment.\nThe Weaviate examples repo contains a fully pre-configured setup using\nPrometheus, Grafana and some example\ndashboards.\nYou can start up a full-setup including monitoring and dashboards with a single\ncommand. In this setup the follow"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Question and Answer (Q&A) module is a Weaviate module for answer extraction from data. It uses BERT-related models for finding and extracting answers. The qna-transformers module tries to find an answer in the data objects of the specified class. There are currently five different Question Answering models available."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/qna-transformers",
          "webPageMainText": "The Question and Answer (Q&A) module is a Weaviate module for answer extraction from data. It uses BERT-related models for finding and extracting answers. This module can be used in GraphQL Get{...} queries, as a search operator. The qna-transformers module tries to find an answer in the data objects of the specified class. If an answer is found within the given certainty range, it will be returned in the GraphQL _additional { answer { ... } } field. There will be a maximum of 1 answer returned, if this is above the optionally set certainty. The answer with the highest certainty (confidence level) will be returned.\nThere are currently five different Question Answering models available (source: Hugging Face Model Hub): distilbert-base-uncased-distilled-squad (uncased), bert-large-uncased-whole-word-masking-finetuned-squad (uncased), distilbert-base-cased-distilled-squad (cased), deepset/roberta-base-squad2, and deepset/bert-large-uncased-whole-word-masking-squad2 (uncased). Note that no"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This course was written for the Weaviate Python client API (v3), and is now deprecated. We recommend you start with one of the 100-level courses written with the v4 client API, such as those for working with text data, your own vectors, or multimodal data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp",
          "webPageMainText": "This course was written for the Weaviate Python client API (v3), and is now deprecated.\nIf you are new to Weaviate, we recommend you start with one of the 100-level courses written with the v4 client API, such as those for working with text data, your own vectors, or multimodal data.\nThis course is designed to get you started with Weaviate, so that you can go from being new to Weaviate to building an MVP-level product with Weaviate in a short period of time.\nAlong the way, you'll develop intuitions about not only how Weaviate works, but also how vectors work, and how vector searches work. You'll also learn how to use Weaviate's client library so that you can get going in a language that you are familiar with.\nBy the time you're done with these short units, you'll be able to build your own instance of Weaviate with your own data, and have a suite of search tools at your disposal so that you can get the data you want in the format you want it.\nStart here: Learn what Weaviate is, and abou"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is designed to be easy to monitor and observe by following a cloud native approach. To do this Weaviate supports the following features:Publishing of Prometheus metrics to the standard /metrics endpoint.Use of built-in Kubernetes liveness and readiness checks. Configuration of settings via environment variables.Simplified deployment via helm charts."
              }
            ]
          },
          "url": "https://weaviate.io/blog/monitoring-weaviate-in-production",
          "webPageMainText": "\nWeaviate is designed to be easy to monitor and observe by following a cloud native approach. To do this Weaviate supports the following features\nPublishing of Prometheus metrics to the standard /metrics endpoint\nUse of built-in Kubernetes liveness and readiness checks\nConfiguration of settings via environment variables\nSimplified deployment via helm charts\nThere is existing documentation on the exported metrics which also has an example for how to use a Prometheus instance for metrics.\nOne common question though is: How can I integrate Weaviate with my existing observability stack?\nThis article describes two approaches using either Grafana agent or Datadog agent to scrape these metrics. It also provides a list of important metrics to monitor.\nIt is assumed that you have already deployed Weaviate. By default Prometheus monitoring is disabled, so you can enable it with this environment setting:\nWeaviate will then publish Prometheus metrics on port 2112.\nIf you are using Weaviate 1.17 or"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate offers three primary search types - namely vector, keyword, and hybrid searches. These code examples are runnable, with the v4 Weaviate Python client. Connect to the pre-configured demo instance of Weaviates with the following code."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/which_search/review",
          "webPageMainText": "Weaviate offers three primary search types - namely vector, keyword, and hybrid searches. Let's briefly recap what they are, and how they work.\nThese code examples are runnable, with the v4 Weaviate Python client. Connect to the pre-configured demo instance of Weaviate with the following code, and try the examples below.\nA vector search finds objects with the most similar vectors to the query vector.\nBecause each vector is a numerical representation of the underlying object, a vector similarity can be thought of as a similarity in meaning. Therefore a vector search is also called \"semantic search\".\nIn Weaviate, you can search for objects with similar vectors in any of the following ways:\nWith a source medium (e.g. text or image):\nWith a vector:\nWith an existing Weaviate object:\nA keyword search finds objects whose keywords (i.e. tokens) are the most relevant to the keywords (i.e. tokens) of the query. The relevance is determined by the BM25F algorithm.\nIntuitively, the BM25F algorithm "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets. The fusion method and the relative weights are configurable. The search rankings are part of the object metadata. Weaviate uses the score to order the search results. To see the object rankings, set the explain score field in your query."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/hybrid#vector-similarity-search",
          "webPageMainText": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets.\nThe fusion method and the relative weights are configurable.\nCombine the results of a vector search and a keyword search. The search uses a single query string.\nThe output is like this:\nA hybrid search on a collection that has named vectors must specify a target vector. Weaviate uses the query vector to search the target vector space.\nThe output is like this:\nTo see the object rankings, set the explain score field in your query. The search rankings are part of the object metadata. Weaviate uses the score to order the search results.\nThe output is like this:\nHybrid search results can favor the keyword component or the vector component. To change the relative weights of the keyword and vector components, set the alpha value in your query.\nThe output is like this:\nRelative Score Fusion is the default fusion method starting in v1.24.\nThe output is like this:\nFor a discussion of"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#read--write-requests-while-a-backup-is-running",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Inverted indices are used often in document retrieval systems and search engines. They allow fast full-text search and fast key-based search instead of brute-force. This fast data retrieval comes with the only cost of slight increase of processing time when a new data object is added, since the data object will indexed and stored in an inverted way."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/performance",
          "webPageMainText": "Weaviate uses two types of data indexing. Next to the vector indexes that are created and powers the semantic search capability, there is also the inverted index.\nThe inverted index is essentially what powers all the GraphQL where filters, where vectors or semantics are needed to find results. With inverted indexes, contents or data object properties such as words and numbers are mapped to its location in the database. This is the opposite of the more traditional forward index, which maps from documents to its content.\nInverted indices are used often in document retrieval systems and search engines, because it allows fast full-text search and fast key-based search instead of brute-force. This fast data retrieval comes with the only cost of slight increase of processing time when a new data object is added, since the data object will indexed and stored in an inverted way, rather than only storing the index of the data object. In the database (Weaviate), there is a big lookup table which"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a vector database. Vector databases store data objects and vectors that represent those objects. The vector representation is also called an \"embedding\" When you import data, you can pass pre-existing vectors or generate new ones. \"Bring your own vectors\" means you supply the vector embeddings when you upload your data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/starter-guides/custom-vectors",
          "webPageMainText": "Weaviate is a vector database. Vector databases store data objects and vectors that represent those objects. The vector representation is also called an \"embedding.\"\nWhen you import data, you can pass pre-existing vectors or generate new ones. \"Bring your own vectors\" means you supply the vector embeddings when you upload your data. The embeddings you provide can be custom vectors or vectors that are pre-generated using a model provider.\nThis guide discusses importing data that has pre-existing vectors.\nTo use this guide to import data that has pre-existing vectors, follow these steps:\nThis section introduces setup requirements and the example data that this guide uses.\nThe example data is based on a set of ten questions from the \"Jeopardy!\" television program. The import data file is a JSON formatted document that contains the vectors and the underlying data.\nThe JSON file is based on this data. The vector embeddings are generated with the OpenAI API text-embedding-ada-002 model.\nWeav"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.22 is already available on Weaviate Cloud - so try it out! Nested properties let you work with an address value that has number, street, and city` properties of its own. Object and object[] join the available list of data types."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-22-release",
          "webPageMainText": "Weaviate 1.22 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f relating to this release:\n\n1.22 is already available on Weaviate Cloud - so try it out!\nFor more details, keep scrolling \u2b07\ufe0f!\n\n1.22 welcomes new members to the Weaviate data type family, with object and object[] joining the available list.\nThis allows you to store nested objects directly in Weaviate as property values. In other words, you can store them without having to flatten the object or use cross-references to other Weaviate classes.\nThis is particularly useful for storing data that is not easily represented in a flat structure. For example, nested properties let you work with an address value that has number, street, and city` properties of its own.\nAn example class definition is shown below, where a Nested class has a parent property with an object datatype. Because the parent property is an object, it can have its own properties (nestedProperties), such as child in this example, which is a text datatype.\nAn example obje"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate powers site search, recommendation, knowledge extraction, and other information retrieval cases. The architecture that guides the principles for Weaviate\u2019s replication systems is modeled after how users typically use Weaviates. The two different architectures for schema and data replication are based on the Raft consensus algorithm."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture/philosophy",
          "webPageMainText": "The architecture that guides the principles for Weaviate\u2019s replication systems is modeled after how users typically use Weaviate. Weaviate powers site search, recommendation, knowledge extraction, and other information retrieval cases. These cases all have a few things in common:\nBased on the above usage patterns, and keeping the CAP theorem trade-offs in mind, Weaviate implements two different architectures for schema and data replication.\nSchema replication is based on the Raft consensus algorithm, which provides strong consistency. This means that schema changes are consistent across the cluster, even in the event of (a minority of) node failures. Schema operations are considered critical, so Weaviate has a strongly consistent schema.\nData replication is based on a leaderless design with tunable consistency. This means there is no central leader or primary node that will replicate to follower nodes. Weaviate\u2019s data replication architecture prefers availability over consistency. Neve"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "RAG queries are also called 'generative' queries in Weaviate. You can access these functions through the generate submodule of the collection object. Each generative query works in addition to the regular search query. This allows you to retrieve objects from a Weaviates instance and then generate outputs based on the retrieved objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/mm_rag/setup",
          "webPageMainText": "Retrieval augmented generation (RAG) is a way to combine the best of both worlds: the retrieval capabilities of semantic search and the generation capabilities of AI models such as large language models. This allows you to retrieve objects from a Weaviate instance and then generate outputs based on the retrieved objects.\nWhen we created a collection, we specified the generative_module parameter as shown here.\nThis selects a generative module that will be used to generate outputs based on the retrieved objects. In this case, we're using the openai module, and the GPT family of large language models.\nAs we did before with the vectorizer module, you will require an API key from the provider of the generative module. In this case, you will need an API key from OpenAI.\nRAG queries are also called 'generative' queries in Weaviate. You can access these functions through the generate submodule of the collection object.\nEach generative query works in addition to the regular search query, and wi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If OpenID Connect (OIDC) authentication is enabled, its details will be available through the /v1/.well-known/openid-configuration endpoint. The discovery endpoint accepts a GET request:If there is an OIDC provider, the endpoint returns the following fields:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/oidc",
          "webPageMainText": "If OpenID Connect (OIDC) authentication is enabled, its details will be available through the /v1/.well-known/openid-configuration endpoint.\nIf a token is configured, the endpoint redirects to it.\nThe discovery endpoint accepts a GET request:\nIf there is an OIDC provider, the endpoint returns the following fields:\nIf there is no OIDC provider, the endpoint returns a 404 HTTP status code.\nIf OIDC is configured, the endpoint returns a document like this:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/objects/post/objects/validate",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This example creates a collection for the movie data, including multiple named vector definitions. To use named vectors, your collection be configured with named vector definition. The key difference here is the use of NamedVectors class to define vectorizer configurations. This code builds on the multimodal example. Review that example for further explanations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors/nv_collections/create_collection",
          "webPageMainText": "To use named vectors, your collection be configured with named vector definitions.\nThis example creates a collection for the movie data, including multiple named vector definitions:\nThe key difference here is the use of NamedVectors class to define vectorizer configurations. Let's review the code in further detail:\nThis code builds on the multimodal example. Review that example for further explanations.\nThis definition allows each object to be represented by three vectors, named title, overview and poster_title.\nThis vector representation is generated from the title property (source_properties). The text2vec-openai module is used for vectorization.\nYou could use this to search for movies by similarities to their titles.\nThis vector representation is based on the overview property. As such, you could use this to search for movies by similarities to their plot or key ideas.\nThis vector representation is generated from a combination of the title and poster properties. The multi2vec-clip m"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This section includes reference guides for other modules, such as the spellcheck module and custom modules. You can find information about the backup module here. This section includes guide guides for the backup and spellcheck modules. The backup module can be found here. The spellcheck and custom module is available here."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/other-modules",
          "webPageMainText": "This section includes reference guides for other modules, such as the spellcheck module and custom modules. You can find information about the backup module here.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The ref2Vec-centroid module is used to calculate object vectors based on the centroid of referenced vectors. The idea is that this centroid vector would be calculated from the vectors of an object's references, enabling associations between clusters of objects. This is useful in applications such as making suggestionsbased on the aggregation of a user's actions or preferences."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/ref2vec-centroid",
          "webPageMainText": "The ref2Vec-centroid module is used to calculate object vectors based on the centroid of referenced vectors. The idea is that this centroid vector would be calculated from the vectors of an object's references, enabling associations between clusters of objects. This is useful in applications such as making suggestions based on the aggregation of a user's actions or preferences.\nThis module is enabled by default on the WCD.\nWhich modules to use in a Weaviate instance can be specified in the Docker Compose file. Ref2Vec-centroid can be added like this:\nIn your Weaviate schema, you must define how you want this module to vectorize your data. If you are new to Weaviate schemas, you might want to check out the tutorial on the Weaviate schema first.\nFor example, here is an Article class which is configured to use ref2vec-centroid. Doing so requires only a class-level moduleConfig, containing two fields:\nThe Article class specifies its hasParagraphs property as the only reference property to "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a fully managed Weaviate instance that runs in the cloud. It's a great way to get started as it requires no installation or maintenance. To connect to the WCD instance, you need to use the cluster URL and the API key."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/setup_weaviate/create_instance/create_wcs",
          "webPageMainText": "Here, you will create a Weaviate Cloud (WCD) instance. WCD is a fully managed Weaviate instance that runs in the cloud. It's a great way to get started with Weaviate, as it requires no installation or maintenance.\nGo to the WCD Console and log in with your credentials. If you don't have an account yet, you can sign up by clicking on the Register here link from the login screen.\nFrom the console, go to the Dashboard and click on the Create cluster button. From the following screen:\nClick on the Create button to create your Weaviate instance. The process will take a few minutes.\nOnce the instance is created, you will be able see its details by clicking on the Details button. Find the cluster URL and the API key.\nYou will need these details to connect to your Weaviate instance.\nTo connect to the Weaviate Cloud (WCD) instance, you need to use the cluster URL and the API key. You can find these details in the WCD Console.\nUse the connect_to_wcs function to connect to your WCD instance.\nSome"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "If not specified explicitly, the default distance metric in Weaviate iscosine. It can be set in the vectorIndexConfig field as part of the schema to any of the following types: larger distance values indicate lower similarity. If you're missing your favorite distance type and would like to contribute it, we'd be happy to review your PR."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/distances",
          "webPageMainText": "If not specified explicitly, the default distance metric in Weaviate is\ncosine. It can be set in the vectorIndexConfig field as part of the schema (example) to any of the following types:\nIn all cases, larger distance values indicate lower similarity. Conversely, smaller distance values indicate higher similarity.\nIf you're missing your favorite distance type and would like to contribute it to Weaviate, we'd be happy to review your PR.\nOn a typical Weaviate use case the largest portion of CPU time is spent calculating vector distances. Even with an approximate nearest neighbor index - which leads to far fewer calculations - the efficiency of distance calculations has a major impact on overall performance.\nYou can use the following overview to find the best possible combination of distance metric and CPU architecture / instruction set.\nIf you like dealing with Assembly programming, SIMD, and vector instruction sets we would love to receive your contribution for one of the combinations t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The default docker image doesn't need any configuration. To customize your instance, edit the configuration settings in the docker-compose.yml file. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally. You can use environment variables to control your Weaviates setup, authentication and authorization."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/docker-compose#configurator",
          "webPageMainText": "Weaviate supports deployment with Docker. If you use the default values, you don't need a docker-compose.yml file to run the image. To customize your instance, edit the configuration settings in the docker-compose.yml file.\nThe default docker image doesn't need any configuration. To run a basic Weaviate instance, run this command from a terminal:\nThe command sets the following default values:\nWe prepared a starter Docker Compose file, which will let you:\nSave the text below as docker-compose.yml:\nEdit the docker-compose.yml file to add your local configuration. To start your Weaviate instance, run this command in your shell:\nThe Configurator can generate a docker-compose.yml file for you. Use the Configurator to select specific Weaviate modules, including vectorizers that run locally (i.e. text2vec-transformers, or multi2vec-clip)\nYou can use environment variables to control your Weaviate setup, authentication and authorization, module settings, and data storage settings.\nA comprehensi"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a managed service that runs Weaviate for you. WCD is the fastest way to create a new instance and requires the least amount of effort for users. You can run Weaviates using containerization solutions such as Docker and Kubernetes."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/hello_weaviate/set_up",
          "webPageMainText": "Weaviate Cloud (WCD) is a managed service that runs Weaviate for you. You can also manage your own Weaviate instances using Docker, Kubernetes, or Embedded Weaviate.\nNo matter how you run Weaviate, the underlying code is identical. However, there are some operational differences to be aware of.\nWeaviate Cloud (WCD), is a managed SaaS service that requires no maintenance at your end.\nAs it is managed by Weaviate (the company - the software is not sentient... yet). WCD is the fastest way to create a new instance of Weaviate and requires the least amount of effort for users.\nWCD has Weaviate instances that are pre-configured for your convenience. They include a number of Weaviate modules by default. They also have built-in support for user authentication.\nWCD includes a free \"sandbox\" tier. The WCD sandbox is our recommended method of running Weaviate in this course.\nYou can run Weaviate instances using containerization solutions such as Docker and Kubernetes.\nRunning your own instance pr"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The buzz around generative AI has greatly increased interest in AI-native tech. More and more people realize that a vector database like ours may be nearly essential for most applications of LLMs. Meanwhile our core open-source technology has passed the MVP stage and new instances of product-market fit are occurring so fast that it's a challenge to keep up."
              }
            ]
          },
          "url": "https://weaviate.io/company/playbook/cell-theory-planning-for-organic-growth",
          "webPageMainText": "\nThe last six months we\u2019ve felt a quantum shift at Weaviate. The buzz around generative AI has greatly increased interest in AI-native tech. More and more people realize that a vector database like ours may be nearly essential for most enterprise applications of LLMs. Meanwhile our core open-source technology has passed the MVP stage and new instances of product-market fit are occurring so fast that it\u2019s a challenge to keep up with them.\nHence that quantum shift; now, our challenge isn\u2019t proving that there\u2019s a role for Weaviate in the coming AI disruption, it is determining how best to scale our operation.\nAs a founder, this is a good problem to have! In many ways, it is the very problem Etienne and I set out to have when we created our company in 2019. But shaping the growth of a company is very different from shaping a product. It calls for a different kind of vision because people aren\u2019t code, tools, or processes.\nRather than envision departments and hierarchical structures, I natur"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Chunking is the pre-processing step of splitting texts into smaller pieces of texts, i.e. \"chunks\" It can have a significant impact on the performance of vector databases, and outputs of language models. This is a preview version of this unit. Some sections are not yet complete - such as videos and quiz questions. Check back later for the full version."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking/introduction",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nChunking is the pre-processing step of splitting texts into smaller pieces of texts, i.e. \"chunks\".\nYou know by now that a vector database stores objects by corresponding vectors to capture their meaning. But just how much text does each vector capture the meaning of? Chunking defines this. Each chunk is the unit of information that is vectorized and stored in the database.\nConsider a case where the source text comprises a set of books. A chunking method could conceivably split the text into a set of chapters, paragraphs, sentences, or even words, into chunks.\nWhile this is a simple concept, it can have a significant impact on the performance of vector databases, and outputs of language models.\nLet's go back to the above example, building a vecto"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Core uses a typical Test Pyramid approach. The tests are grouped into the following three levels:Unit tests test the smallest possible unit, mostly a struct in golang. Unit tests are designed to validate the business logic and not the internals.Integration tests test anything that crosses a boundary."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/tests#journey-tests",
          "webPageMainText": "Weaviate Core follows a typical Test Pyramid approach. As Weaviate itself contains no graphical user interface (GUI), the highest level tests test the user journeys at an API level.\nThe tests are grouped into the following three levels:\nUnit tests test the smallest possible unit, mostly one \"class\" (usually a struct in golang) with its methods. Unit tests are designed to validate the business logic and not the internals.\nUnit tests are stateless and do not depend on any external programs or runtime other than the Golang-built tools. (Note: We do make use of the stretchr/testify packages. However, they are installed with any other code-level dependency and don't require running dedicated software).\nThis makes tests fast to execute, easy to adapt and easy to run with third-party tools like code watchers.\nIntegration tests test anything that crosses a boundary. A boundary could be the dependence on an external party (e.g. a third-party database) or an independent custom tool, such as the "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This is the sixth year for the list of \u201cAI startups to watch\u2019, which Forbes develops with Sequoia Capital and Meritech Capital. Companies under consideration are vetted by two separate judging panels. It\u2019s still too early to really know all the companies that will evolve, flourish, and grow as the economy is influenced by generative AI."
              }
            ]
          },
          "url": "https://weaviate.io/blog/forbes-ai-50-2024",
          "webPageMainText": "\nOf course, I was happy to see Weaviate on Forbes\u2019 recently released 2024 AI 50 list. This is the sixth year for the list of \u201cAI startups to watch\u201d, which Forbes develops with Sequoia Capital and Meritech Capital. Companies under consideration are vetted by two separate judging panels\u2014one that looks at products from a technical perspective and another that examines performance from an investment and business perspective. Since previous selectees include Hugging Face, Anthropic, and Databricks, it would be an understatement to say I\u2019m flattered that list now includes Weaviate.\nHearing we\u2019d be included in this list was a happy surprise and testament to the hard work of all the talented folks at Weaviate who I think very highly of. But honestly, what I think or what any group of experts thinks is less important than what developers decide. It\u2019s still too early to really know all the companies that will evolve, flourish, and grow as the economy is influenced by generative AI; things are mo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "OpenAI recently announced embeddings that you can simply use chunks of (say the first 8, 16, 32, 64, 128 or 256 ... dimensions of the total 2048d vector) They use Matryoshka representation learning(MRL) to do this."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper21",
          "webPageMainText": "\nOpenAI recently announced embeddings that you can simply use chunks of (say the first 8, 16, 32, 64, 128 or 256 ... dimensions of the total 2048d vector) they use Matryoshka representation learning(MRL). \nThis is how they work, In Short\u23e9:\nMLR allows you to use a subset of the dimensions of the embedding vector - earlier dimensions store more information than dimensions later on in the vector, which simply add more details\nYou can understand how this works by the analogy of trying to classify an image at multiple resolutions - the lower res give high-level info and the higher res add details - Human perception of the natural world also has a naturally coarse-to-fine granularity\nThis is done by modifying the loss function which is optimized. If previously the loss function was L, for MRL we break down the Loss function into the sum of the losses on individual vector dimension ranges: Loss_Total =  L(upto 8d) + L(upto 16d) + L(upto 32d) + ... + L(upto 2048d) - Now there is incentive for "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This tutorial demonstrates having Weaviate create vectors with a vectorizer. For a tutorial on using custom vectors, see this tutorial. We will use a (tiny) dataset of quizzes. The data comes from a TV quiz show (\"Jeopardy!\")Try it directly on Google Colab (or go to the file)."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/quickstart",
          "webPageMainText": "Welcome to the Quickstart guide for Weaviate, an open-source vector database. This tutorial is intended to be a hands-on introduction to Weaviate.\nIn the next ~20 minutes, you will:\nVectors are mathematical representations of data objects, which enable similarity-based searches in vector databases like Weaviate.\nWith Weaviate, you have options to:\nThis tutorial demonstrates having Weaviate create vectors with a vectorizer. For a tutorial on using custom vectors, see this tutorial.\nWe will use a (tiny) dataset of quizzes.\nThe data comes from a TV quiz show (\"Jeopardy!\")\nTry it directly on Google Colab (or go to the file).\nYou need a Weaviate instance to work with. We recommend creating a free cloud sandbox instance on Weaviate Cloud (WCD).\nGo to the WCD quickstart and follow the instructions to create a sandbox instance, and come back here.  Collect the API key and URL from the Details tab in WCD.\nIf you prefer another method, see this section.\nWe suggest using a Weaviate client (read m"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In 1.25 we\u2019re introducing the dynamic vector index. This will initially create a flat index to be used and once the number of objects exceeds a certain threshold (by default 10,000 objects) it will dynamically switch you over to an HNSW index. Here is how you can configure Weaviate to use a dynamic index."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-25-release",
          "webPageMainText": "Weaviate 1.25 is here!\nHere are the release \u2b50\ufe0fhighlights\u2b50\ufe0f!\n\n\nConfiguring Weaviate and not sure if you have enough objects to justify building a full HNSW index or to stick to a flat index? We\u2019ve got good news for you: In 1.25 we\u2019re introducing the dynamic vector index!\nPreviously you\u2019d have to decide at the outset if you wanted a flat or HNSW index. The flat index was ideal for use cases with a small object count where brute force nearest neighbors search was viable and would provide lower memory overhead and good latency. As the object count increased the flat index would become prohibitively slow and this is what the HNSW index would solve.\nWith 1.25 you can now configure Weaviate to use a dynamic index. This will initially create a flat index to be used and once the number of objects exceeds a certain threshold (by default 10,000 objects) it will dynamically switch you over to an HNSW index.\nHere is how you can configure Weaviate to use a dynamic index:\nThis is a one-way dynamic sw"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "It is also possible to add a cross-reference property to an existing collection definition. This requires adding reference properties in both directions, and adding two cross-references per object pair. Use cross- references to establish directional relationships between collections. Use the reference property in the collection definition before adding cross-References to it."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/cross-references#add-a-one-way-cross-reference-property",
          "webPageMainText": "Use cross-references to establish directional relationships between collections.\nNotes:\nInclude the reference property in the collection definition before adding cross-references to it.\nIt is also possible to add a cross-reference property to an existing collection definition.\nSpecify a cross-reference when creating an object.\nSpecify the required id and properties for the source and the target.\nThis requires adding reference properties in both directions, and adding two cross-references per object pair (from A -> to B and from B -> to A).\nCreate the JeopardyCategory collection:\nCreate the JeopardyQuestion collection including the reference property to JeopardyCategory:\nModify JeopardyCategory to add the reference to JeopardyQuestion:\nAnd add the cross-references:\nWeaviate allows creation of multiple cross-references from one source object.\nCross-references can be read as part of the object.\nDeleting a cross-reference with the same parameters used to define the cross-reference.\nWhat ha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Multimodal RAG allows you to pack retrieved context into a prompt so that a language model can read relevant information before generating a response. This function is critical and allows us to integrate knowledge in a more scalable and modular way into LLMs. Vector databases provide an ideal store from which multimedia knowledge can be retrieved and can capture the meaning of all of these modalities."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper6",
          "webPageMainText": "\nWhat's better than retrieval augmented generation(RAG)? \ud83e\udd41\ud83e\udd41\ud83e\udd41 \nMultimodal RAG! \ud83d\ude0e\ud83d\udc4c\ud83d\udd25\nRAG allows you to pack retrieved context into a prompt so that a language model can read relevant information before generating a response - this function is critical and allows us to integrate knowledge in a more scalable and modular way into LLMs. \nBut isn't a picture worth a thousand words? So why just stop at retrieving textual context??\nThis is where multimodal RAG(MM-RAG) comes into the picture!\nIf you have an external knowledge database that can represent and store multimedia like images, audio, and video, just as well as it can text, then you can retrieve these objects and provide them a richer context for Large Multimodal Models to generate with. \nVector databases provide an ideal store from which multimedia knowledge can be retrieved and can capture the meaning of all of these modalities. \nA paper(https://arxiv.org/abs/2211.12561) earlier this year from @michiyasunaga at Stanford presented the f"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "In this article, we will focus on integration tests. Integrated testing is an important part of the development process, and especially so for complex applications. Weaviate-based apps usually fall in this category. We'll show you how to make testing easier with Embedded Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/blog/automated-testing",
          "webPageMainText": "\nAs a software engineer with experience in test automation, I firmly believe in Test-Driven Development, and more specifically, incorporating integration testing from the very early stages of developing an application.\nBut you probably know that writing tests is quite a task in itself, and in many cases running them can also be a chore. For example, the test suite may need to set up and tear down a separate service such as a database, which can be time-consuming and error-prone.\nI'm here to tell you that it doesn't have to be that way. In this article, I'll show you how to make testing easier with Embedded Weaviate, and other tips for better automated testing.\nAnd doing so, you might just discover the hidden gem that is the value provided by adding tests to your applications.\nIn this article, we will focus on integration tests. Integrated testing is an important part of the development process, and especially so for complex applications. Weaviate-based apps usually fall in this categor"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-aws module allows Weaviate to access AWS Bedrock and AWS Sagemaker services. The module accepts parameters through the request header, collection configuration, or environment variables. To use the module, enable it in your Docker Compose file ( docker-compose.yml)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-aws",
          "webPageMainText": "Starting in v1.22.5, AWS Bedrock is supported.\nStarting in v1.24.1, AWS Sagemaker is supported.\nThe text2vec-aws module allows Weaviate to access AWS Bedrock and AWS Sagemaker services.\nIf you need to run your own embedding service, use Sagemaker. Bedrock uses AWS models.\nThe module accepts parameters through the request header, collection configuration, or environment variables. Some parameters (such as the API key) can be set in multiple ways.\nWhere the same parameter can be set in multiple ways, setting it at query-time through the HTTP request header (if possible) will have the highest precedence.\nWe suggest you only set any given parameter in one place to avoid confusion.\nYou must provide access key based AWS credentials to use the API, including an AWS access key and a corresponding AWS secret access key. You can set them as environment variables, or provide them at query time.\nTo use text2vec-aws, enable it in your Docker Compose file (docker-compose.yml).\nThis configuration doe"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Add reranker-cohere to the ENABLE_MODULES environment variable. This module is enabled by default in WCD. You can also specify options such as the model to use. This example configures the Document collection to use the rerank-multilingual-v3.0 model."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/reranker-cohere",
          "webPageMainText": "This module is enabled by default in WCD.\nAdd reranker-cohere to the ENABLE_MODULES environment variable.\nBelow is an example Docker Compose file, which will spin up Weaviate with the reranker-cohere module (as well as text2vec-cohere).\nThe reranker-cohere module can be configured for any collection in the schema. You can also specify options such as the model to use.\nThis example configures the Document collection to use the reranker-cohere module, with the rerank-multilingual-v3.0 model, and to return the documents in the response.\nIf there is only one reranker module enabled, you don't need to do anything. The reranker module will be used by default.\nWhere multiple reranker modules are enabled, you must specify the reranker module to be used for each collection. You can do this by adding the desired reranker in the moduleConfig section of the schema, even without any further settings.\nThe reranker-cohere module supports the following models:\nYou can also pass in your fine-tuned rera"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The /v1/ modules endpoint is available for all modules that are connected to your Weaviate instance. The available module endpoints thus depend on how you configured your weaviate. For API references of specific modules, visit the specific modules pages. If you have any questions or feedback, let us know in the user forum."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest_legacy/modules",
          "webPageMainText": "The /v1/modules endpoint is available for all modules that are connected to your Weaviate instance. The available module endpoints thus depend on how you configured your weaviate. For API references of specific modules offered by Weaviate, visit the specific modules pages, for example the text2vec-contextionary.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Moonsift offers an ecommerce browser extension for users to curate shoppable boards with products from across the internet. Stylists and curators use Moonsift to create collections, registries, and wish lists that can be shared and shopped with a simple link. Thousands of customers add products from tens of thousands of retailers per month to Moonsift."
              }
            ]
          },
          "url": "https://weaviate.io/blog/moonsift-story",
          "webPageMainText": "\nUK-based startup Moonsift is harnessing the power of AI\u2014using machine learning models and Weaviate\u2019s vector database\u2014to help online shoppers discover the products they love. \nMoonsift offers an ecommerce browser extension for users to curate shoppable boards with products from across the internet. Stylists and curators use Moonsift to create collections, registries, and wish lists that can be shared and shopped with a simple link. While thousands of customers add products from tens of thousands of retailers per month to Moonsift, co-founders David Wood and Alex Reed have a bigger vision for improving product discoverability for online shoppers. \nWith combined experience in natural language processing (NLP), data science, and consulting for retail brands, Wood and Reed saw how retailers unknowingly restrict their own discoverability by tailoring keywords for search engines rather than users. How even with the most illustrious descriptions, shoppers struggle to find the products they\u2019re"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Paid support is available for Serverless Clusters, Weaviate Enterprise SaaS, and Bring your Own Cloud clusters. Sandboxes and self-hosted clusters are not eligible for paid support. Professional support is email based and is available 24 hours a day, seven days a week."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/support-levels",
          "webPageMainText": "Weaviate Cloud (WCD) offers multiple levels of support. You have the flexibility to choose the level of support that you need.\nSandboxes and self-hosted clusters are not eligible for paid support.\nPaid support is available for Serverless Clusters, Weaviate Enterprise SaaS, and Bring your Own Cloud clusters.\nFor Serverless instances, the default support level is Standard support. You are automatically enrolled for Standard support when you create a Serverless cluster. To switch to another level, contact our sales team\nFor Weaviate Enterprise SaaS and Bring your Own Cloud clusters, contact our sales team to discuss which level of support is right for you.\nStandard support is email based and is available during business hours.\nMonitoring. The WCD team monitors your cluster.\nSeverity determines incident response time:\nProfessional support is email based and is available 24 hours a day, seven days a week.\nSeverity 1 and Severity 2 incident response includes a  follow up phone call.\nMonitori"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate vector database. Explore enterprise use cases heavily used by our customers adopting generative AI features, search capabilities, and RAG with Weaviate. Use Weaviates vector database to help your customers adopt generativeAI features and search capabilities. Use the Weaviated vector database for your customers to help you with your customers' use cases."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/application",
          "webPageMainText": "Explore enterprise use cases heavily used by our customers adopting generative AI features, search capabilities, and RAG with Weaviate vector database.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate seamlessly integrates with the ImageBind library, allowing users to leverage compatible models directly within the Weaviate database. These integrations empower developers to build sophisticated AI-driven applications with ease. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/imagebind",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nMeta's ImageBind library can be used with a wide range of models for natural language processing. Weaviate seamlessly integrates with the ImageBind library, allowing users to leverage compatible models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\nWeaviate integrates with the ImageBind model by spinning it up in a container. This allows users to host their own model and use them with Weaviate.\n\nThe ImageBind embedding model transforms multi-modal data into high-dimensional vector representations, capturing semantic meaning and context.\nWeaviate integrates with ImageBind's embedding models to enable seamless vectorization of data. This integration allows users to perform semantic and hybrid search operations without the need for additional preprocessing or data transformati"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud was built to help developers scale AI applications with ease and confidence. Weaviate is built on an extensible framework with flexible deployment options that can adapt to the needs of your business as they evolve. We\u2019re committed to offering the capabilities our enterprise customers need to meet security and compliance requirements."
              }
            ]
          },
          "url": "https://weaviate.io/security",
          "webPageMainText": "Weaviate Cloud was built to help developers scale AI applications with ease and confidence.\nWeaviate is built on an extensible framework with flexible deployment options that can adapt to the needs of your business as they evolve. We\u2019re committed to offering the capabilities our enterprise customers need to meet security and compliance requirements.\u00a0\nWeaviate Cloud was built to offload the burden of managing a vector database and give development teams peace of mind. Whether you\u2019re running Weaviate as a Serverless, Weaviate Enterprise Cloud, or Bring Your Own Cloud solution\u2013 our top priority is keeping your data safe and available. Read more about our SLAs here.\u00a0\nRun in a dedicated tenant or in your own VPC.\u00a0\nData is fully encrypted in transit and at rest.\nRely on built-in mechanisms from your identity provider.\nFully isolate data with advanced tenant management.\nConfigurable backups, automated daily.\nProactive monitoring. On standby 24/7 for incident support.\nHigh availability and res"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.18 brings a set of great features, performance improvements, and fixes. This release introduces a compact, modern data structure to Weaviate called \u201cRoaring bitmaps\u201d The new Roaring bitmap indexing dramatically speeds up filtered searches. It provides up to 1000(!) times faster performance in some cases."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-18-release#faster-filtering-with-roaring-bitmaps",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.18, which brings a set of great features, performance improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\n\n\nThis release introduces a compact, modern data structure to Weaviate called \u201cRoaring bitmaps\u201d that will replace the internals of the inverted index. The new Roaring bitmap indexing dramatically speeds up filtered searches, and we\u2019ve seen it provide up to 1000(!) times faster performance in some cases.\nAt Weaviate, we've been on a journey to keep up with the growing needs of our users. As more and more vectors are added to Weaviate instances, the \"allow list\" of pre-filtered items can reach tens, or hundreds of millions of objects. This can result in long retrieval times that are far from ideal from a user perspective. The introduction of Roaring Bitmaps is another step that will help us and our users scale"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a search engine that uses inverted indices to store data and values. Data is stored as vectors, which enables semantic search. This combination of data storage is unique, and enables fast, filtered and semantic search from end-to-end. Weaviate comes containerized to make it easier for others to build their own systems."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/faq",
          "webPageMainText": "Our goal is three-folded. Firstly, we want to make it as easy as possible for others to create their own semantic systems or vector search engines (hence, our APIs are GraphQL based). Secondly, we have a strong focus on the semantic element (the \"knowledge\" in \"vector databases,\" if you will). Our ultimate goal is to have Weaviate help you manage, index, and \"understand\" your data so that you can build newer, better, and faster applications. And thirdly, we want you to be able to run it everywhere. This is the reason why Weaviate comes containerized.\nOther database systems like Elasticsearch rely on inverted indices, which makes search super fast. Weaviate also uses inverted indices to store data and values. But additionally, Weaviate is also a vector-native search database, which means that data is stored as vectors, which enables semantic search. This combination of data storage is unique, and enables fast, filtered and semantic search from end-to-end.\nYes, we do - check out Weaviate"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open-source vector database. The key difference is that they can perform tasks based on similarity. Using this type of search requires you to identify terms that may be relevant. Weaviate can also be used to store and retrieve data in a variety of ways."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/theory/hello_weaviate/intro_weaviate",
          "webPageMainText": "Weaviate is an open-source vector database. But what does that mean? Let's unpack it here.\nWeaviate is a fantastic tool for retrieving the information you need, quickly and accurately. It does this by being an amazing vector database.\nYou may be familiar with traditional databases such as relational databases that use SQL. A database can catalog, store and retrieve information. A vector database can carry out these tasks also, with the key difference being that they can perform these tasks based on similarity.\nImagine that you are searching a relational database containing articles on cities, to retrieve a list of \"major\" European cities. Using SQL, you might construct a query like this:\nWhich would return cities that contained any of these strings (major, important, prominent, ... etc) in the wiki_summary column.\nThis works well in many circumstances. However, there are two significant limitations with this approach.\nUsing this type of search requires you to identify terms that may ha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/resources",
          "webPageMainText": "Weaviate scales well for large projects. Smaller projects, less than 1M objects, do not require resource planning. For medium and large-scale projects, you should plan how to get the best performance from your resources. While you design you system, keep in mind CPU and memory management. CPU and memory are the primary resources for Weaviate instances. Depending on the modules you use, GPUs may also play a role.\nYou can set environment variables to manage Weaviate's resource usage, as to prevent Weaviate from using all available resources. The following environment variables are available:\nLIMIT_RESOURCES: When set to true, Weaviate automatically limits its resource usage. It sets memory usage to 80% of the total memory and uses all but one CPU core. It overrides any GOMEMLIMIT values but respects GOMAXPROCS settings.\nGOMEMLIMIT: This sets the memory limit for the Go runtime, which should be around 10-20% of the total memory available for Weaviate. It controls the aggressiveness of the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate supports client libraries for these languages: English, German, French, Spanish, Italian, Portuguese, Spanish. Weaviate is not officially maintained by these community contributed libraries. To contribute to these libraries, contact the maintainers directly. If you have a Weaviates client library you would like to add here, let us know in the forum or on Slack."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/community",
          "webPageMainText": "Weaviate supports client libraries for these languages:\nMembers of the Weaviate community provide client libraries for some additional languages. These community contributed libraries are not officially maintained by Weaviate. However, we are very grateful for the work these developers do, and we want to share it with you.\nTo contribute to these libraries, contact the maintainers directly.\nIf you have a Weaviate client library you would like to add here, let us know in the forum or on Slack.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "It is also possible to add a cross-reference property to an existing collection definition. This requires adding reference properties in both directions, and adding two cross-references per object pair. Use cross- references to establish directional relationships between collections. Use the reference property in the collection definition before adding cross-References to it."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/cross-references#read-cross-references",
          "webPageMainText": "Use cross-references to establish directional relationships between collections.\nNotes:\nInclude the reference property in the collection definition before adding cross-references to it.\nIt is also possible to add a cross-reference property to an existing collection definition.\nSpecify a cross-reference when creating an object.\nSpecify the required id and properties for the source and the target.\nThis requires adding reference properties in both directions, and adding two cross-references per object pair (from A -> to B and from B -> to A).\nCreate the JeopardyCategory collection:\nCreate the JeopardyQuestion collection including the reference property to JeopardyCategory:\nModify JeopardyCategory to add the reference to JeopardyQuestion:\nAnd add the cross-references:\nWeaviate allows creation of multiple cross-references from one source object.\nCross-references can be read as part of the object.\nDeleting a cross-reference with the same parameters used to define the cross-reference.\nWhat ha"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's integration with Hugging Face's APIs allows you to access their models' capabilities directly from Weaviate. The model provider integration pages are new and still undergoing improvements. The integration is enabled by default on Weaviates Cloud (WCD) serverless instances. Go to Hugging face to sign up and obtain an API key."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/huggingface/embeddings",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nWeaviate's integration with Hugging Face's APIs allows you to access their models' capabilities directly from Weaviate.\nConfigure a Weaviate vector index to use an Hugging Face Hub embedding model, and Weaviate will generate embeddings for various operations using the specified model and your Hugging Face API key. This feature is called the vectorizer.\nAt import time, Weaviate generates text object embeddings and saves them into the index. For vector and hybrid search operations, Weaviate converts text queries into embeddings.\n\nYour Weaviate instance must be configured with the Hugging Face vectorizer integration (text2vec-huggingface) module.\nThis integration is enabled by default on Weaviate Cloud (WCD) serverless instances.\nYou must provide a valid Hugging Face API key to Weaviate for this integration. Go to Hugging Face to sign up and obtain an API key.\nP"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model. It encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware. The ONNX-enabled images can use ONNx Runtime for faster inference processing on CPUs."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-transformers",
          "webPageMainText": "The text2vec-transformers module enables Weaviate to obtain vectors locally from text using a transformers-based model.\ntext2vec-transformers encapsulates models in Docker containers, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nTransformer model inference speeds are usually about ten times faster with GPUs. If you have a GPU, use one of the GPU enabled models.\nIf you use text2vec-transformers without GPU acceleration, imports or nearText queries may become bottlenecks. The ONNX-enabled images can use ONNX Runtime for faster inference processing on CPUs. Look for the -onnx suffix in the image name.\nAlternatively, consider one of the following options:\nThis module is not available on Weaviate Cloud.\nTo use text2vec-transformers, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to genera"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The multi2vec-clip module enables Weaviate to obtain vectors locally from text or images using a CLIP model. It encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware. As of Weaviates v1.24.2, you can use multiple inference containers."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-clip#additional-search-operators",
          "webPageMainText": "The multi2vec-clip module enables Weaviate to obtain vectors locally from text or images using a CLIP model.\nmulti2vec-clip encapsulates the model in a Docker container, which allows independent scaling on GPU-enabled hardware while keeping Weaviate on CPU-only hardware, as Weaviate is CPU-optimized.\nKey notes:\nThis module is not available on Weaviate Cloud.\nTo use multi2vec-clip, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nAs of Weaviate v1.24.2, you can use multiple inference containers with multi2vec-clip. This allows you to use different models for different collections by setting the inferenceUrl in the collection configuration.\nThis configuration enables multi2vec-clip, sets it as the default vectorizer, and sets the parameters for the Docker container, including setting it to use multi2vec-clip:sentence"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Researchers from Cambridge released a paper developing a method called SelfCheckGPT. It uses only black-box access to a LLM through an API to assess if it's hallucinating. They report higher AUC-PR scores in sentence-level hallucination detection and higher correlation scores in passage-level factuality."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper9",
          "webPageMainText": "\n\u2753Can you really get a LLM to self-check its own responses for hallucinations?\n\ud83d\udcdcResearchers from Cambridge released a paper developing a method called SelfCheckGPT - a framework that uses only black-box access to a LLM through an API to assess if it's hallucinating.\n\u23e9TLDR: They pass in the same prompt to the model multiple times and generate N more sample responses in addition to the original response and get the LLM to check for inconsistencies.\n\ud83d\udcd1They compare how often each sentence in the original response contradicts these samples using the following prompt for every sentence:\nThe intuition is that if an LLM has knowledge of a given concept, sampled responses are likely to be similar and contain consistent facts. Hallucinated statements, on the other hand, are more likely to diverge from the extra sampled responses and will contradict one another.\nThey report higher AUC-PR scores in sentence-level hallucination detection and higher correlation scores in passage-level factuality asse"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page describes the code-level architecture of media2vec. The module architecture is dependent on the respective module. A module is essentially any struct that implements a specific Golang interface. The main interface is a really small one - a module essentially only has to provide a Name() string and Init(...) error method."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-modules/architecture#visualization",
          "webPageMainText": "This page describes the code-level architecture. The high-level architecture\ndepends on the respective module. For example, media2vec modules typically\nuse a microservice pattern to offload model inference into a separate\ncontainer, see this example for the text2vec-transformers high-level\narchitecture.\nA module is essentially any struct that implements a specific Golang interface.\nTo keep module development comfortable, we have decided that the main interface\nis a really small one. A module essentially only has to provide a Name()\nstring and Init(...) error method.\nIf your struct implements this small\ninterface\nit is already a valid Weaviate Module.\nAlthough a valid module, the above example provides little value to the user -\nit can't do anything. We cannot predict which capability a module will provide\nand don't want to force every module developer to implement hundreds of methods -\nonly to have 95 of them return \"not implemented\".\nThus, we have decided to make each capability a sma"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate lets you search collections with named vectors. Each search must specify a \"target\" vector. This applies for near_text and near_ vector searches, as well as multimodal searches such as near_image. Let's explore a few examples here."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors/nv_queries/searches",
          "webPageMainText": "As collections with named vectors can include multiple vectors, any vector or similarity search must specify a \"target\" vector.\nThis applies for near_text and near_vector searches, as well as multimodal searches such as near_image and so on. Let's explore a few examples here.\nHere, we look for entries in \"MovieNVDemo\" based on their similarity to the phrase \"A joyful holiday film\". Note, however, that we show multiple versions of the same query, each with a different target_vector parameter:\nEach named vector here is based on a different property of the movie data.\nThe first search compares the meaning of the movie title with the query, the second search compares the entire summary (overview) with the query, and the third compares the poster (and the title) with the query.\nWeaviate also allows each named vector to be set with a different vectorizer. You will recall that the poster_title vector is created by the CLIP models, while the title and overview properties are created by the Ope"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#read-a-single-collection-definition",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#timeout-values",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The cross-reference type is the graph element of Weaviate. It allows you to link to any number of instances of a given class. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/datatypes#datatype-date",
          "webPageMainText": "When creating a property, Weaviate needs to know what type of data you will give it. Weaviate accepts the following types:\nRefer to this section on how to configure the tokenization behavior of a text property.\nPrior to v1.19, Weaviate supported an additional datatype string, which was differentiated by tokenization behavior to text. As of v1.19, this type is deprecated and will be removed in a future release.\nUse text instead of string. text supports the tokenization options that are available through string.\nThe cross-reference type is the graph element of Weaviate: you can create a link from one object to another. In the schema you can define multiple classes to which a property can point, in a list of strings. The strings in the dataType list are names of classes defined elsewhere in the schema. For example:\nThe cross-reference type objects are arrays by default. This allows you to link to any number of instances of a given class (including zero).\nIn the above example, our objects "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate follows GraphQL naming conventions. Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections. Use properties to configure additional parameters such as data type, index characteristics, or tokenization. For details, see:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/collections#define-multiple-named-vectors",
          "webPageMainText": "Every object in Weaviate belongs to exactly one collection. Use the examples on this page to manage your collections.\nNewer Weaviate documentation discuses \"collections.\" Older Weaviate documentation refers to \"classes\" instead. Expect to see both terms throughout the documentation.\nTo create a collection, specify at least the collection name. If you don't specify any properties, auto-schema creates them.\nWeaviate follows GraphQL naming conventions.\nIf you use an initial upper case letter to define a property name, Weaviate changes it to a lower case letter internally.\nProperties are the data fields in your collection. Each property has a name and a data type.\nUse properties to configure additional parameters such as data type, index characteristics, or tokenization.\nFor details, see:\nBy default, Weaviate creates missing collections and missing properties. When you configure collections manually, you have more precise control of the collection settings.\nTo disable auto-schema set AUTOS"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud uses Stripe for billing. Sandbox clusters are free. You do not need a billing account to create a Sandbox cluster.Serverless clusters are charged for resource usage. The monthly charge is determined by your usage and your support level. Weaviate offers three levels of support, Standard, Professional, and Business Critical."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/platform/billing",
          "webPageMainText": "Sandbox clusters are free. You do not need a billing account to create a Sandbox cluster.\nServerless clusters are charged for resource usage. The monthly charge is determined by your usage and your support level. You have to have a billing account to create a serverless cluster.\nTo estimate costs for different combinations of usage levels and SLAs, see the pricing calculator.\nWeaviate Cloud (WCD) uses Stripe for billing. To create a Stripe account follow these steps:\nUsage charges reflect the number and size of the objects in your collection. Weaviate polls each collection to determine a daily object count.\nThe values are added together and normalized to get a base price. The base price is multiplied by the pricing rate for the cluster's SLA tier.\nIf the cluster has high availability, the pricing rate is multiplied by three.\nThere are significant cost savings when compression is enabled.\nWeaviate offers three levels of support, Standard, Professional, and Business Critical. Each suppor"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn how to deploy Weaviate on Kubernetes, a popular container orchestration platform. You will learn how to set up a local Kuberne cluster and deploy a Weaviates instance. You'll also learnHow to configure the Weaviated instance on KuBERnetes. This short, project-based unit will teach you how to use KuberNetes."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/deployment/k8s",
          "webPageMainText": "In this short, project-based unit, you will learn how to deploy Weaviate on Kubernetes, a popular container orchestration platform.\nYou will learn how to set up a local Kubernetes cluster and deploy a Weaviate instance on Kubernetes. You will also learn how to configure the Weaviate instance on Kubernetes.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "GRPC is a high-performance, open-source universal RPC framework that is contract-based. It is based on HTTP/2 and Protocol Buffers, and is therefore very fast and efficient. The latest (v4) Weaviate Python client library supports gRPC, and other client libraries will follow."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/grpc",
          "webPageMainText": "Starting with Weaviate v1.19.0, a gRPC interface has been progressively added to Weaviate. gRPC is a high-performance, open-source universal RPC framework that is contract-based and can be used in any environment. It is based on HTTP/2 and Protocol Buffers, and is therefore very fast and efficient.\nAs of Weaviate v1.23.7, the gRPC interface is considered stable. The latest (v4) Weaviate Python client library supports gRPC, and the other client libraries will follow.\nA gRPC interface is defined through its Protocol Buffer, or Protobuf (read more) definitions.\nIn the case of Weaviate, the .proto files are listed in the Core library's proto directory.\nThis directory contains the following files:\nTo take advantage of the gRPC API, we recommend using the latest version of Weaviate. We suggest using port 50051 for gRPC calls. This can be set in the configuration file for Weaviate. (Note that Weaviate Cloud (WCD) uses port 443 for gRPC.)\nAs an example, the snippet below maps 50051 as the host"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "A hybrid search combines bm25 searches with a vector search. It produces rankings from a combination of the two results. This can produce helpful results when a search alone is not producing desired results. For example, it may be useful when you want particular keywords to weight the results a certain way."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/zero_to_mvp/queries_2/hybrid",
          "webPageMainText": "A hybrid search combines bm25 searches that you just learned about with a vector search, producing rankings from a combination of the two results.\nThis can produce helpful results when a vector search or a keyword search alone is not producing desired results. For example, it may be useful when a vector search alone is producing too many irrelevant results, and you want particular keywords to weight the results a certain way.\nA hybrid search works by combining the results of a bm25 search with the results of a vector search. More specifically, it uses a combination of each result's BM25F search ranking and its vector search ranking among the set of results.\nThe sum of the inverse of the BM25F ranking and the vector search ranking is used to produce a final score for each result, with any weighting (alpha) applied if applicable. The final score is then used to rank the results.\nThis has the effect of rewarding results that score high in at least one of the searches. For example, take th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#batch-sizing",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Question and Answer (Q&A) module is a Weaviate module for answer extraction from data. It uses BERT-related models for finding and extracting answers. The qna-transformers module tries to find an answer in the data objects of the specified class. There are currently five different Question Answering models available."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/reader-generator-modules/qna-transformers#graphql-ask-search",
          "webPageMainText": "The Question and Answer (Q&A) module is a Weaviate module for answer extraction from data. It uses BERT-related models for finding and extracting answers. This module can be used in GraphQL Get{...} queries, as a search operator. The qna-transformers module tries to find an answer in the data objects of the specified class. If an answer is found within the given certainty range, it will be returned in the GraphQL _additional { answer { ... } } field. There will be a maximum of 1 answer returned, if this is above the optionally set certainty. The answer with the highest certainty (confidence level) will be returned.\nThere are currently five different Question Answering models available (source: Hugging Face Model Hub): distilbert-base-uncased-distilled-squad (uncased), bert-large-uncased-whole-word-masking-finetuned-squad (uncased), distilbert-base-cased-distilled-squad (cased), deepset/roberta-base-squad2, and deepset/bert-large-uncased-whole-word-masking-squad2 (uncased). Note that no"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "When running Weaviate with Docker or Kubernetes, you can persist its data by mounting a volume to store the data outside of the containers. Doing so will cause the Weaviates instance to also load the data from the mounted volume when it is restarted."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/persistence#disk-pressure-warnings-and-limits",
          "webPageMainText": "When running Weaviate with Docker or Kubernetes, you can persist its data by mounting a volume to store the data outside of the containers. Doing so will cause the Weaviate instance to also load the data from the mounted volume when it is restarted.\nNote that Weaviate now offers native backup modules starting with v1.15 for single-node instances, and v1.16 for multi-node instances. For older versions of Weaviate, persisting data as described here will allow you to back up Weaviate.\nWhen running Weaviate with Docker Compose, you can set the volumes variable under the weaviate service and a unique cluster hostname as an environment variable.\nIn the case you want a more verbose output, you can change the environment variable for the LOG_LEVEL\nA complete example of a Weaviate without modules but with an externally mounted volume and more verbose output:\nSee Backups.\nFor Kubernetes setup, the only thing to bear in mind is that Weaviate needs a PersistentVolumes through PersistentVolumeClaim"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page outlines what an ideal bug report would look like. We don't want to discourage you from reporting a bug just because you might not be able to provide all the info needed to make the report great. If a bug report is well-prepared, it has a greater chance of being picked up first."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/more-resources/write-great-bug-reports",
          "webPageMainText": "This page outlines what an ideal bug report would look like. We know that it is\nnot always possible to write a perfect bug report, and we don't want to\ndiscourage you from reporting a bug just because you might not be able to\nprovide all the info needed to make the report great. At the same time we want\nto provide you with the information to make the lives of our engineers a bit\neasier. Sometimes we also need to prioritize and decide about which bug ticket\nto pick up first. If a bug report is well-prepared, it has a greater chance of\nbeing picked up first.\nHere are some points that make a bug report great:\nProviding Context\nWhen you have been working on a specific use-case or fighting against a\nspecific bug for ages there is probably a lot of context in your or your\nteams' head(s). Sometimes this context gets lost when handing over a bug\nreport to one of our engineers. Since they have probably been working on\nsomething completely different before, it may be difficult for them to\nunders"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets. The fusion method and the relative weights are configurable. The search rankings are part of the object metadata. Weaviate uses the score to order the search results. To see the object rankings, set the explain score field in your query."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/hybrid#weight-keyword-vs-vector-results",
          "webPageMainText": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets.\nThe fusion method and the relative weights are configurable.\nCombine the results of a vector search and a keyword search. The search uses a single query string.\nThe output is like this:\nA hybrid search on a collection that has named vectors must specify a target vector. Weaviate uses the query vector to search the target vector space.\nThe output is like this:\nTo see the object rankings, set the explain score field in your query. The search rankings are part of the object metadata. Weaviate uses the score to order the search results.\nThe output is like this:\nHybrid search results can favor the keyword component or the vector component. To change the relative weights of the keyword and vector components, set the alpha value in your query.\nThe output is like this:\nRelative Score Fusion is the default fusion method starting in v1.24.\nThe output is like this:\nFor a discussion of"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page describes how to run Weaviate from source (git checkout / tarball) locally. The default configuration is local-development which will run the server locally with the text2vec-contextionary and backup-filesystem modules. For example, the setup below uses Docker Compose to spin up Prometheus and Grafana instances."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-core/setup",
          "webPageMainText": "This page describes how to run Weaviate from source (git checkout / tarball) locally.\nYou can find the source code at the Weaviate repo.\nPrerequisites:\nThe fastest way to run Weaviate from source is to issue the command below:\nWhere <configuration> is one of the server configuration ($CONFIG) values in /tools/dev/run_dev_server.sh. For example, you can run:\nTo run the server locally with the OpenAI module.\nThe default configuration is local-development which will run the server locally with the text2vec-contextionary and backup-filesystem modules.\nYou can also create your own configuration. For instance, you can clone an entry (local-all-openai-cohere-palm is a good start) and add the required environment variables.\nTo run with Docker, start up the Weaviate container and the container(s) for any additional services with\nthen run the development server as described in the section above.\nFor example, the setup below uses Docker Compose to spin up Prometheus and Grafana instances. Those a"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The gRPC API is faster than the REST API. Use it to improve import speeds. Batch imports are an efficient way to add multiple data objects and cross-references. To create a bulk import job, follow these steps:The following example adds objects to the MyCollection collection."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/import",
          "webPageMainText": "Batch imports are an efficient way to add multiple data objects and cross-references.\nTo create a bulk import job, follow these steps:\nThe following example adds objects to the MyCollection collection.\nThe gRPC API is faster than the REST API. Use the gRPC API to improve import speeds.\nThe Python client uses gRPC by default. See the client page for additional batch import configuration options.\nThe TypeScript client v3 uses gRPC by default.\nTo use the gRPC API with the Java client, add the setGRPCHost field to your client connection code. Update setGRPCSecured if you use an encrypted connection.\nTo use the gRPC API with the Go client, add the GrpcConfig field to your client connection code. Update Secured if you use an encrypted connection.\nTo use the gRPC API with the Spark connector, add the grpc:host field to your client connection code. Update grpc:secured if you use an encrypted connection.\nWeaviate generates an UUID for each object. Object IDs must be unique. If you set object ID"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate provides the necessary APIs to iterate through all your data. This is useful when you want to manually copy/migrate your data (and vector embeddings) from one place to another. The new API clients (currently supported by the Python Client v4), encapsulate this functionality as an Iterator."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/read-all-objects#restore-to-a-target-instance",
          "webPageMainText": "Weaviate provides the necessary APIs to iterate through all your data. This is useful when you want to manually copy/migrate your data (and vector embeddings) from one place to another.\nThis is done with the help of the after operator, also called the cursor API.\nThe new API clients (currently supported by the Python Client v4), encapsulate this functionality as an Iterator.\nThe following code iterates through all objects, providing the properties and id for each object.\nRead through all data including the vectors. (Also applicable where named vectors are used.)\nIterate through all tenants and read data for each.\nFor classes where multi-tenancy is enabled, you need to specify the tenant name when reading or creating objects. See Manage data: multi-tenancy operations for details.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model. To use this module, you must enable it in your Docker Compose file. For production use cases, we recommend using other modules that use a more modern, transformer-based architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-contextionary#how-to-use",
          "webPageMainText": "The text2vec-contextionary module enables Weaviate to obtain vectors locally using a lightweight model.\nKey notes:\nAs a lightweight model, it is well suited for testing purposes.\nFor production use cases, we recommend using other modules that use a more modern, transformer-based architecture.\nThis module is not available on Weaviate Cloud.\nTo use text2vec-contextionary, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nContextionary:\nThis configuration enables text2vec-contextionary, sets it as the default vectorizer, and sets the parameters for the Contextionary Docker container.\nYou can configure how the module will behave in each class through the Weaviate schema.\nYou can set vectorizer behavior using the moduleConfig section under each class and property:\nIf you are using this module and are vectorizing the class or property name, t"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Learn how named vectors can provide a flexible way to represent your data in Weaviate. Learn what happens when text is indexed, and searched, or converted into a vector. Find out how to get the most out of this feature. Learn how to build with Weaviates and multi-modal data."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy",
          "webPageMainText": "We've built these courses to help you build amazing things with Weaviate, faster.\nProject-based learning where you'll learn how to build with Weaviate and any text data. Weaviate generates the vectors for you.\nProject-based learning where you'll learn how to build with Weaviate and your own data and vectors. This version is for those who prefer to use your own vectors built outside of Weaviate.\nProject-based learning where you'll learn how to build with Weaviate and multi-modal data. Weaviate generates the vectors for you.\nLearn how named vectors can provide a flexible way to represent your data in Weaviate.\nVector indexes are the key components for vector search. Learn what they are, and how to use them effectively to suit your needs.\nVectors can be compressed to reduce memory requirements or improve retrieval speeds. Find out how to get the most out of this feature.\nWhat happens when text is indexed, and searched, or converted into a vector? They are 'tokenized'. Learn what this is, "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate Go client is compatible with Go 1.16+. The client doesn't support the old Go modules system. The current Go client version is v4.14.0. The suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviates instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/go",
          "webPageMainText": "The current Go client version is v4.14.0.\nThe Weaviate Go client is compatible with Go 1.16+.\nThe client doesn't support the old Go modules system. Create a repository for your code before you import the Weaviate client.\nCreate a repository:\nTo get the latest stable version of the Go client library, run the following:\nThis example establishes a connection to your Weaviate instance and retrieves the schema.:\nFor more comprehensive information on configuring authentication with Weaviate, refer to the authentication page.\nThe Go client offers multiple options for authenticating against Weaviate, including multiple OIDC authentication flows.\nThe suitable authentication options and methods for the client largely depend on the specific configuration of the Weaviate instance.\nEach Weaviate instance in Weaviate Cloud (WCD) is pre-configured to act as a token issuer for OIDC authentication.\nSee our WCD authentication documentation for instructions on how to authenticate against WCD with your pr"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_collections",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_multimodal_data/setup_weaviate",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Aggregate queries process the result set to return calculated results. Use aggregate queries for groups of objects or the entire result set. To run an Aggregate query, specify the following:A target collection to search. One or more aggregated properties, such as:Select at least one sub-property for each selected property."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/aggregate",
          "webPageMainText": "Aggregate queries process the result set to return calculated results. Use aggregate queries for groups of objects or the entire result set.\nTo run an Aggregate query, specify the following:\nA target collection to search\nOne or more aggregated properties, such as:\nSelect at least one sub-property for each selected property\nFor details, see Aggregate.\nReturn the number  of objects matched by the query.\n  The output is like this:\nThis example counts occurrence frequencies in the question property:\n  The output is like this:\nThis  example sums the points property.\n  The output is like this:\nTo group your results, use groupBy in the query.\nTo retrieve aggregate data for each group, use the groupedBy properties.\n  The output is like this:\nYou can use Aggregate with a similarity search operator (one of the Near operators).\nUse objectLimit to specify the maximum number of objects to aggregate.\n  The output is like this:\nYou can use Aggregate with a similarity search operator (one of the Near "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate can automatically replicate data across nodes in the background in a cluster with multiple server nodes. Database replication improves reliability, scalability, and/or performance. The user can control trade-offs between consistency and availability through tunable consistency. Weaviate adopts two different replication architectures for schema consistency and data consistency."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/replication-architecture",
          "webPageMainText": "Weaviate can automatically replicate data across nodes in the background in a cluster with multiple server nodes. This enables a variety of use cases. For example, if a node goes down, another node can shoulder the load without loss of availability or data. Database replication improves reliability, scalability, and/or performance.\nThe user can control trade-offs between consistency and availability through tunable consistency.\nWeaviate adopts two different replication architectures for schema consistency and data consistency.\nNote that regardless of whether data is replicated, the schema is always replicated across all nodes.\nIn this Replication Architecture section, you will find information about:\n\nDatabase replication refers to keeping a copy of the same data point on multiple nodes of a cluster, which in turn creates a distributed database. A distributed database consists of multiple nodes, all of which can contain a copy of the data. So if one node (server) goes down, users can s"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.25 is released! Updates include named vectors, server telemetry, backend improvements, performance enhancements. The new (v4) release of the Weaviate Python Client is faster (gRPC), provides better IDE support and more type-safety, and many other developer experience improvements."
              }
            ]
          },
          "url": "https://weaviate.io/blog/tags/release",
          "webPageMainText": "We're pleased to share that the Weaviate v3 TypeScript client is now stable!\nWeaviate 1.25 is released! Updates include ...\nA beta release of our new TypeScript client is now available! Help us make it better by trying it out and providing your feedback.\nWeaviate 1.24 is released! Updates include named vectors, server telemetry, backend improvements, performance enhancements.\nThe new (v4) release of the Weaviate Python Client is - faster (gRPC), provides better IDE support and more type-safety, and many other developer experience improvements. Check out the new release and let us know what you think!\nWeaviate 1.23 released with AutoPQ, flat indexing + Binary Quantization, OSS LLM support through Anyscale, and more!\nWeaviate 1.22 released with nest object storage, async indexing, further gRPC support, and more!\nA preview release of our new Python client is now available! Help us make it better by trying it out and providing your feedback.\nWeaviate 1.21 released with new operators, perfo"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate has a RESTful API and a GraphQL API. The client libraries in all languages support all API functions. Some clients, e.g. the Python client, have additional functionality, such as full schema management and batching operations. Weaviate should be easy to understand, intuitive to use and valuable."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/interface",
          "webPageMainText": "You can manage and use Weaviate through its APIs. Weaviate has a RESTful API and a GraphQL API. The client libraries in all languages support all API functions. Some clients, e.g. the Python client, have additional functionality, such as full schema management and batching operations. This way, Weaviate is easy to use in custom projects. Additionally, the APIs are intuitive, so it is easy to integrate into your existing data landscape.\nThis page contains information on how Weaviate's APIs are designed, and how you can use Weaviate Console to search through your Weaviate instance with GraphQL.\nUser Experience (UX) is one of our most valuable principles. Weaviate should be easy to understand, intuitive to use and valuable, desirable and usable to the community. The interaction with Weaviate is naturally very important for its UX. Weaviate's APIs are designed from the perspective of user needs, keeping the software features in mind. We do user research, user testing and prototyping to mak"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "With Weaviate you can query your data using vector similarity search, keyword search, or a mix of both with hybrid search. You can control what object properties and metadata to return. This page provides fundamental search syntax to get you started.You can get objects without specifying any parameters. This returns objects ordered by their UUID."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/basics#retrieve-cross-referenced-properties",
          "webPageMainText": "With Weaviate you can query your data using vector similarity search, keyword search, or a mix of both with hybrid search. You can control what object properties and metadata to return.\nThis page provides fundamental search syntax to get you started.\nYou can get objects without specifying any parameters. This returns objects ordered by their UUID.\nThe output is like this:\n  Specify the information that you want your query to return. You can return object properties, object IDs, and object metadata.\nUse limit to set a fixed maximum number of objects to return.\nThe output is like this:\nTo start in the middle of your result set, define an offset. Set a limit to return objects starting at the offset.\nThe output is like this:\nTo paginate through the entire database, use a cursor instead of offset and limit.\nYou can specify which object properties to return.\nThe output is like this:\nYou can retrieve the object vector. (Also applicable where named vectors are used.)\nThe output is like this:\nY"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " vector search is the most robust and versatile search type. It is well-suited for situations where the meaning, or the vector representation, is of the highest importance. Keyword search is useful when there is an expectation or requirement to match the exact search terms. This can be the case for specific domains such as legal, medical or technical areas where the exact terminology is important."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/which_search/selection",
          "webPageMainText": "Selecting the right search type is key for effective search tasks. Let's explore how to select the right search type for your needs.\nVector search is the most robust and versatile search type. As such, it is well-suited for situations where the the meaning, or the vector representation, is of the highest importance.\nIn cross-modal, object-based or multi-lingual searches, vector search may be the only viable option.\nStart with vector search for:\nKeyword search is useful when there is an expectation or requirement to match the exact search terms. This can be the case for specific domains such as legal, medical or technical areas where the exact terminology is important.\nKeyword search is also useful when the user is unlikely to make mistakes in inputs and is inputting a predictable set of terms, such as through a sanitized form or a drop-down menu.\nIn summary, start with keyword search for:\nExact term matching: Ideal in domains like legal, medical, or technical fields where specific term"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This section shows you how to configure Weaviate to suit your specific needs. You do not need to read this section linearly. But we do recommend that you browse through this section so that you are aware of the available main customization options, including features that will help you to take it into production. For example, you can read about how to:"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration",
          "webPageMainText": "This section shows you how to configure Weaviate to suit your specific needs.\nFor example, you can read about how to:\nYou do not need to read this section linearly. But we do recommend that you browse through this section so that you are aware of the available main customization options, including features that will help you to take it into production.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate v1.15 introduced a backup feature that streamlines the backup process. This tutorial will show you how to use this feature to back up your data and restore it to another Weaviate instance. By the end of this tutorial, you will have:"
              }
            ]
          },
          "url": "https://weaviate.io/blog/tutorial-backup-and-restore-in-weaviate",
          "webPageMainText": "\nMaintaining data integrity is one of the key goals for database users. So it should come as no surprise that backing up the data is an important part of database best practices.\nAlthough it has always been possible to back up Weaviate data, doing so used to require many manual and inelegant steps. So, we have introduced a backup feature in Weaviate v1.15 that streamlines the backup process, whether it be to a local file system or to a cloud storage provider.\nIf you have not yet had a chance to use this cool feature, don't worry! This tutorial will show you how to use this feature to back up your data and restore it to another Weaviate instance.\nBy the end of this tutorial, you will have:\nTo get started, clone github.com/weaviate-tutorials/weaviate-backup repository and spin up Weaviate:\nThe Docker Compose file (docker-compose.yml) has been set up to spin up two Weaviate instances for this tutorial. You should be able to connect to them at http://localhost:8080 and http://localhost:809"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": ". If you have any questions or feedback, let us know in the user forum. Back to Mail Online home. back to the page you came from.  Back to the site you came From.  The Daily Mail home. Back To the Daily Mail Home."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_rag",
          "webPageMainText": "If you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "ChatPDF and ChatDOC can be used to chat with your PDFs. PDFs contain valuable insights and information that are key to unlocking text information. With the latest advancements in multimodal deep learning, it is now possible to extract high quality data from PDF documents and add it to your Weaviate workflow."
              }
            ]
          },
          "url": "https://weaviate.io/blog/ingesting-pdfs-into-weaviate",
          "webPageMainText": "\nSince the release of ChatGPT, and the subsequent realization of pairing Vector DBs with ChatGPT, one of the most compelling applications has been chatting with your PDFs (i.e. ChatPDF or ChatDOC). Why PDFs? PDFs are fairly universal for visual documents, encompassing research papers, resumes, powerpoints, letters, and many more. In our latest Weaviate Podcast with Unstructured Founder Brian Raymond, Brian motivates this kind of data by saying \u201cImagine you have a non-disclosure agreement in a PDF and want to train a classifier\u201d. Although PDFs are great for human understanding, they have been very hard to process with computers. PDF documents contain valuable insights and information that are key to unlocking text information for businesses. With the latest advancements in multimodal deep learning (models that process both images and text), it is now possible to extract high quality data from PDF documents and add it to your Weaviate workflow.\nOptical Character Recognition (OCR) describ"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is a persistent and fault-tolerant database. This page gives you an overview of how objects and vectors are stored within Weaviate and how an inverted index is created at import time. Each class in Weaviates user-defined schema leads to the creation of an index internally. An index is a wrapper type comprised of one or many shards."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/storage#hnsw-vector-index-storage",
          "webPageMainText": "Weaviate is a persistent and fault-tolerant database. This page gives you an overview of how objects and vectors are stored within Weaviate and how an inverted index is created at import time.\nThe components mentioned on this page aid Weaviate in creating some of its unique features:\nEach class in Weaviate's user-defined schema leads to the creation of an index internally. An index is a wrapper type that is comprised of one or many shards. Shards within an index are self-contained storage units. Multiple shards can be used to distribute the load among multiple server nodes automatically.\nEach shard houses three main components:\nWeaviate doesn't rely on any third-party databases. The three components of a shard are all housed within Weaviate. This means that there are no runtime dependencies to other services and all components will scale equally with Weaviate.\nSince version v1.5.0, the object and inverted store are implemented using an LSM-Tree approach. This means that data can be ing"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Large language models (LLMs) like GPT-4 have impressive capabilities in generation and reasoning. But they have limitations in terms of their ability to access and retrieve specific facts, figures, or contextually relevant information. A popular solution to this problem is setting up a retrieval-augmented generation (RAG) system."
              }
            ]
          },
          "url": "https://weaviate.io/blog/llamaindex-and-weaviate",
          "webPageMainText": "\nWhile large language models (LLMs) like GPT-4 have impressive capabilities in generation and reasoning, they have limitations in terms of their ability to access and retrieve specific facts, figures, or contextually relevant information. A popular solution to this problem is setting up a retrieval-augmented generation (RAG) system: combine the language model with an external storage provider, and create an overall software system that can orchestrate the interactions with and between these components in order to create a \u201cchat with your data\u201d experience.\nThe combination of Weaviate and LlamaIndex provide the critical components needed to easily setup a powerful and reliable RAG stack, so that you can easily deliver powerful LLM-enabled experiences over your data, such as search engines, chatbots, and more. First, we can use Weaviate as the vector database that acts as the external storage provider. Next, we can use a powerful data framework such as LlamaIndex to help with data managem"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Replication is disabled by default and can be enabled per data class in the collection configuration. Weaviate instances can be replicated to increase availability and read throughput, and to enable zero-downtime upgrades. To enable replication on a class, the replication factor has to be set, which looks like the following."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/replication",
          "webPageMainText": "Weaviate instances can be replicated to increase availability and read throughput, and to enable zero-downtime upgrades. On this page, you will learn how to set replication for your Weaviate instance.\nFor more about how replication is designed and built in Weaviate, see the Replication Architecture pages.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nReplication is disabled by default and can be enabled per data class in the collection configuration. This means you can set different replication factors per class in your dataset. To enable replication on a class, the replication factor has to be set, which looks like the following:\nHere's an example for all clients:\nWhen you set this replication factor in the data schema before you add data, you will have 3 replicas of the data stored. Weaviate can also handle changing this setting after you imported the d"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The live endpoint checks if the application is alive. You can use it for a Kubernetes liveness probe. Various cluster statuses are available in Weaviate. The v1//schema/cluster-status endpoint displays the status of the schema synchronization."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/status",
          "webPageMainText": "Various cluster statuses are available in Weaviate.\nThe live endpoint checks if the application is alive. You can use it for a Kubernetes liveness probe.\nThe endpoint accepts a GET request:\nThe endpoint returns HTTP status code 200 if the application is able to respond to HTTP requests.\nThe endpoint returns HTTP status code 200 if the application is able to respond to HTTP requests.\nThe ready endpoint checks if the application is ready to receive traffic. You can use it for Kubernetes readiness probe.\nThe discovery endpoint accepts a GET request:\nThe endpoint returns HTTP status code 200 if the application is able to respond to HTTP requests. If the application is currently unable to serve traffic, the endpoint returns HTTP status code 503.\nIf the application is unavailable and you have horizontal replicas of Weaviate that can receive traffic, redirect traffic to one of the replicas.\nThe v1//schema/cluster-status endpoint displays the status of the schema synchronization. The endpoint "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is an open-source, free-to-use database. It can be used to search large sets of data. This post explains how to use Weaviate to search the data in a large database. We also show you how to import the data into Weaviates."
              }
            ]
          },
          "url": "https://weaviate.io/blog/details-behind-the-sphere-dataset-in-weaviate",
          "webPageMainText": "\nEarlier in December, we wrote a blog post about importing the Sphere dataset into Weaviate. In that post, we talked about what the Sphere dataset is, announced the release of the Sphere dataset files for Weaviate, and shared how you can use Weaviate to search through large datasets like Sphere. More specifically, we provided a short guide on how you could import Sphere into Weaviate using Python as well as Spark, before finishing with example queries on the entire Sphere dataset. If you haven\u2019t checked that out we recommend you have a quick look!\nIn this post, we will pull back the curtains and go behind the scenes to show you how we got all of that data into Weaviate. You will see all the gory details of what it took to get all ~1 billion (898 million) article snippet objects from Sphere and their vector representations into Weaviate. We\u2019ll also dive into the hardware and software setup that was used along with the performance metrics behind the import process.\nIf you are:\nThis artic"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page describes the code-level architecture of media2vec. The module architecture is dependent on the respective module. A module is essentially any struct that implements a specific Golang interface. The main interface is a really small one - a module essentially only has to provide a Name() string and Init(...) error method."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-modules/architecture#module-capabilities-additionalgo",
          "webPageMainText": "This page describes the code-level architecture. The high-level architecture\ndepends on the respective module. For example, media2vec modules typically\nuse a microservice pattern to offload model inference into a separate\ncontainer, see this example for the text2vec-transformers high-level\narchitecture.\nA module is essentially any struct that implements a specific Golang interface.\nTo keep module development comfortable, we have decided that the main interface\nis a really small one. A module essentially only has to provide a Name()\nstring and Init(...) error method.\nIf your struct implements this small\ninterface\nit is already a valid Weaviate Module.\nAlthough a valid module, the above example provides little value to the user -\nit can't do anything. We cannot predict which capability a module will provide\nand don't want to force every module developer to implement hundreds of methods -\nonly to have 95 of them return \"not implemented\".\nThus, we have decided to make each capability a sma"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " Vector search returns the objects with most similar vectors to that of the query. To search a collection that has named vectors, use the target vector field to specify which named vector to search. To set a similarity threshold between the search and target vectors, define a maximum distance (or certainty)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/similarity#search-with-text",
          "webPageMainText": "Vector search returns the objects with most similar vectors to that of the query.\nTo search a collection that has named vectors, use the target vector field to specify which named vector to search.\nThe output is like this:\nUse the Near Text operator to find objects with the nearest vector to an input text.\nThe output is like this:\nUse the Near Image operator to find objects with the nearest vector to an image.\nThis example uses a base64 representation of an image.\nSee Image search for more information.\nIf you have an object ID, use the Near Object operator to find similar objects to that object.\nIf you have an input vector, use the Near Vector operator to find objects with similar vectors\nTo set a similarity threshold between the search and target vectors, define a maximum distance (or certainty).\nUse limit to set a fixed maximum number of objects to return.\nOptionally, use offset to paginate the results.\nTo limit results to groups of similar distances to the query, use the autocut fil"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative search is a multi-stage process. First Weaviate performs a query, then it passes the retrieved results and a prompt to a large language model (LLM), to generate a new output.Configure the target collection to use the generator module. Define object properties to interpolate retrieved content in the prompt."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/generative",
          "webPageMainText": "Generative search, also known as \"Retrieval Augmented Generation\" (RAG), is a multi-stage process.\nFirst Weaviate performs a query, then it passes the retrieved results and a prompt to a large language model (LLM), to generate a new output.\nConfigure Weaviate to use a generator module. For details, see the module reference page:\nConfigure the target collection to use the generator module. For details, see schema configuration on the module reference page.\nQuery your database to retrieve one or more objects.\nUse the query results to generate a new result.\nAny vector-based search on collections with named vectors configured must include a target vector name in the query. This allows Weaviate to find the correct vector to compare with the query vector.\nSingle prompt search returns a generated response for each object in the query results.\nDefine object properties \u2013 using {prop-name} syntax \u2013 to interpolate retrieved content in the prompt.\nThe properties you use in the prompt do not have t"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/contributor-guide/weaviate-modules",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Filters can be used to precisely refine search results. You can filter by properties as well as metadata, and you can combine multiple filters with and or or conditions to further narrow down the results. This example finds entries in \"Movie\" based on their similarity to the query \"dystopian future\", only from those released after 2020."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_searches/filters",
          "webPageMainText": "Filters can be used to precisely refine search results. You can filter by properties as well as metadata, and you can combine multiple filters with and or or conditions to further narrow down the results.\nThis example finds entries in \"Movie\" based on their similarity to the query \"dystopian future\", only from those released after 2020. It prints out the title and release year of the top 5 matches.\nThis query is identical to that shown earlier for semantic search, but with the addition of a filter. The filters parameter here takes an instance of the Filter class to set the filter conditions. The current query filters the results to only include those with a release year after 2010.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Concepts section explains various aspects related to Weaviate and its architecture. You can read these sections in any order. If you are after a practical guide, try the quickstart tutorial. The figure below gives a 30,000 feet view of Weaviates architecture."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts#weaviate-architecture",
          "webPageMainText": "The Concepts section explains various aspects related to Weaviate and its architecture to help you get the most out of it. You can read these sections in any order.\nIf you are after a practical guide, try the quickstart tutorial.\nData structure\nModules\nIndexing\nVector indexing\nVector quantization\nThe figure below gives a 30,000 feet view of Weaviate's architecture.\n\nYou can learn more about the individual components in this figure by following these guides:\nLearn about storage inside a shard\nWays to scale Weaviate horizontally\nHow to plan resources\nFiltered vector search\nUser-facing interfaces\nReplication architecture\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "1.21 adds ContainsAny and ContainsAll operators to make your filters sweeter than ever. You can use these to reduce complex chains of And or Or where filters to simple, digestible, queries that are easier on your eye and your brain. This is one of our most-requested features, and we are very excited for you to try it out."
              }
            ]
          },
          "url": "https://weaviate.io/blog/weaviate-1-21-release",
          "webPageMainText": "\nWeaviate 1.21 is here!\nHere are the \u2b50\ufe0fhighlights\u2b50\ufe0f relating to this release:\n1.21 is already available on Weaviate Cloud - so try it out!\nFor more details, keep scrolling \u2b07\ufe0f!\n\nYou asked for it - and it\u2019s here! 1.21 adds ContainsAny and ContainsAll operators to make your filters (syntactically) sweeter than ever.\nYou can use these to reduce complex chains of And or Or where filters to simple, digestible, queries that are easier on your eye and your brain.\nThese operators allow you to filter an array property, using a query array.\nContainsAny will find all objects whose property contains one or more (i.e. any) of the query values. In other words - a series of Or statements.\nContainsAll, on the other hand, will find all objects whose property contains every single one (i.e. all) of the query values. This can replace a series of And statements.\nThis is one of our most-requested features, and we are very excited for you to try it out.\nConsider a dataset of people (class Person), where each"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Generative Feedback Loops take results generated from language models, vectorize them, and save them back into the database. This interaction between the models and dataset enables smarter automation of tasks like data cleaning and content creation. Use data produced by generative models to enhance user experiences and automate manual tasks."
              }
            ]
          },
          "url": "https://weaviate.io/gen-feedback-loops",
          "webPageMainText": "Use data produced by generative models to enhance user experiences and automate manual tasks.\nWhile vector search and RAG are popular AI use cases that many of our customers are moving to production with, we\u2019re looking ahead to what\u2019s next. Generative Feedback Loops take results generated from language models, vectorize them, and save them back\u00a0into the database. This interaction between the models and dataset enables smarter automation of tasks like data cleaning and content creation.\nCreate trustworthy feedback loops using Weaviate-powered vector search and RAG.\nAutomate the cleaning and organizing of existing data, such as adding tags or labels.\nPersonalize insights and deliver better AI-generated content, faster.\nLearn how to enhance blog posts, from creating new content to editing and analyzing existing material with Generative Feedback Loops.\nDSPy + Weaviate for the Next Generation of LLM Apps\nGenerative Feedback Loops with LLMs for Vector Databases\nWeaviate Podcast Search meets "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate runs on a single node in a Kubernetes cluster with Minikube. To scale it up to a multi-node setup, we need a cluster with multiple nodes. Then, we can configure Weaviate to make use of these nodes. We'll delete the current one and start a new one for simplicity."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/deployment/k8s/multi_node",
          "webPageMainText": "Recall that we have deployed Weaviate on a single node in our Kubernetes cluster with Minikube. Now, let's scale it up to a multi-node setup.\nTo do this, we will need a Kubernetes cluster with multiple nodes. Then, we can configure Weaviate to make use of these nodes.\nWe'll stop the current Weaviate deployment and then deploy a new one with multiple nodes with Minikube.\nKeep in mind that this runs multiple containers on the same host device for learning. In a production environment, you would typically have a managed Kubernetes cluster with multiple, isolated, physical or virtual nodes.\nFirst, stop the tunnel by pressing Ctrl+C at the terminal where you ran minikube tunnel.\nThen, stop Minikube:\nSince the minikube cluster exists, we will have to delete it before we can start a new one with multiple nodes:\nYou can also add nodes to an existing Minikube cluster. But we'll delete the current one and start a new one for simplicity.\nTo start a multi-node Kubernetes cluster with Minikube, run"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue. Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/filters#pagination-with-offset",
          "webPageMainText": "Conditional filters may be added to queries such as Object-level and Aggregate queries, as well as batch deletion. The operator used for filtering is also called a where filter.\nA filter may consist of one or more conditions, which are combined using the And or Or operators. Each condition consists of a property path, an operator, and a value.\nEach set of algebraic conditions is called an \"operand\". For each operand, the required properties are:\nFor example, this filter will only allow objects from the class Article with a wordCount that is GreaterThan than 1000.\nThe where filter is an algebraic object, which takes the following arguments:\nIf the operator is And or Or, the operands are a list of where filters.\nWeaviate doesn't have an operator to invert a filter (e.g. Not Like ... ). If you would like us to add one, please upvote the issue.\nThe behavior for the Equal operator on multi-word textual properties in where filters depends on the tokenization of the property.\nSee the Schema p"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The examples on this page demonstrate how to create individual objects in Weaviate. To create an object, specify the following:By default, auto-schema creates new collections and adds new properties. The same value always generates the same ID. Use deterministic IDs to avoid inserting duplicate objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/create#create-an-object-with-named-vectors",
          "webPageMainText": "The examples on this page demonstrate how to create individual objects in Weaviate.\nThis example creates an object in the JeopardyQuestion collection.\nTo create an object, specify the following:\nBy default, auto-schema creates new collections and adds new properties.\nWhen you create an object, you can provide a vector. (For specifying multiple, named vectors, see below.)\nWhen you create an object, you can specify named vectors (if configured in your collection).\nWhen you create an object, you can specify an ID.\nIf no ID is provided, Weaviate will generate a random UUID.\nYou can generate an ID based on your data object.\nObject IDs are not randomly generated. The same value always generates the same ID.Weaviate throws an error if you provide a duplicate ID. Use deterministic IDs to avoid inserting duplicate objects.\nYou can create an object with cross-references to other objects.\nSee How-to: Cross-references for more on working with cross-references.\nCurrently, geo-coordinate filtering i"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's vector-first storage system takes care of all storage operations with a vector index. The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold. Weavia supports two types of vector indexing:Available starting in v1.25."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/concepts/vector-index#dynamic-ef",
          "webPageMainText": "Vector indexing is a key component of vector databases. It can help to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indices).\nWeaviate supports two types of vector indexing:\nAvailable starting in v1.25. This is an experimental feature, use with caution.\nThis page explains what vector indices are, and what purpose they serve in the Weavia"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) provides two instance types. To create a cluster, click the 'Create cluster' button on the WCD Dashboard page. By default, API keys are enabled for all WCD clusters. Serverless clusters have an administrator key and a read-only key. Sandbox clusters only have a administrator key."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs/create-instance",
          "webPageMainText": "Weaviate Cloud (WCD) provides two instance types.\nTo create a cluster, click the 'Create cluster' button on the WCD Dashboard page.\n\nFollow the steps to create a cluster:\nTo create a sandbox cluster, follow these steps:\nIt takes a minute or two to create the new cluster. When the cluster is ready, WCD displays a check mark (\u2714\ufe0f) next to the cluster name.\nServerless clusters require billing details. WCD prompts you to add billing details if you have not already added them.\nTo create a serverless cluster, follow these steps:\nIt takes a minute or two to create the new cluster. When the cluster is ready, WCD displays a check mark (\u2714\ufe0f) next to the cluster name.\nBy default, API keys are enabled for all WCD clusters. Serverless clusters have an administrator key and a read-only key. Sandbox clusters only have an administrator key.\nWhen you develop your client application, use an API key to connect your client to the cluster. For more details, see authentication.\nTo get API keys, click the API "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Instabase leverages AI to streamline operations and enhance efficiency across various industries, including banking, insurance, and ride-sharing platforms like Uber. Instabase strategically uses GenAI to transform unstructured data into actionable insights. It\u2019s not just a prototype, but a core part of their platform in production."
              }
            ]
          },
          "url": "https://weaviate.io/blog/instabase-and-weaviate",
          "webPageMainText": "\nIn March we hosted our first-ever roadshow in San Francisco, inviting tech leaders who use Weaviate to share their experiences of building AI applications in production. Our CTO, Etienne, sat down with Shaunak Godbole, Head of Infrastructure Engineering at Instabase, to discuss the latest developments in intelligent document processing and automation technologies. \nInstabase leverages AI to streamline operations and enhance efficiency across various industries, including banking, insurance, and ride-sharing platforms like Uber. The discussion highlighted Instabase\u2019s innovative approaches to handling complex data challenges and their strategic implementation of technologies like Weaviate to stay ahead in a highly competitive and evolving landscape.\nGenerative AI can solve highly complex problems: Instabase strategically uses GenAI to transform unstructured data into actionable insights. It\u2019s not just a prototype, but a core part of their platform in production, already benefiting large"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate (we-vee-eight) is an open source, AI-native vector database. Just bring your text data to Weaviate and it will do the rest. Multiple deployment options are available to cater for different users and use cases. All options offer vectorizer and RAG module integration."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate",
          "webPageMainText": "Weaviate (we-vee-eight) is an open source, AI-native vector database. Use this documentation to get started with Weaviate and to learn how to get the most out of Weaviate's features.\nStart with the Quickstart tutorial - an end-to-end demo that takes 15-30 minutes.\nPlease visit our forum. The Weaviate team and our awesome community can help.\nGetting Started\nMultiple deployment options are available to cater for different users and use cases. All options offer vectorizer and RAG module integration.\nChoose your next step. Weaviate is flexible and can be used in many contexts and scenarios.\nJust bring your text data to Weaviate and it will do the rest.\nJust populate Weaviate with your text data and start using powerful vector, keyword and hybrid search capabilities.\nAnd use our integrations to build generative ai tools with your data.\nDo you prefer to work with your own vectors? No problem.\nYou can add your own vectors to Weaviate and still benefit from all of its indexing and search capab"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Researchers at MicrosoftAI propose \"unlearning\" or \"un-training\" as a three-step process. First they finetune a model to always respond with some reference to the information they want to later erase. This \"reinforced model\" becomes a specialist in the information we eventually want to unlearn. This step is used to identify which tokens should be targeted in the unlearning step."
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper7",
          "webPageMainText": "\nSure, you can train a LLM, perhaps you can even finetune one! But can you brainwash one into forgetting specific concepts?\ud83e\udde0\nHow would you erase a concept from a LLM's parametric memory?\nThis question was addressed by researchers at MicrosoftAI in their new paper(https://arxiv.org/abs/2310.02238) where they \"propose a novel technique for unlearning a subset of the training data from a LLM\" without adversely impacting performance on other benchmarks.\nThey propose \"unlearning\" or \"un-training\" as a three-step process:\nFirst they finetune a model to always respond with some reference to the information they want to later erase. This \"reinforced model\" becomes a specialist in the information we eventually want to unlearn. This step is used to identify which tokens should be targeted in the unlearning step!\nFor each of these unlearning targets identified in step 1 they generate synthetic generic alternatives using GPT4. So for example a sentence that originally says \"Harry went to the Gryff"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You have completed this course on compression. We hope you found it helpful and informative. There are many more resources available to help you continue your learning journey. Keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn)"
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/compression/next_steps",
          "webPageMainText": "Congratulations! You have completed this course on compression. We hope you found it helpful and informative.\nThere are many more resources available to help you continue your learning journey.\nWe are constantly improving our documentation, so please keep an eye out for new resources and updates, by signing up for our newsletter or following us on social media (Twitter, LinkedIn).\nSee you soon! \ud83d\udc4b\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#3-enable-pq-and-create-the-codebook",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers object-level query functions. They are collectively referred to as Get queries within. A Get query requires the target collection to be specified. Metadata retrieval is optional in both GraphQL and gRPC calls. You can use retrieve groups of objects that match the query. The number of groups and objects per group can be limited."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/get",
          "webPageMainText": "This page covers object-level query functions. They are collectively referred to as Get queries within.\nA Get query requires the target collection to be specified.\nIn GraphQL calls, the properties to be retrieved to be must be specified explicitly.\nIn gRPC calls, all properties are fetched by default.\nMetadata retrieval is optional in both GraphQL and gRPC calls.\nEach Get query can include any of the following types of arguments:\nThe above query will result in something like the following:\nWithout any arguments, the objects are retrieved according to their ID.\nAccordingly, such a Get query is not suitable for a substantive object retrieval strategy. Consider the Cursor API for that purpose.\nYou can use retrieve groups of objects that match the query.\nThe groups are defined by a property, and the number of groups and objects per group can be limited.\n  The other clients do not yet natively support groupby operations. Please use \"raw\" graphql queries to perform groupby operations.\nWhere "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Pagination is not a cursor-based implementation. This has the following implications: The autocut function limits results based on discontinuities in the result set. The query stops returning results after the specified number of jumps. The Get and Explore functions support offset. For more details, see performance considerations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-operators#limit-argument",
          "webPageMainText": "Functions such as limit, autocut, and sort modify queries at the class level.\nThe limit argument restricts the number of results. These functions support limit:\nTo return sets of results, \"pages\", use offset and limit together to specify a sub-set of the query response.\nFor example, to list the first ten results, set limit: 10 and offset: 0. To display the next ten results, set offset: 10. To continue iterating over the results, increase the offset again. For more details, see performance considerations\nThe Get and Explore functions support offset.\nPagination is not a cursor-based implementation. This has the following implications:\nThe autocut function limits results based on discontinuities in the result set. Specifically, autocut looks for discontinuities, or jumps, in result metrics such as vector distance or search score.\nTo use autocut, specify how many jumps there should be in your query. The query stops returning results after the specified number of jumps.\nFor example, conside"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#error-handling",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate allows object deletion by id or by a set of criteria. To delete objects, you must provide the collection name as well as identifying criteria (e.g. object id or filters) For multi-tenancy collections, you will also need to specify the tenant name when deleting objects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/manage-data/delete#delete-multiple-objects",
          "webPageMainText": "Weaviate allows object deletion by id or by a set of criteria.\nTo delete objects, you must provide the collection name as well as identifying criteria (e.g. object id or filters).\nFor multi-tenancy collections, you will also need to specify the tenant name when deleting objects. See Manage data: multi-tenancy operations for details on how.\nCollections act like namespaces, so two different collections could have duplicate IDs between them.\n\n\nPrior to Weaviate v1.14 you can manipulate objects without specifying the collection name. This method is deprecated. It will be removed in Weaviate v2.0.0.\nStarting in v1.20, you can have multi-tenant datasets. When multi-tenancy is enabled, the tenant name is required.\nAlways include the collection name, and, when enabled, the tenant name.\nTo delete by id, specify the collection name and the object id.\nTo delete objects that match a set of criteria, specify the collection and a where filter.\nThe ContainsAny / ContainsAll filters allow deletion of "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Chunking is an important concept in the world of vector databases and language models. The Lord of the Rings, for example, is over 500,000 words long. Chunking splits texts like these into smaller pieces of texts, i.e. \"chunks\", before storing them in a vector database."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/standalone/chunking",
          "webPageMainText": "This is a preview version of this unit.\nSo some sections are not yet complete - such as videos and quiz questions.\nPlease check back later for the full version, and in the meantime, feel free to provide any feedback through the comments below.\nChunking is an important concept in the world of vector databases and language models. Although we've looked at relatively small pieces of text in previous units, real-world text data can be much longer.\nThink about lengths of articles, transcripts, or even books. Instead of a few words, these texts can be thousands, or tens of thousands of words long if not longer. The Lord of the Rings, for example, is over 500,000 words long!\nChunking splits texts like these into smaller pieces of texts, i.e. \"chunks\", before storing them in a vector database, or passing them to a language model.\nThis can seem relatively innocuous at first, like deciding where to split a sentence or a paragraph into two. But chunking decisions can significantly impact the sear"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is available as a hosted service, Weaviate Cloud (WCD), or as a self managed instance. If you manage your own instance, you can host it locally or with a cloud provider. Self-managed instances use the same Weaviates core database as WCD."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation#installation-methods",
          "webPageMainText": "Weaviate is available as a hosted service, Weaviate Cloud (WCD), or as a self managed instance. If you manage your own instance, you can host it locally or with a cloud provider. Self-managed instances use the same Weaviate core database as WCD.\nTo install and configure Weaviate, see the following:\nDocker Compose and Kubernetes use yaml files to configure Weaviate instances. Docker uses the docker-compose.yml file. Kubernetes relies on Helm charts and the values.yaml file. The Weaviate documentation also calls these files configuration yaml files.\nIf you are self-hosting, consider experimenting on a small scale with Docker and then transferring your configuration to Kubernetes Helm charts when you are more familiar with Weaviate.\nDISCLAIMER: Release candidate images and other unreleased software are not supported.\nUnreleased software and images may contain bugs. APIs may change. Features under development may be withdrawn or modified. Do not use unreleased software in production.\nTo ru"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Mistral offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with Mistral's APIs. These integrations empower developers to build sophisticated AI-driven applications. The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/model-providers/mistral",
          "webPageMainText": "The model provider integration pages are new and still undergoing improvements. We appreciate any feedback on this forum thread.\nMistral offers a wide range of models for natural language processing and generation. Weaviate seamlessly integrates with Mistral's APIs, allowing users to leverage Mistral's models directly within the Weaviate database.\nThese integrations empower developers to build sophisticated AI-driven applications with ease.\n\nMistral's generative AI models can generate human-like text based on given prompts and contexts.\nWeaviate's generative AI integration enables users to perform retrieval augmented generation (RAG) directly within the Weaviate database. This combines Weaviate's efficient storage and fast retrieval capabilities with Mistral's generative AI models to generate personalized and context-aware responses.\nMistral generative AI integration page\nThese integrations enable developers to leverage Mistral's powerful models directly within Weaviate.\nIn turn, they "
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/schema",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": " vector databases have been around for a few years, but they\u2019ve just recently drawn the wider developer community\u2019s attention. This article will walk through what vector databases are and explain some of their core concepts, such as vector embeddings and vector search. We will dive into the technical details of how distance metrics are used in vector search and how vector indexes enable efficient retrieval."
              }
            ]
          },
          "url": "https://weaviate.io/blog/what-is-a-vector-database",
          "webPageMainText": "\nIf you have just recently heard the term \u201cvector database\u201d for the first time, you are not alone. Although vector databases have been around for a few years, they\u2019ve just recently drawn the wider developer community\u2019s attention.\nThe excitement around vector databases is closely related to the release of ChatGPT. Since late 2022, the public has started to understand the capabilities of state-of-the-art large language models (LLMs), while developers have realized that vector databases can enhance these models further.\nThis article will walk through what vector databases are and explain some of their core concepts, such as vector embeddings and vector search. Then, we will dive into the technical details of how distance metrics are used in vector search and how vector indexes enable efficient retrieval. Once we have a fundamental understanding of vector databases, we will discuss their use cases and the current tool landscape.\nA vector database indexes, stores, and provides access to str"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Python and TypeScript client libraries support running Weaviate embedded on Linux, and starting with versions 3.21.0 and 1.2.0 respectively. Oh, and all your data stays private locally, and we don't charge you anything. We're also going to build a useful example, illustrating a testing scenario."
              }
            ]
          },
          "url": "https://weaviate.io/blog/embedded-local-weaviate",
          "webPageMainText": "Yes, 10 Python lines of code, generously formatted with whitespace. Or 14 for TypeScript. Oh, and all your data stays private locally, and we don't charge you anything. We're also going to build a useful example, illustrating a testing scenario. Here's how.\nThe Python and TypeScript client libraries support running Weaviate embedded on Linux, and starting with versions 3.21.0 and 1.2.0 respectively, on macOS as well.\n  Save as embedded.py and run python embedded.py:\n  Save as embedded.ts and run node --loader=ts-node/esm embedded.ts:\nEssentially, what happens behind the scenes is that the client library downloads the server binary, spawns it in a separate process, connects to it, then terminates it on exit. The data is persisted, so you can use it from future invocations, or you can transfer it to another instance.\nYou can learn more about running Weaviate locally from client code on the Embedded Weaviate page.\nWhat can you do with Embedded Weaviate? Quite a few things!\nFirst off, you "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Researchers from Microsoft asked if unsupervised next token prediction finetuning is better than RAG to improve LLM perf. on both seen and unseen QnA tasks. RAG is a better way to inject knowledge into LLMs than unsuper supervised fine-tuning(USFT)"
              }
            ]
          },
          "url": "https://weaviate.io/papers/paper11",
          "webPageMainText": "\n\u2753When using LLMs is unsupervised fine-tuning better than RAG for knowledge-intensive tasks? Should you do both?\nIf you want to augment an LLM with knowledge of your enterprise data you can do so by augmenting the parametric (finetune) or non-parametric(w/ a vector db like\n@weaviate_io\n) memory.\n\ud83d\udcdcResearchers from Microsoft(https://arxiv.org/abs/2312.05934) asked if unsupervised next token prediction finetuning is better than RAG to improve LLM perf. on both seen and unseen QnA tasks?\n\u23e9In Short: RAG is a better way to inject knowledge into LLMs than unsupervised fine-tuning(USFT) and more surprisingly they found that RAG alone is even better than RAG + finetuning. Probably because USFT is not efficiently persisting new knowledge into params.\nWould be cool to see a study comparing RAG vs. SFT/Instruction tuning or RLHF.\nThis improvement in QnA tasks with RAG occurred for both questions in the MMLU dataset as well as on a new dataset of \"current events\" that the model was not trained on.\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Auto-GPT is one of the fastest rising open-source python projects harnessing the power of GPT-4. It chains together \u201cthoughts\u201d and completes various tasks or assignments autonomously. It takes G PT-4 one step further by interacting with large language models, like LangChain."
              }
            ]
          },
          "url": "https://weaviate.io/blog/autogpt-and-weaviate",
          "webPageMainText": "\nEdit (5/Jun/2023): Auto-GPT has temporarily removed support for external vector stores as they refactor their code.\nWe are working on re-introducing the integration. For now, please use this version (https://github.com/Significant-Gravitas/Auto-GPT/tree/v0.3.1) to use Auto-GPT with Weaviate.\nAs generative language models such as GPT-4 continue to push the boundaries of what AI can do, the excitement surrounding its potential is spreading quickly. Many applications and projects are built on top of GPT-4 to extend its capabilities and features. Additionally, many tools were created in order to interact with large language models, like LangChain as an example. Auto-GPT is one of the fastest rising open-source python projects harnessing the power of GPT-4!\nAuto-GPT has gotten a lot of attention lately, with the amount of stars jumping from 20k to 80k in a matter of days. Auto-GPT chains together \u201cthoughts\u201d and completes various tasks or assignments autonomously. It takes GPT-4 one step fu"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is already a very performant and robust vector database. With the recent release of v1.18 we are now bringing vector compression algorithms to Weaviate users everywhere. The main goal of this new feature is to offer similar performance at a fraction of the memory requirements and cost."
              }
            ]
          },
          "url": "https://weaviate.io/blog/ann-algorithms-hnsw-pq",
          "webPageMainText": "\nWeaviate is already a very performant and robust vector database and with the recent release of  v1.18 we are now bringing vector compression algorithms to Weaviate users everywhere. The main goal of this new feature is to offer similar performance at a fraction of the memory requirements and cost. In this blog we expand on the details behind this delicate balance between recall performance and memory management.\nIn our previous blog Vamana vs. HNSW - Exploring ANN algorithms Part 1, we explained the challenges and benefits of the Vamana and HNSW indexing algorithms. However, we did not explain the underlying motivation of moving vectors to disk. In this post we explore:\nWhen indexing, there exist two big chunks of information that utilize massive amounts of memory: vectors and neighborhood graphs.\nWeaviate currently supports vectors of float32. This means we need to allocate 4 bytes, or 32 bits, per stored vector dimension. A database like Sift1M contains 1 million vectors of 128 dim"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The TypeScript client v3 supports Node.js server based development. To develop a browser based application, use the v2 client. If you have older code that uses the JavaScript client, update to the v3 client. The v2 version is still available in npm, however you should not use it to begin new projects."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/typescript#authentication",
          "webPageMainText": "The TypeScript client supports code that is written in TypeScript or JavaScript.\nThe TypeScript client v3 supports Node.js server based development. It does not support browser based web client development. To develop a browser based application, use the v2 client.\nThe v3 client is the current TypeScript client. If you have code written for the v2 client, you should migrate it to v3.\nThe v2 client version is still available in npm, however you should not use it to begin new projects.\nIf you have suggestions or comments on how to improve the new client, let us know:\nThe v3 TypeScript client replaces the v2 JavaScript only client. The JavaScript client is no longer supported. If you have older code that uses the JavaScript client, update to the TypeScript client.\nThese charts show the Weaviate client releases associated with Weaviate core releases.\nSee the client change logs on GitHub.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "We use an AWS CloudFormation template for delivery. You can use AWS Marketplace to directly launch a Weaviate cluster. This will set up the following resources:If you prefer a video, you can watch the following walkthrough. This video is recorded in September 2023, some details may have changed since."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/installation/aws-marketplace",
          "webPageMainText": "You can use AWS Marketplace to directly launch a Weaviate cluster.\nWe use an AWS CloudFormation template for delivery.\nThis will set up the following resources:\nIf you prefer a video, you can watch the following walkthrough. This video is recorded in September 2023, some details may have changed since then.\nNot all settings may be changed after launch. For example, these settings are currently not changeable after launch:\nOnce you open the CloudFormation template, you should see a set of options similar to below.\nHere, you can:\nAfter clicking Create stack, the creation process may take a while, such as around 30 minutes.\nYou can check the status of individual resources in the Events tab. Once the stack has been created, the status for the stack will change to \u2705 CREATE_COMPLETE.\nOnce the stack has been created, you can access the cluster using kubectl, and Weaviate itself using the load balancer.\nYou can run the following command which will update or create a kubeconfig file for the Wea"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate community produces a lot of great content including blog posts, tutorials, and demo applications. To help these reach the broader community, we maintain a curated list of these in our Awesome Weaviate repository. If you would like to share your own work, we would love to hear from you."
              }
            ]
          },
          "url": "https://weaviate.io/developers/contributor-guide/getting-started/writing-blogs",
          "webPageMainText": "The Weaviate community produces a lot of great content including blog posts, tutorials, and demo applications. To help these reach the broader community, we maintain a curated list of these in our Awesome Weaviate repository.\nIf you would like to share your own work, we would love to hear from you. We can help it reach the wider Weaviate community, who will in turn benefit from your work.\nHere are some ideas and tips on how:\nYou could contribute by writing a blog post, or tutorial relating to Weaviate.\nIt could be about anything from your Weaviate journey, concepts you've learnt and used with Weaviate like vector databases, or guides on how to integrate Weaviate with something.\nIt can be hosted anywhere. It could be at a well-known platform such as Medium, Dev.to, or HashNode, or somewhere smaller like your own blog.\nWe ask of your article to:\nYou could also contribute by creating a demo application that uses Weaviate under the hood. It can be a web app, mobile app or demos showing cer"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "GraphQL uses 'metadata' to retrieve data. The fields id, vector, certainty, distance, featureProjection and classification are available by default. Additional properties may be available for each query, depending on the query type as well as enabled Weaviate modules. For examples, see the related how to page."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-properties#classification",
          "webPageMainText": "Various 'additional properties', also called 'metadata', can be retrieved in queries.\nThe fields id, vector, certainty, distance, featureProjection and classification are available by default.\nFurther additional properties may be available for each query, depending on the query type as well as enabled Weaviate modules.\nNote that only the id is available from cross-referenced objects.\nIn GraphQL queries, all additional properties to be retrieved can be set through the reserved _additional{} property.\nEach of the client libraries may handle this differently. See the examples below.\nAn example query getting the UUID and the distance.\nUse the id field to fetch the object UUID.\nUse the vector field to fetch the vector representation of the data object\nThe generate field can be used to perform a generative search.\nA generate query will cause corresponding additional result fields to be available, such as singleResult, groupedResult and error.\nFor examples, see the related how-to page.\nThe re"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/tags/release",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is transitioning from the term \"class\" to \"collection\" Expect to see both terms during the transition period. The \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. Some parameters are mutable after creation, other parameters cannot be changed after collection creation."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/config-refs/schema#invertedindexconfig--indexpropertylength",
          "webPageMainText": "A collection schema describes how to store and index a set of data objects in Weaviate. This page discuses the collection schema, collection parameters and collection configuration.\nWe are transitioning from the term \"class\" to \"collection.\" Expect to see both terms during the transition period.\nAn example of a complete collection object including properties:\nSome parameters are mutable after creation, other parameters cannot be changed after collection creation. To change immutable parameters, delete the collection and recreate it.\nIn Weaviate v1.25, a replication factor cannot be changed once it is set.\nThis is due to the schema consensus algorithm change in v1.25. This will be improved in future versions.\nAfter you create a collection, you can add new properties. You cannot modify existing properties after you create the collection.\nThe \"Auto-schema\" feature generates a collection definition automatically by inferring parameters from data being added. It is enabled by default, and c"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "You can also perform keyword (BM25) searches to find items based on their keyword similarity, or hybrid searches that combine BM25 and semantic/ vector searches. The limit parameter here sets the maximum number of results to return. The return_metadata parameter takes an instance of the MetadataQuery class to set metadata to return in the search results."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/text_searches/keyword_hybrid",
          "webPageMainText": "You can also perform keyword (BM25) searches to find items based on their keyword similarity, or hybrid searches that combine BM25 and semantic/vector searches.\nThis example finds entries in \"Movie\" with the highest keyword search scores for the term \"history\", and prints out the title and release year of the top 5 matches.\nThe results are based on a keyword search score using what's called the BM25f algorithm.\nThe limit parameter here sets the maximum number of results to return.\nThe return_metadata parameter takes an instance of the MetadataQuery class to set metadata to return in the search results. The current query returns the score, which is the BM25 score of the result.\nThis example finds entries in \"Movie\" with the highest hybrid search scores for the term \"history\", and prints out the title and release year of the top 5 matches.\nThe results are based on a hybrid search score. A hybrid search blends results of BM25 and semantic/vector searches.\nThe limit parameter here sets the"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Pagination is not a cursor-based implementation. This has the following implications: The autocut function limits results based on discontinuities in the result set. The query stops returning results after the specified number of jumps. The Get and Explore functions support offset. For more details, see performance considerations."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/additional-operators#autocut",
          "webPageMainText": "Functions such as limit, autocut, and sort modify queries at the class level.\nThe limit argument restricts the number of results. These functions support limit:\nTo return sets of results, \"pages\", use offset and limit together to specify a sub-set of the query response.\nFor example, to list the first ten results, set limit: 10 and offset: 0. To display the next ten results, set offset: 10. To continue iterating over the results, increase the offset again. For more details, see performance considerations\nThe Get and Explore functions support offset.\nPagination is not a cursor-based implementation. This has the following implications:\nThe autocut function limits results based on discontinuities in the result set. Specifically, autocut looks for discontinuities, or jumps, in result metrics such as vector distance or search score.\nTo use autocut, specify how many jumps there should be in your query. The query stops returning results after the specified number of jumps.\nFor example, conside"
        },
        {
          "_additional": {
            "summary": []
          },
          "url": "https://weaviate.io/developers/weaviate/api/rest#tag/objects/head/objects/%7BclassName%7D/%7Bid%7D",
          "webPageMainText": ""
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's Backup feature is designed to work natively with cloud technology. Single node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v 1.16. All service-discovery and authentication-related configuration is set using environment variables."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/backups#s3-aws-or-s3-compatible",
          "webPageMainText": "Weaviate's Backup feature is designed to work natively with cloud technology. Most notably, it allows:\nSingle node backup is available strating in Weaviate v1.15. Multi-node backups is avaiable starting in v1.16.\nIn order to perform backups, a backup provider module must be activated. Multiple backup providers can be active at the same time. Currently backup-s3, backup-gcs, backup-azure, and backup-filesystem modules are available for S3, GCS, Azure or filesystem backups respectively.\nAs it is built on Weaviate's module system, additional providers can be added in the future.\nAll service-discovery and authentication-related configuration is set using\nenvironment variables.\nUse the backup-s3 module to enable backing up to and restoring from any S3-compatible blob storage. This includes AWS S3, and MinIO.\nTo enable the module, add its name to the ENABLE_MODULES environment variable. Modules are comma-separated. To enable the module along with the text2vec-transformers module for example,"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page shows how to create a Weaviate instance using Docker. If you have created a cloud instance of Weaviates, you can skip this page and continue with Communicate with Weaviated. You can provide the OpenAI API key to WeAViate through headers={\"X-OpenAI-Api-Key\": <YOUR_KEY>}."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_text_data/setup_weaviate/create_instance/create_docker",
          "webPageMainText": "If you have created a cloud instance of Weaviate, you can skip this page and continue with Communicate with Weaviate.\nHere, you will create a Weaviate instance using Docker.\nInstall Docker on your machine. We recommend following the official Docker installation guide.\nCreate a new directory and navigate to it in your terminal. Then, create a new file called docker-compose.yml and add the following content:\nRun the following command to start Weaviate:\nOnce the instance is created, you can access it at http://localhost:8080.\nTo connect to the Weaviate instance, use the connect_to_local function.\nSome Weaviate modules can use inference APIs for vectorizing data or large language model integration. You can provide the API keys for these services to Weaviate at instantiation.\nThis course uses OpenAI, so you can provide the OpenAI API key to Weaviate through headers={\"X-OpenAI-Api-Key\": <YOUR_KEY>} as shown below:\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers aggregation queries. They are collectively referred to as Aggregate queries within. An Aggregate query can aggregate over an entire collection, or the results of a search. Each query can include any of the following types of arguments:Each data type has its own set of available aggregated properties."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/aggregate#aggregate-syntax-and-query-structure",
          "webPageMainText": "This page covers aggregation queries. They are collectively referred to as Aggregate queries within.\nAn Aggregate query can aggregate over an entire collection, or the results of a search.\nAn Aggregate query requires the target collection to be specified. Each query can include any of the following types of arguments:\nEach data type has its own set of available aggregated properties. The following table shows the available properties for each data type.\nBelow is an example query to obtain meta information about the Article collection. Note that the data is not grouped here, and results relate to all data objects in the Article collection.\nThe above query will result in something like the following:\nAs such, this Aggregate query will retrieve the total object count in a class.\nYou can use a groupBy argument to get meta information about groups of data objects.\nThe groupBy argument is structured as follows for the Aggregate function:\nIn the following example, the articles are grouped by "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) instance or a local Docker instance is fine for this course. If you're not sure which to choose, we recommend starting with a WCD instance. For this unit, you can choose to create a Weaviate cloud (W CD) instance."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/starter_custom_vectors/setup_weaviate/create_instance",
          "webPageMainText": "For this unit, you can choose to create a Weaviate Cloud (WCD) instance or a local Docker instance.\nEither option is fine for this course. If you're not sure which to choose, we recommend starting with a WCD instance.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The multi2vec-bind module enables Weaviate to use the ImageBind model to vectorize data at import time. To use the module, you must enable it in your Docker Compose file (e.g. docker-compose.yml) The module requires a significant amount of memory to run."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind#additional-search-operators",
          "webPageMainText": "The multi2vec-bind module enables Weaviate to use the ImageBind model to vectorize data at import time.\nKey notes:\nmulti2vec-bind allows Weaviate to generate vectors data containing any number of the following modalities:\nThis module is not available on Weaviate Cloud.\nThe multi2vec-bind module requires a significant amount of memory to run. You may need to increase the memory limit for the multi2vec-bind container to 12 GB or more, such as through Docker Desktop's settings. You can additionally set a limit on your Docker Compose file as shown below, however your Docker Desktop memory limit must be equal to or higher than the limit set in the Docker Compose file.\nTo use multi2vec-bind, you must enable it in your Docker Compose file (e.g. docker-compose.yml).\nWhile you can do so manually, we recommend using the Weaviate configuration tool to generate the Docker Compose file.\nWeaviate:\nInference container:\nThis module will benefit greatly from GPU usage. Make sure to enable CUDA if you h"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "New search engines and databases brilliantly answer queries posed in natural language. The same approach can also be used to search anything from images to DNA. Much of the software involved is open source, so it functions transparently. Clients can retain control of their data, keeping it safely behind their own firewalls."
              }
            ]
          },
          "url": "https://weaviate.io/blog/the-ai-first-database-ecosystem",
          "webPageMainText": "\nA new ecosystem of smaller companies is ushering in a \"third wave\" of AI-first database technology. New search engines and databases brilliantly answer queries posed in natural language, but their machine-learning models are not limited to text searches. The same approach can also be used to search anything from images to DNA.\nMuch of the software involved is open source, so it functions transparently and users can customize it to meet their specific needs. Clients can retain control of their data, keeping it safely behind their own firewalls.\nFirst-wave database technology is often called by the acronym SQL\u2014the initials of a ubiquitous query language used to manage relational databases, which are conceptually similar to spreadsheets or tables. Throughout the 1980s, this technology was dominated by companies like Oracle and Microsoft.\nThe second wave of databases is called \"NoSQL\". These are the domain of companies like MongoDB. They store data in different ways, for example, key-valu"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate is more than just a database. It\u2019s a flexible platform for building powerful, production-ready AI applications. Our open source vector database and surrounding offerings are designed to support developers and teams of all sizes on their AI journey. Get the best of vector and keyword techniques with Weaviate."
              }
            ]
          },
          "url": "https://weaviate.io/#contact-us",
          "webPageMainText": "Bring intuitive applications to life with less  hallucination, data leakage, and vendor lock-in\nImprove search experiences by merging vector and keyword techniques. Deliver contextual, precise results across all of your data in any modality, with less effort.\nBuild trustworthy generative AI applications using your own data, with privacy and security top-of-mind. Surface relevant and accurate answers using your favorite LLMs.\nMake your dataset smarter by enriching it with AI-generated answers. Improve personalization and spend less time on manual data cleaning.\nSoftware development is changing. Our open source vector database and surrounding offerings are designed to support developers and teams of all sizes on their AI journey.\nWeaviate is more than just a database. It\u2019s a flexible platform for building powerful, production-ready AI applications.\nOpen source with a strong community. Resources to help developers of all levels build production-ready AI apps.\nGet the best of vector and ke"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate 1.19 introduces generative cohere module, gRPC API support, improved data types, and more. Weaviate now supports the PaLM models for embeddings and generative search through two new modules. Learn about the intersection between LLMs and Search."
              }
            ]
          },
          "url": "https://weaviate.io/blog/page/5",
          "webPageMainText": "ML Models that can see, read, hear and more!\nAn introductory overview of LlamaIndex, the LLM framework\nLearn about the new native multi-tenancy feature\nLearn about the intersection between LLMs and Search\nThe Weaviate server can be run locally directly from client code\nA discussion on data privacy and privacy-preserving machine learning for LLMs\nDemo on how to ingest PDFs into Weaviate using Unstructured.\nWeaviate now supports the PaLM models for embeddings and generative search through two new modules.\nAn introduction to creating generative feedback loops with LLMs in Weaviate.\nWeaviate 1.19 introduces generative cohere module, gRPC API support, improved data types, and more.\nThe Weaviate Cloud Service is the easiest way to get a Weaviate cluster up and running within minutes. Learn more here.\nA show-and-tell of how we created the Weaviate Retrieval Plugin for ChatGPT\n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud. Use WCD to simplify development and confidently deploy enterprise-ready AI applications. WCD is built on Weaviate core. They share the same technology, and offer the same great features."
              }
            ]
          },
          "url": "https://weaviate.io/developers/wcs#weaviate-enterprise-saas",
          "webPageMainText": "Weaviate Cloud (WCD) is a fully managed vector database in the cloud.\nWCD manages the infrastructure so you can focus on innovation. Use WCD to simplify development and confidently deploy enterprise-ready AI applications.\nWeaviate is more than just a vector database. Weaviate is a scalable, flexible platform. The core, open source project offers vector search, keyword, and hybrid search. It has a plugable architecture to connect with ML models and tools to help you build scalable AI applications.\nWCD is built on Weaviate core. They share the same technology, and offer the same great features. In addition, WCD handles the work of hosting your Weaviate instance. This gets you up and running fast and lets you focus on your application. WCD takes care of the operational details so you don't have to.\nThese pages document the WCD user interface (UI) and WCD specific operational features. For information about the Weaviate database, client APIs, third-party modules, and other features, see th"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page broadly covers the Weaviate Python client (v4 release) The v4 client uses remote procedure calls (RPCs) under-the-hood. The free (sandbox) tier of WCD is compatible with the v4client as of 31 January, 2024."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/client-libraries/python#authentication",
          "webPageMainText": "This page broadly covers the Weaviate Python client (v4 release). For usage information not specific to the Python client, such as code examples, see the relevant pages in the Weaviate documentation. Some frequently used sections are listed here for convenience.\nIf you are migrating from the v3 client to the v4, see this dedicated guide.\nThe Python client library is developed and tested using Python 3.8+. It is available on PyPI.org, and can be installed with:\nThe v4 client uses remote procedure calls (RPCs) under-the-hood. Accordingly, a port for gRPC must be open to your Weaviate server.\nIf you are running Weaviate with Docker, you can map the default port (50051) by adding the following to your docker-compose.yml file:\nThe free (sandbox) tier of WCD is compatible with the v4 client as of 31 January, 2024. Sandboxes created before this date will not be compatible with the v4 client.\nThe v4 client requires Weaviate 1.23.7 or higher. Generally, we encourage you to use the latest versio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This example imports the movie data into our collection. The exact same code that we used for single vector configuration in the multimodal course can be used here. This is because the named vector configuration is set up in the collection definition, and Weaviate handles the rest."
              }
            ]
          },
          "url": "https://weaviate.io/developers/academy/py/named_vectors/nv_collections/import_data",
          "webPageMainText": "This example imports the movie data into our collection.\nAmazingly, the exact same code that we used for single vector configuration in the multimodal course can be used here. This is because the named vector configuration is set up in the collection definition, and Weaviate handles the rest.\nThe code:\nWe won't repeat the explanation of the code here, as it is the same as in the multimodal course. If you would like a refresher, please review the multimodal course.\nWhen the batcher sends the queue to Weaviate, the objects are added to the collection. In our case, the movie collection.\nIn this case, recall that we have three named vectors for each object - title, overview and poster_title. The vectors are generated by the vectorizers that we set up in the collection definition.\nNext, we will explore how these named vectors provide flexibility in searching for our data.\nIf you have any questions or feedback, let us know in the user forum. \n"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Product quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. Starting in v1.23, AutoPQ simplifies configuring PQ on new collections."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/configuration/pq-compression#enable-pq-compression",
          "webPageMainText": "Starting in v1.23, AutoPQ simplifies configuring PQ on new collections.\nProduct quantization (PQ) is a form of data compression for vectors. PQ reduces the memory footprint of a vector index, so enabling PQ for HNSW lets you work with larger datasets. For a discussion of how PQ saves memory, see this page.\nPQ makes tradeoffs between recall, performance, and memory usage. This means a PQ configuration that reduces memory may also reduce recall. There are similar trade-offs when you use HNSW without PQ. If you use PQ compression, you should also tune HNSW so that they compliment each other.\nTo configure HNSW, see Configuration: Vector index .\nPQ is configured at a collection level. There are two ways to enable PQ compression:\nFor new collections, use AutoPQ. AutoPQ automates triggering of the PQ training step based on the size of the collection.\nAutoPQ requires asynchronous indexing.\nSpecify PQ settings for each collection for which it is to be enabled.\nFor additional configuration optio"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "This page covers object-level query functions. They are collectively referred to as Get queries within. A Get query requires the target collection to be specified. Metadata retrieval is optional in both GraphQL and gRPC calls. You can use retrieve groups of objects that match the query. The number of groups and objects per group can be limited."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/api/graphql/get#consistency-levels",
          "webPageMainText": "This page covers object-level query functions. They are collectively referred to as Get queries within.\nA Get query requires the target collection to be specified.\nIn GraphQL calls, the properties to be retrieved to be must be specified explicitly.\nIn gRPC calls, all properties are fetched by default.\nMetadata retrieval is optional in both GraphQL and gRPC calls.\nEach Get query can include any of the following types of arguments:\nThe above query will result in something like the following:\nWithout any arguments, the objects are retrieved according to their ID.\nAccordingly, such a Get query is not suitable for a substantive object retrieval strategy. Consider the Cursor API for that purpose.\nYou can use retrieve groups of objects that match the query.\nThe groups are defined by a property, and the number of groups and objects per group can be limited.\n  The other clients do not yet natively support groupby operations. Please use \"raw\" graphql queries to perform groupby operations.\nWhere "
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Weaviate's v1.17 release introduces replication. Replication enables you to set up your Weaviate environment in a cluster with multiple server nodes. Adding extra database nodes can serve more users simultaneously. Database replication enables zero downtime upgrades, because of no downtime upgrades."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/release-notes/older-releases/release_1_17",
          "webPageMainText": "\nWe are happy to announce the release of Weaviate 1.17, which brings a set of great features, performance improvements, and fixes.\nIf you like your content brief and to the point, here is the TL;DR of this release:\nRead below to learn more about each of these points in more detail.\n\nWeaviate's v1.17 release introduces replication. Replication enables you to set up your Weaviate environment in a cluster with multiple server nodes. Weaviate will automatically replicate data across nodes in the background.\nThis enables a variety of use cases. For example, if a Weaviate node goes down, another node can shoulder the load without losing availability or data. Data in Weaviate will thus have a higher availability for its users.\nSecondly, Replication can improve the throughput of read requests, as you can use all additional nodes to spread the load of queries. Adding extra database nodes can serve more users simultaneously.\nThirdly, database replication enables zero downtime upgrades, because o"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "The Weaviate Hero Program was brought to life to appreciate, recognize & celebrate members in our Community. We are an open-source purpose-built vector database for secure, stateful, explainable generative AI applications. With this global program, we enable members to accelerate their knowledge, skills, and growth in the areas of Vector Databases, Search and AI-native applications."
              }
            ]
          },
          "url": "https://weaviate.io/community",
          "webPageMainText": "We are an open-source purpose-built vector database for secure, stateful, explainable generative AI applications.\nThe Weaviate Hero Program was brought to life to appreciate, recognize & celebrate members in our Community who contribute and engage in ways that make our Community \u201ca great and safe place where people can learn, make friends, and grow. A place for giving and receiving.\u201d\nAnd who ultimately develop and share practices that help individuals in the group thrive. With this global program, we enable members to accelerate their knowledge, skills, and growth in the areas of Vector Databases, Search, and AI-native applications and become thought leaders through their activities and initiatives across the Weaviate Ecosystem.\nBy introducing a company-wide program we adhere to our open-source nature of being transparent, open, and supportive of knowledge sharing. We believe that a culture of giving and sharing leads to better and open innovation and contributes to a great AI landscap"
        },
        {
          "_additional": {
            "summary": [
              {
                "property": "webPageMainText",
                "result": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets. The fusion method and the relative weights are configurable. The search rankings are part of the object metadata. Weaviate uses the score to order the search results. To see the object rankings, set the explain score field in your query."
              }
            ]
          },
          "url": "https://weaviate.io/developers/weaviate/search/hybrid",
          "webPageMainText": "Hybrid search combines the results of a vector search and a keyword (BM25F) search by fusing the two result sets.\nThe fusion method and the relative weights are configurable.\nCombine the results of a vector search and a keyword search. The search uses a single query string.\nThe output is like this:\nA hybrid search on a collection that has named vectors must specify a target vector. Weaviate uses the query vector to search the target vector space.\nThe output is like this:\nTo see the object rankings, set the explain score field in your query. The search rankings are part of the object metadata. Weaviate uses the score to order the search results.\nThe output is like this:\nHybrid search results can favor the keyword component or the vector component. To change the relative weights of the keyword and vector components, set the alpha value in your query.\nThe output is like this:\nRelative Score Fusion is the default fusion method starting in v1.24.\nThe output is like this:\nFor a discussion of"
        }
      ]
    }
  }
}
